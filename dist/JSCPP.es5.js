(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  function setupGlobals(global) {
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
  }
  setupGlobals(global);
  var typeOf = function(x) {
    return typeof x;
  };
  global.$traceurRuntime = {
    options: {},
    setupGlobals: setupGlobals,
    typeof: typeOf
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__3 = $traceurRuntime,
      canonicalizeUrl = $__3.canonicalizeUrl,
      resolveUrl = $__3.resolveUrl,
      isAbsolute = $__3.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some(function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    });
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    var $__2 = this;
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame, index) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            if (index === 1) {
              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);
            } else {
              evaled.push(columnSpacing(m[3]) + '^');
            }
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    });
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {
        return module;
      });
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__2 = arguments;
            var depMap = {};
            deps.forEach(function(dep, index) {
              return depMap[dep] = $__2[index];
            });
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func(), liveModuleSentinel);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  $traceurRuntime.registerModule = ModuleStore.registerModule.bind(ModuleStore);
  $traceurRuntime.getModule = ModuleStore.get;
  $traceurRuntime.setModule = ModuleStore.set;
  $traceurRuntime.normalizeModuleName = ModuleStore.normalize;
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/new-unique-string.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/new-unique-string.js";
  var random = Math.random;
  var counter = Date.now() % 1e9;
  function newUniqueString() {
    return '__$' + (random() * 1e9 >>> 1) + '$' + ++counter + '$__';
  }
  return {get default() {
      return newUniqueString;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/has-native-symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/has-native-symbols.js";
  var v = !!Object.getOwnPropertySymbols && typeof Symbol === 'function';
  function hasNativeSymbol() {
    return v;
  }
  return {get default() {
      return hasNativeSymbol;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/symbols.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var $create = Object.create;
  var $defineProperty = Object.defineProperty;
  var $freeze = Object.freeze;
  var $getOwnPropertyNames = Object.getOwnPropertyNames;
  var $keys = Object.keys;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var SymbolImpl = function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof SymbolImpl))
      return value;
    throw new $TypeError('Symbol cannot be new\'ed');
  };
  $defineProperty(SymbolImpl.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolImpl.prototype, 'toString', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    return symbolValue[symbolInternalProperty];
  }));
  $defineProperty(SymbolImpl.prototype, 'valueOf', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue)
      throw $TypeError('Conversion from symbol to string');
    return symbolValue[symbolInternalProperty];
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    $freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: SymbolImpl.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: SymbolImpl.prototype.valueOf,
    enumerable: false
  });
  $freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s];
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function polyfillSymbol(global) {
    var Object = global.Object;
    if (!hasNativeSymbol()) {
      global.Symbol = SymbolImpl;
      Object.getOwnPropertyNames = getOwnPropertyNames;
      Object.keys = keys;
      $defineProperty(Object, 'getOwnPropertySymbols', nonEnum(getOwnPropertySymbols));
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = global.Symbol('Symbol.iterator');
    }
    if (!global.Symbol.observer) {
      global.Symbol.observer = global.Symbol('Symbol.observer');
    }
  }
  var g = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : (void 0);
  polyfillSymbol(g);
  var typeOf = hasNativeSymbol() ? function(x) {
    return typeof x;
  } : function(x) {
    return x instanceof SymbolValue ? 'symbol' : typeof x;
  };
  return {get typeof() {
      return typeOf;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/typeof.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/typeof.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/typeof.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__.typeof;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/symbols.js";
  var t = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/typeof.js", "traceur-runtime@0.0.111/src/runtime/symbols.js")).default;
  $traceurRuntime.typeof = t;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createClass.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createClass.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols;
  function forEachPropertyKey(object, f) {
    getOwnPropertyNames(object).forEach(f);
    if (getOwnPropertySymbols) {
      getOwnPropertySymbols(object).forEach(f);
    }
  }
  function getDescriptors(object) {
    var descriptors = {};
    forEachPropertyKey(object, function(key) {
      descriptors[key] = getOwnPropertyDescriptor(object, key);
      descriptors[key].enumerable = false;
    });
    return descriptors;
  }
  var nonEnum = {enumerable: false};
  function makePropertiesNonEnumerable(object) {
    forEachPropertyKey(object, function(key) {
      defineProperty(object, key, nonEnum);
    });
  }
  function createClass(ctor, object, staticObject, superClass) {
    defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));
    } else {
      makePropertiesNonEnumerable(object);
      ctor.prototype = object;
    }
    defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  return {get default() {
      return createClass;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js";
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  return {get default() {
      return superConstructor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js";
  var $__0 = Object,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getPrototypeOf = $__0.getPrototypeOf;
  function superDescriptor(homeObject, name) {
    var proto = getPrototypeOf(homeObject);
    do {
      var result = getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  return {get default() {
      return superDescriptor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superGet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superGet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superGet.js")).default;
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      var value = descriptor.value;
      if (value)
        return value;
      if (!descriptor.get)
        return value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  return {get default() {
      return superGet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superSet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superSet.js")).default;
  var $TypeError = TypeError;
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  return {get default() {
      return superSet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/classes.js";
  var createClass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createClass.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superConstructor.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superGet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superGet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superSet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/exportStar.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames;
  function exportStar(object) {
    var $__2 = arguments,
        $__3 = function(i) {
          var mod = $__2[i];
          var names = getOwnPropertyNames(mod);
          var $__5 = function(j) {
            var name = names[j];
            if (name === '__esModule' || name === 'default') {
              return 0;
            }
            defineProperty(object, name, {
              get: function() {
                return mod[name];
              },
              enumerable: true
            });
          },
              $__6;
          $__4: for (var j = 0; j < names.length; j++) {
            $__6 = $__5(j);
            switch ($__6) {
              case 0:
                continue $__4;
            }
          }
        };
    for (var i = 1; i < arguments.length; i++) {
      $__3(i);
    }
    return object;
  }
  return {get default() {
      return exportStar;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/exportStar.js";
  var exportStar = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/exportStar.js", "traceur-runtime@0.0.111/src/runtime/exportStar.js")).default;
  $traceurRuntime.exportStar = exportStar;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-symbol.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-symbol.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/private-symbol.js")).default;
  var $Symbol = typeof Symbol === 'function' ? Symbol : undefined;
  var $getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var $create = Object.create;
  var privateNames = $create(null);
  function isPrivateSymbol(s) {
    return privateNames[s];
  }
  ;
  function createPrivateSymbol() {
    var s = ($Symbol || newUniqueString)();
    privateNames[s] = true;
    return s;
  }
  ;
  function hasPrivate(obj, sym) {
    return hasOwnProperty.call(obj, sym);
  }
  ;
  function deletePrivate(obj, sym) {
    if (!hasPrivate(obj, sym)) {
      return false;
    }
    delete obj[sym];
    return true;
  }
  ;
  function setPrivate(obj, sym, val) {
    obj[sym] = val;
  }
  ;
  function getPrivate(obj, sym) {
    var val = obj[sym];
    if (val === undefined)
      return undefined;
    return hasOwnProperty.call(obj, sym) ? val : undefined;
  }
  ;
  function init() {
    if ($getOwnPropertySymbols) {
      Object.getOwnPropertySymbols = function getOwnPropertySymbols(object) {
        var rv = [];
        var symbols = $getOwnPropertySymbols(object);
        for (var i = 0; i < symbols.length; i++) {
          var symbol = symbols[i];
          if (!isPrivateSymbol(symbol)) {
            rv.push(symbol);
          }
        }
        return rv;
      };
    }
  }
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-weak-map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-weak-map.js";
  var $WeakMap = typeof WeakMap === 'function' ? WeakMap : undefined;
  function isPrivateSymbol(s) {
    return false;
  }
  function createPrivateSymbol() {
    return new $WeakMap();
  }
  function hasPrivate(obj, sym) {
    return sym.has(obj);
  }
  function deletePrivate(obj, sym) {
    return sym.delete(obj);
  }
  function setPrivate(obj, sym, val) {
    sym.set(obj, val);
  }
  function getPrivate(obj, sym) {
    return sym.get(obj);
  }
  function init() {}
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private.js";
  var sym = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-symbol.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var weak = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-weak-map.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var hasWeakMap = typeof WeakMap === 'function';
  var m = hasWeakMap ? weak : sym;
  var isPrivateSymbol = m.isPrivateSymbol;
  var createPrivateSymbol = m.createPrivateSymbol;
  var hasPrivate = m.hasPrivate;
  var deletePrivate = m.deletePrivate;
  var setPrivate = m.setPrivate;
  var getPrivate = m.getPrivate;
  m.init();
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js")),
      getPrivate = $__0.getPrivate,
      setPrivate = $__0.setPrivate,
      createPrivateSymbol = $__0.createPrivateSymbol;
  var $apply = Function.prototype.call.bind(Function.prototype.apply);
  var CONTINUATION_TYPE = Object.create(null);
  var isTailRecursiveName = null;
  function createContinuation(operand, thisArg, argsArray) {
    return [CONTINUATION_TYPE, operand, thisArg, argsArray];
  }
  function isContinuation(object) {
    return object && object[0] === CONTINUATION_TYPE;
  }
  function $bind(operand, thisArg, args) {
    var argArray = [thisArg];
    for (var i = 0; i < args.length; i++) {
      argArray[i + 1] = args[i];
    }
    var func = $apply(Function.prototype.bind, operand, argArray);
    return func;
  }
  function $construct(func, argArray) {
    var object = new ($bind(func, null, argArray));
    return object;
  }
  function isTailRecursive(func) {
    return !!getPrivate(func, isTailRecursiveName);
  }
  function tailCall(func, thisArg, argArray) {
    var continuation = argArray[0];
    if (isContinuation(continuation)) {
      continuation = $apply(func, thisArg, continuation[3]);
      return continuation;
    }
    continuation = createContinuation(func, thisArg, argArray);
    while (true) {
      if (isTailRecursive(func)) {
        continuation = $apply(func, continuation[2], [continuation]);
      } else {
        continuation = $apply(func, continuation[2], continuation[3]);
      }
      if (!isContinuation(continuation)) {
        return continuation;
      }
      func = continuation[1];
    }
  }
  function construct() {
    var object;
    if (isTailRecursive(this)) {
      object = $construct(this, [createContinuation(null, null, arguments)]);
    } else {
      object = $construct(this, arguments);
    }
    return object;
  }
  function setupProperTailCalls() {
    isTailRecursiveName = createPrivateSymbol();
    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {
      var result = tailCall(function(thisArg) {
        var argArray = [];
        for (var i = 1; i < arguments.length; ++i) {
          argArray[i - 1] = arguments[i];
        }
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {
      var result = tailCall(function(thisArg, argArray) {
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
  }
  function initTailRecursiveFunction(func) {
    if (isTailRecursiveName === null) {
      setupProperTailCalls();
    }
    setPrivate(func, isTailRecursiveName, true);
    return func;
  }
  return {
    get createContinuation() {
      return createContinuation;
    },
    get tailCall() {
      return tailCall;
    },
    get construct() {
      return construct;
    },
    get initTailRecursiveFunction() {
      return initTailRecursiveFunction;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.initTailRecursiveFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/call.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/call.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/call.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.tailCall;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/continuation.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/continuation.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/continuation.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.createContinuation;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/construct.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/construct.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/construct.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.construct;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/properTailCalls.js";
  var initTailRecursiveFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initTailRecursiveFunction.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var call = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/call.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var continuation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/continuation.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var construct = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/construct.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  $traceurRuntime.initTailRecursiveFunction = initTailRecursiveFunction;
  $traceurRuntime.call = call;
  $traceurRuntime.continuation = continuation;
  $traceurRuntime.construct = construct;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js";
  var $TypeError = TypeError;
  function checkObjectCoercible(v) {
    if (v === null || v === undefined) {
      throw new $TypeError('Value cannot be converted to an Object');
    }
    return v;
  }
  return {get default() {
      return checkObjectCoercible;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spread.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/modules/spread.js")).default;
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[Symbol.iterator] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[Symbol.iterator]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  return {get default() {
      return spread;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spread.js";
  var spread = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spread.js", "traceur-runtime@0.0.111/src/runtime/spread.js")).default;
  $traceurRuntime.spread = spread;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  return {get default() {
      return iteratorToArray;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/destructuring.js";
  var iteratorToArray = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/iteratorToArray.js", "traceur-runtime@0.0.111/src/runtime/destructuring.js")).default;
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/async.js";
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/async.js")),
      createPrivateSymbol = $__12.createPrivateSymbol,
      getPrivate = $__12.getPrivate,
      setPrivate = $__12.setPrivate;
  var $__11 = Object,
      create = $__11.create,
      defineProperty = $__11.defineProperty;
  var observeName = createPrivateSymbol();
  function AsyncGeneratorFunction() {}
  function AsyncGeneratorFunctionPrototype() {}
  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;
  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;
  defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});
  var AsyncGeneratorContext = function() {
    function AsyncGeneratorContext(observer) {
      var $__2 = this;
      this.decoratedObserver = createDecoratedGenerator(observer, function() {
        $__2.done = true;
      });
      this.done = false;
      this.inReturn = false;
    }
    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {
      throw: function(error) {
        if (!this.inReturn) {
          throw error;
        }
      },
      yield: function(value) {
        if (this.done) {
          this.inReturn = true;
          throw undefined;
        }
        var result;
        try {
          result = this.decoratedObserver.next(value);
        } catch (e) {
          this.done = true;
          throw e;
        }
        if (result === undefined) {
          return;
        }
        if (result.done) {
          this.done = true;
          this.inReturn = true;
          throw undefined;
        }
        return result.value;
      },
      yieldFor: function(observable) {
        var ctx = this;
        return observeForEach(observable[Symbol.observer].bind(observable), function(value) {
          if (ctx.done) {
            this.return();
            return;
          }
          var result;
          try {
            result = ctx.decoratedObserver.next(value);
          } catch (e) {
            ctx.done = true;
            throw e;
          }
          if (result === undefined) {
            return;
          }
          if (result.done) {
            ctx.done = true;
          }
          return result;
        });
      }
    }, {});
  }();
  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {
    var observe = getPrivate(this, observeName);
    var ctx = new AsyncGeneratorContext(observer);
    schedule(function() {
      return observe(ctx);
    }).then(function(value) {
      if (!ctx.done) {
        ctx.decoratedObserver.return(value);
      }
    }).catch(function(error) {
      if (!ctx.done) {
        ctx.decoratedObserver.throw(error);
      }
    });
    return ctx.decoratedObserver;
  };
  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});
  function initAsyncGeneratorFunction(functionObject) {
    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;
    return functionObject;
  }
  function createAsyncGeneratorInstance(observe, functionObject) {
    for (var args = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      args[$__10 - 2] = arguments[$__10];
    var object = create(functionObject.prototype);
    setPrivate(object, observeName, observe);
    return object;
  }
  function observeForEach(observe, next) {
    return new Promise(function(resolve, reject) {
      var generator = observe({
        next: function(value) {
          return next.call(generator, value);
        },
        throw: function(error) {
          reject(error);
        },
        return: function(value) {
          resolve(value);
        }
      });
    });
  }
  function schedule(asyncF) {
    return Promise.resolve().then(asyncF);
  }
  var generator = Symbol();
  var onDone = Symbol();
  var DecoratedGenerator = function() {
    function DecoratedGenerator(_generator, _onDone) {
      this[generator] = _generator;
      this[onDone] = _onDone;
    }
    return ($traceurRuntime.createClass)(DecoratedGenerator, {
      next: function(value) {
        var result = this[generator].next(value);
        if (result !== undefined && result.done) {
          this[onDone].call(this);
        }
        return result;
      },
      throw: function(error) {
        this[onDone].call(this);
        return this[generator].throw(error);
      },
      return: function(value) {
        this[onDone].call(this);
        return this[generator].return(value);
      }
    }, {});
  }();
  function createDecoratedGenerator(generator, onDone) {
    return new DecoratedGenerator(generator, onDone);
  }
  Array.prototype[Symbol.observer] = function(observer) {
    var done = false;
    var decoratedObserver = createDecoratedGenerator(observer, function() {
      return done = true;
    });
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      for (var $__4 = void 0,
          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        var value = $__4.value;
        {
          decoratedObserver.next(value);
          if (done) {
            return;
          }
        }
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
    decoratedObserver.return();
    return decoratedObserver;
  };
  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});
  return {
    get initAsyncGeneratorFunction() {
      return initAsyncGeneratorFunction;
    },
    get createAsyncGeneratorInstance() {
      return createAsyncGeneratorInstance;
    },
    get observeForEach() {
      return observeForEach;
    },
    get schedule() {
      return schedule;
    },
    get createDecoratedGenerator() {
      return createDecoratedGenerator;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.initAsyncGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createAsyncGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.observeForEach;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/schedule.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/schedule.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/schedule.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.schedule;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createDecoratedGenerator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/async.js";
  var initAsyncGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initAsyncGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createAsyncGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createAsyncGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var observeForEach = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/observeForEach.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var schedule = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/schedule.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createDecoratedGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createDecoratedGenerator.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;
  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;
  $traceurRuntime.observeForEach = observeForEach;
  $traceurRuntime.schedule = schedule;
  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/generators.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/generators.js")),
      createPrivateSymbol = $__2.createPrivateSymbol,
      getPrivate = $__2.getPrivate,
      setPrivate = $__2.setPrivate;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    maybeUncatchable: function() {
      if (this.storedException === RETURN_SENTINEL) {
        throw RETURN_SENTINEL;
      }
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateSymbol();
  var moveNextName = createPrivateSymbol();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'throw', v);
    },
    return: function(v) {
      var ctx = getPrivate(this, ctxName);
      ctx.oldReturnValue = ctx.returnValue;
      ctx.returnValue = v;
      return nextOrThrow(ctx, getPrivate(this, moveNextName), 'throw', RETURN_SENTINEL);
    }
  };
  defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = create(functionObject.prototype);
    setPrivate(object, ctxName, ctx);
    setPrivate(object, moveNextName, moveNext);
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  return {
    get createGeneratorInstance() {
      return createGeneratorInstance;
    },
    get initGeneratorFunction() {
      return initGeneratorFunction;
    },
    get asyncWrap() {
      return asyncWrap;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.asyncWrap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.initGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.createGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/generators.js";
  var asyncWrap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/asyncWrap.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var initGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var createGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spawn.js";
  function spawn(self, args, gen) {
    return new Promise(function(resolve, reject) {
      function fulfill(v) {
        try {
          step(gen.next(v));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(v) {
        try {
          step(gen.throw(v));
        } catch (e) {
          reject(e);
        }
      }
      function step(res) {
        if (res.done) {
          resolve(res.value);
        } else {
          Promise.resolve(res.value).then(fulfill, rejected);
        }
      }
      step((gen = gen.apply(self, args)).next());
    });
  }
  return {get default() {
      return spawn;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spawn.js";
  var spawn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spawn.js", "traceur-runtime@0.0.111/src/runtime/spawn.js")).default;
  $traceurRuntime.spawn = spawn;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      freeze = $__1.freeze;
  var slice = Array.prototype.slice;
  var map = Object.create(null);
  function getTemplateObject(raw) {
    var cooked = arguments[1];
    var key = raw.join('${}');
    var templateObject = map[key];
    if (templateObject)
      return templateObject;
    if (!cooked) {
      cooked = slice.call(raw);
    }
    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));
  }
  return {get default() {
      return getTemplateObject;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/template.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/template.js";
  var getTemplateObject = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/getTemplateObject.js", "traceur-runtime@0.0.111/src/runtime/template.js")).default;
  $traceurRuntime.getTemplateObject = getTemplateObject;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols,
      propertyIsEnumerable = $__1.propertyIsEnumerable;
  function createDataProperty(o, p, v) {
    defineProperty(o, p, {
      configurable: true,
      enumerable: true,
      value: v,
      writable: true
    });
  }
  function copyDataProperties(target, source) {
    if (source == null) {
      return;
    }
    var copy = function(keys) {
      for (var i = 0; i < keys.length; i++) {
        var nextKey = keys[i];
        if (propertyIsEnumerable.call(source, nextKey)) {
          var propValue = source[nextKey];
          createDataProperty(target, nextKey, propValue);
        }
      }
    };
    copy(getOwnPropertyNames(source));
    copy(getOwnPropertySymbols(source));
  }
  var $__default = function() {
    var target = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      copyDataProperties(target, arguments[i]);
    }
    return target;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/jsx.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/jsx.js";
  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spreadProperties.js", "traceur-runtime@0.0.111/src/runtime/jsx.js")).default;
  $traceurRuntime.spreadProperties = spreadProperties;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/runtime-modules.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./classes.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./exportStar.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./relativeRequire.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spread.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./destructuring.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spawn.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./template.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./jsx.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/frozen-data.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/frozen-data.js";
  function findIndex(arr, key) {
    for (var i = 0; i < arr.length; i += 2) {
      if (arr[i] === key) {
        return i;
      }
    }
    return -1;
  }
  function setFrozen(arr, key, val) {
    var i = findIndex(arr, key);
    if (i === -1) {
      arr.push(key, val);
    }
  }
  function getFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      return arr[i + 1];
    }
    return undefined;
  }
  function hasFrozen(arr, key) {
    return findIndex(arr, key) !== -1;
  }
  function deleteFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      arr.splice(i, 2);
      return true;
    }
    return false;
  }
  return {
    get setFrozen() {
      return setFrozen;
    },
    get getFrozen() {
      return getFrozen;
    },
    get hasFrozen() {
      return hasFrozen;
    },
    get deleteFrozen() {
      return deleteFrozen;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var $TypeError = TypeError;
  var $Object = Object;
  function toObject(x) {
    if (x == null) {
      throw $TypeError();
    }
    return $Object(x);
  }
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach(function(f) {
      return f(global);
    });
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js";
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      createPrivateSymbol = $__16.createPrivateSymbol,
      getPrivate = $__16.getPrivate,
      setPrivate = $__16.setPrivate;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      deleteFrozen = $__17.deleteFrozen,
      getFrozen = $__17.getFrozen,
      setFrozen = $__17.setFrozen;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")).default;
  var $__9 = Object,
      defineProperty = $__9.defineProperty,
      getOwnPropertyDescriptor = $__9.getOwnPropertyDescriptor,
      hasOwnProperty = $__9.hasOwnProperty,
      isExtensible = $__9.isExtensible;
  var deletedSentinel = {};
  var counter = 1;
  var hashCodeName = createPrivateSymbol();
  function getHashCodeForObject(obj) {
    return getPrivate(obj, hashCodeName);
  }
  function getOrSetHashCodeForObject(obj) {
    var hash = getHashCodeForObject(obj);
    if (!hash) {
      hash = counter++;
      setPrivate(obj, hashCodeName, hash);
    }
    return hash;
  }
  function lookupIndex(map, key) {
    if (typeof key === 'string') {
      return map.stringIndex_[key];
    }
    if (isObject(key)) {
      if (!isExtensible(key)) {
        return getFrozen(map.frozenData_, key);
      }
      var hc = getHashCodeForObject(key);
      if (hc === undefined) {
        return undefined;
      }
      return map.objectIndex_[hc];
    }
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.frozenData_ = [];
    map.deletedCount_ = 0;
  }
  var Map = function() {
    function Map() {
      var $__11,
          $__12;
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Map called on incompatible type');
      if (hasOwnProperty.call(this, 'entries_')) {
        throw new TypeError('Map can not be reentrantly initialised');
      }
      initMap(this);
      if (iterable !== null && iterable !== undefined) {
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (iterable)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__10 = $__3.value,
                key = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
                value = ($__12 = $__11.next()).done ? void 0 : $__12.value;
            {
              this.set(key, value);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Map, {
      get size() {
        return this.entries_.length / 2 - this.deletedCount_;
      },
      get: function(key) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          return this.entries_[index + 1];
        }
      },
      set: function(key, value) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          this.entries_[index + 1] = value;
        } else {
          index = this.entries_.length;
          this.entries_[index] = key;
          this.entries_[index + 1] = value;
          if (isObject(key)) {
            if (!isExtensible(key)) {
              setFrozen(this.frozenData_, key, index);
            } else {
              var hash = getOrSetHashCodeForObject(key);
              this.objectIndex_[hash] = index;
            }
          } else if (typeof key === 'string') {
            this.stringIndex_[key] = index;
          } else {
            this.primitiveIndex_[key] = index;
          }
        }
        return this;
      },
      has: function(key) {
        return lookupIndex(this, key) !== undefined;
      },
      delete: function(key) {
        var index = lookupIndex(this, key);
        if (index === undefined) {
          return false;
        }
        this.entries_[index] = deletedSentinel;
        this.entries_[index + 1] = undefined;
        this.deletedCount_++;
        if (isObject(key)) {
          if (!isExtensible(key)) {
            deleteFrozen(this.frozenData_, key);
          } else {
            var hash = getHashCodeForObject(key);
            delete this.objectIndex_[hash];
          }
        } else if (typeof key === 'string') {
          delete this.stringIndex_[key];
        } else {
          delete this.primitiveIndex_[key];
        }
        return true;
      },
      clear: function() {
        initMap(this);
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        for (var i = 0; i < this.entries_.length; i += 2) {
          var key = this.entries_[i];
          var value = this.entries_[i + 1];
          if (key === deletedSentinel)
            continue;
          callbackFn.call(thisArg, value, key, this);
        }
      },
      entries: $traceurRuntime.initGeneratorFunction(function $__13() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return [key, value];
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__13, this);
      }),
      keys: $traceurRuntime.initGeneratorFunction(function $__14() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return key;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__14, this);
      }),
      values: $traceurRuntime.initGeneratorFunction(function $__15() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return value;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function needsPolyfill(global) {
    var $__10 = global,
        Map = $__10.Map,
        Symbol = $__10.Symbol;
    if (!Map || !hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {
      return true;
    }
    try {
      return new Map([[]]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillMap(global) {
    if (needsPolyfill(global)) {
      global.Map = Map;
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js";
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var Map = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Map.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).Map;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).default;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var Set = function() {
    function Set() {
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Set called on incompatible type');
      if (hasOwnProperty.call(this, 'map_')) {
        throw new TypeError('Set can not be reentrantly initialised');
      }
      this.map_ = new Map();
      if (iterable !== null && iterable !== undefined) {
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var item = $__4.value;
            {
              this.add(item);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Set, {
      get size() {
        return this.map_.size;
      },
      has: function(key) {
        return this.map_.has(key);
      },
      add: function(key) {
        this.map_.set(key, key);
        return this;
      },
      delete: function(key) {
        return this.map_.delete(key);
      },
      clear: function() {
        return this.map_.clear();
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        var $__2 = this;
        return this.map_.forEach(function(value, key) {
          callbackFn.call(thisArg, key, key, $__2);
        });
      },
      values: $traceurRuntime.initGeneratorFunction(function $__12() {
        var $__13,
            $__14;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__13 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__14.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__14.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__14.value;
              default:
                return $ctx.end();
            }
        }, $__12, this);
      }),
      entries: $traceurRuntime.initGeneratorFunction(function $__15() {
        var $__16,
            $__17;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__16 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__17 = $__16[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__17.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__17.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__17.value;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function needsPolyfill(global) {
    var $__11 = global,
        Set = $__11.Set,
        Symbol = $__11.Symbol;
    if (!Set || !hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {
      return true;
    }
    try {
      return new Set([1]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillSet(global) {
    if (needsPolyfill(global)) {
      global.Set = Set;
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  var toString = {}.toString;
  var vertxNext;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var browserWindow = (typeof window !== 'undefined') ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    var nextTick = process.nextTick;
    var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
      nextTick = setImmediate;
    }
    return function() {
      nextTick(flush);
    };
  }
  function useVertxTimer() {
    return function() {
      vertxNext(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  function attemptVertex() {
    try {
      var r = require;
      var vertx = r('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }
  var scheduleFlush;
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === 'function') {
    scheduleFlush = attemptVertex();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return asap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js";
  var async = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../../node_modules/rsvp/lib/rsvp/asap.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")).default;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      isObject = $__9.isObject,
      registerPolyfill = $__9.registerPolyfill;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      createPrivateSymbol = $__10.createPrivateSymbol,
      getPrivate = $__10.getPrivate,
      setPrivate = $__10.setPrivate;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: function(x) {
          promiseResolve(promise, x);
        },
        reject: function(r) {
          promiseReject(promise, r);
        }
      };
    } else {
      var result = {};
      result.promise = new C(function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      });
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function() {
    function Promise(resolver) {
      if (resolver === promiseRaw)
        return;
      if (typeof resolver !== 'function')
        throw new TypeError;
      var promise = promiseInit(this);
      try {
        resolver(function(x) {
          promiseResolve(promise, x);
        }, function(r) {
          promiseReject(promise, r);
        });
      } catch (e) {
        promiseReject(promise, e);
      }
    }
    return ($traceurRuntime.createClass)(Promise, {
      catch: function(onReject) {
        return this.then(undefined, onReject);
      },
      then: function(onResolve, onReject) {
        if (typeof onResolve !== 'function')
          onResolve = idResolveHandler;
        if (typeof onReject !== 'function')
          onReject = idRejectHandler;
        var that = this;
        var constructor = this.constructor;
        return chain(this, function(x) {
          x = promiseCoerce(constructor, x);
          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
        }, onReject);
      }
    }, {
      resolve: function(x) {
        if (this === $Promise) {
          if (isPromise(x)) {
            return x;
          }
          return promiseSet(new $Promise(promiseRaw), +1, x);
        } else {
          return new this(function(resolve, reject) {
            resolve(x);
          });
        }
      },
      reject: function(r) {
        if (this === $Promise) {
          return promiseSet(new $Promise(promiseRaw), -1, r);
        } else {
          return new this(function(resolve, reject) {
            reject(r);
          });
        }
      },
      all: function(values) {
        var deferred = getDeferred(this);
        var resolutions = [];
        try {
          var makeCountdownFunction = function(i) {
            return function(x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            };
          };
          var count = 0;
          var i = 0;
          var $__4 = true;
          var $__5 = false;
          var $__6 = undefined;
          try {
            for (var $__2 = void 0,
                $__1 = (values)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
              var value = $__2.value;
              {
                var countdownFunction = makeCountdownFunction(i);
                this.resolve(value).then(countdownFunction, function(r) {
                  deferred.reject(r);
                });
                ++i;
                ++count;
              }
            }
          } catch ($__7) {
            $__5 = true;
            $__6 = $__7;
          } finally {
            try {
              if (!$__4 && $__1.return != null) {
                $__1.return();
              }
            } finally {
              if ($__5) {
                throw $__6;
              }
            }
          }
          if (count === 0) {
            deferred.resolve(resolutions);
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      },
      race: function(values) {
        var deferred = getDeferred(this);
        try {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(x) {
              deferred.resolve(x);
            }, function(r) {
              deferred.reject(r);
            });
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    });
  }();
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async(function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    });
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = createPrivateSymbol();
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        setPrivate(x, thenableSymbol, promise);
        return promise;
      }
      if (typeof then === 'function') {
        var p = getPrivate(x, thenableSymbol);
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          setPrivate(x, thenableSymbol, deferred.promise);
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js")),
      createIteratorResultObject = $__3.createIteratorResultObject,
      isObject = $__3.isObject;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function() {
    var $__1;
    function StringIterator() {}
    return ($traceurRuntime.createClass)(StringIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var o = this;
        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
          throw new TypeError('this must be a StringIterator object');
        }
        var s = o[iteratedString];
        if (s === undefined) {
          return createIteratorResultObject(undefined, true);
        }
        var position = o[stringIteratorNextIndex];
        var len = s.length;
        if (position >= len) {
          o[iteratedString] = undefined;
          return createIteratorResultObject(undefined, true);
        }
        var first = s.charCodeAt(position);
        var resultString;
        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
          resultString = String.fromCharCode(first);
        } else {
          var second = s.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) {
            resultString = String.fromCharCode(first);
          } else {
            resultString = String.fromCharCode(first) + String.fromCharCode(second);
          }
        }
        o[stringIteratorNextIndex] = position + resultString.length;
        return createIteratorResultObject(resultString, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[iteratedString] = s;
    iterator[stringIteratorNextIndex] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/String.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).default;
  var createStringIterator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StringIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).createStringIterator;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      maybeAddIterator = $__3.maybeAddIterator,
      registerPolyfill = $__3.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint(_) {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js")),
      toObject = $__2.toObject,
      toUint32 = $__2.toUint32,
      createIteratorResultObject = $__2.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function() {
    var $__1;
    function ArrayIterator() {}
    return ($traceurRuntime.createClass)(ArrayIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var iterator = toObject(this);
        var array = iterator.iteratorObject_;
        if (!array) {
          throw new TypeError('Object is not an ArrayIterator');
        }
        var index = iterator.arrayIteratorNextIndex_;
        var itemKind = iterator.arrayIterationKind_;
        var length = toUint32(array.length);
        if (index >= length) {
          iterator.arrayIteratorNextIndex_ = Infinity;
          return createIteratorResultObject(undefined, true);
        }
        iterator.arrayIteratorNextIndex_ = index + 1;
        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
          return createIteratorResultObject(array[index], false);
        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
          return createIteratorResultObject([index, array[index]], false);
        return createIteratorResultObject(index, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js";
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrayIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      entries = $__9.entries,
      keys = $__9.keys,
      jsValues = $__9.values;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      checkIterable = $__10.checkIterable,
      isCallable = $__10.isCallable,
      isConstructor = $__10.isConstructor,
      maybeAddFunctions = $__10.maybeAddFunctions,
      maybeAddIterator = $__10.maybeAddIterator,
      registerPolyfill = $__10.registerPolyfill,
      toInteger = $__10.toInteger,
      toLength = $__10.toLength,
      toObject = $__10.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (items)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var item = $__1.value;
          {
            if (mapping) {
              arr[k] = mapFn.call(thisArg, item, k);
            } else {
              arr[k] = item;
            }
            k++;
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__7 = 0; $__7 < arguments.length; $__7++)
      items[$__7] = arguments[$__7];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__8 = global,
        Array = $__8.Array,
        Object = $__8.Object,
        Symbol = $__8.Symbol;
    var values = jsValues;
    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {
      values = Array.prototype[Symbol.iterator];
    }
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/assign.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/assign.js";
  var keys = Object.keys;
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        target[name] = source[name];
      }
    }
    return target;
  }
  return {get default() {
      return assign;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")),
      maybeAddFunctions = $__2.maybeAddFunctions,
      registerPolyfill = $__2.registerPolyfill;
  var assign = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./assign.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")).default;
  var $__0 = Object,
      defineProperty = $__0.defineProperty,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__0.getOwnPropertyNames;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get assign() {
      return assign;
    },
    get is() {
      return is;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js")),
      isNumber = $__1.isNumber,
      maybeAddConsts = $__1.maybeAddConsts,
      maybeAddFunctions = $__1.maybeAddFunctions,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/fround.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/fround.js";
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      LN2 = $__0.LN2,
      abs = $__0.abs,
      floor = $__0.floor,
      log = $__0.log,
      min = $__0.min,
      pow = $__0.pow;
  function packIEEE754(v, ebits, fbits) {
    var bias = (1 << (ebits - 1)) - 1,
        s,
        e,
        f,
        ln,
        i,
        bits,
        str,
        bytes;
    function roundToEven(n) {
      var w = floor(n),
          f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }
    if (v !== v) {
      e = (1 << ebits) - 1;
      f = pow(2, fbits - 1);
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);
      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }
    bits = [];
    for (i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }
  function unpackIEEE754(bytes, ebits, fbits) {
    var bits = [],
        i,
        j,
        b,
        str,
        bias,
        s,
        e,
        f;
    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0);
        b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }
  function unpackF32(b) {
    return unpackIEEE754(b, 8, 23);
  }
  function packF32(v) {
    return packIEEE754(v, 8, 23);
  }
  function fround(x) {
    if (x === 0 || !$isFinite(x) || $isNaN(x)) {
      return x;
    }
    return unpackF32(packF32(Number(x)));
  }
  return {get fround() {
      return fround;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js";
  var jsFround = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fround.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")).fround;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      registerPolyfill = $__3.registerPolyfill,
      toUint32 = $__3.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      abs = $__0.abs,
      ceil = $__0.ceil,
      exp = $__0.exp,
      floor = $__0.floor,
      log = $__0.log,
      pow = $__0.pow,
      sqrt = $__0.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var fround,
      f32;
  if (typeof Float32Array === 'function') {
    f32 = new Float32Array(1);
    fround = function(x) {
      f32[0] = Number(x);
      return f32[0];
    };
  } else {
    fround = jsFround;
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      hasFrozen = $__6.hasFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var sentinel = {};
  var WeakMap = function() {
    function WeakMap() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakMap, {
      set: function(key, value) {
        if (!isObject(key))
          throw new $TypeError('key must be an object');
        if (!isExtensible(key)) {
          setFrozen(this.frozenData_, key, value);
        } else {
          setPrivate(key, this.name_, value);
        }
        return this;
      },
      get: function(key) {
        if (!isObject(key))
          return undefined;
        if (!isExtensible(key)) {
          return getFrozen(this.frozenData_, key);
        }
        return getPrivate(key, this.name_);
      },
      delete: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return deleteFrozen(this.frozenData_, key);
        }
        return deletePrivate(key, this.name_);
      },
      has: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return hasFrozen(this.frozenData_, key);
        }
        return hasPrivate(key, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakMap = $__4.WeakMap,
        Symbol = $__4.Symbol;
    if (!WeakMap || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakMap([[o, false]]);
      return wm.get(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakMap(global) {
    if (needsPolyfill(global)) {
      global.WeakMap = WeakMap;
    }
  }
  registerPolyfill(polyfillWeakMap);
  return {
    get WeakMap() {
      return WeakMap;
    },
    get polyfillWeakMap() {
      return polyfillWeakMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var WeakSet = function() {
    function WeakSet() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakSet, {
      add: function(value) {
        if (!isObject(value))
          throw new $TypeError('value must be an object');
        if (!isExtensible(value)) {
          setFrozen(this.frozenData_, value, value);
        } else {
          setPrivate(value, this.name_, true);
        }
        return this;
      },
      delete: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return deleteFrozen(this.frozenData_, value);
        }
        return deletePrivate(value, this.name_);
      },
      has: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return getFrozen(this.frozenData_, value) === value;
        }
        return hasPrivate(value, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakSet = $__4.WeakSet,
        Symbol = $__4.Symbol;
    if (!WeakSet || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakSet([[o]]);
      return !wm.has(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakSet(global) {
    if (needsPolyfill(global)) {
      global.WeakSet = WeakSet;
    }
  }
  registerPolyfill(polyfillWeakSet);
  return {
    get WeakSet() {
      return WeakSet;
    },
    get polyfillWeakSet() {
      return polyfillWeakSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js";
  var polyfillAll = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js")).polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js" + '');
;(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a)
          return a(o, !0);
        if (i)
          return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }
      var l = n[o] = {exports: {}};
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++)
    s(r[o]);
  return s;
})({
  1: [function(require, module, exports) {
    module.exports = (function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            parser = this,
            peg$FAILED = {},
            peg$startRuleFunctions = {TranslationUnit: peg$parseTranslationUnit},
            peg$startRuleFunction = peg$parseTranslationUnit,
            peg$c0 = function(a) {
              return addPositionInfo({
                type: 'TranslationUnit',
                ExternalDeclarations: a
              });
            },
            peg$c1 = function(a, b) {
              return addPositionInfo({
                type: 'NamespaceDefinition',
                Identifier: a,
                ExternalDeclarations: b
              });
            },
            peg$c2 = function(a) {
              return addPositionInfo({
                type: 'UsingDirective',
                Identifier: a
              });
            },
            peg$c3 = function(a, b) {
              return addPositionInfo({
                type: 'UsingDeclaration',
                scope: a,
                Identifier: b
              });
            },
            peg$c4 = function(a, b) {
              return addPositionInfo({
                type: 'NamespaceAliasDefinition',
                target: b,
                Identifier: a
              });
            },
            peg$c5 = function(a, b) {
              return a;
            },
            peg$c6 = function(a, b, c) {
              return addPositionInfo({
                type: 'TypedefDeclaration',
                DeclarationSpecifiers: a,
                Declarators: [b].concat(c)
              });
            },
            peg$c7 = function(a, b_pointer, b) {
              return null;
            },
            peg$c8 = function(a, b_pointer, b, c) {
              b.Pointer = b_pointer;
              return addPositionInfo({
                type: 'FunctionDefinition',
                DeclarationSpecifiers: a,
                Declarator: b,
                CompoundStatement: c
              });
            },
            peg$c9 = function(a) {
              return addPositionInfo({
                type: 'DeclarationList',
                Declarations: a
              });
            },
            peg$c10 = function(a) {
              return addPositionInfo({
                type: 'Label_case',
                ConstantExpression: a
              });
            },
            peg$c11 = function() {
              return addPositionInfo({type: 'Label_default'});
            },
            peg$c12 = function(a) {
              return addPositionInfo({
                type: 'CompoundStatement',
                Statements: a
              });
            },
            peg$c13 = function(a) {
              return addPositionInfo({
                type: 'ExpressionStatement',
                Expression: a
              });
            },
            peg$c14 = function(a, b, c) {
              return addPositionInfo({
                type: 'SelectionStatement_if',
                Expression: a,
                Statement: b,
                ElseStatement: c ? c[1] : null
              });
            },
            peg$c15 = function(a, b) {
              return addPositionInfo({
                type: 'SelectionStatement_switch',
                Expression: a,
                Statement: b
              });
            },
            peg$c16 = function(a, b) {
              return addPositionInfo({
                type: 'IterationStatement_while',
                Expression: a,
                Statement: b
              });
            },
            peg$c17 = function(a, b) {
              return addPositionInfo({
                type: 'IterationStatement_do',
                Expression: b,
                Statement: a
              });
            },
            peg$c18 = function(a, c, d, e) {
              return addPositionInfo({
                type: 'IterationStatement_for',
                Initializer: a,
                Expression: c,
                Loop: d,
                Statement: e
              });
            },
            peg$c19 = function(a) {
              return addPositionInfo({
                type: 'JumpStatement_goto',
                Identifier: a
              });
            },
            peg$c20 = function() {
              return addPositionInfo({type: 'JumpStatement_continue'});
            },
            peg$c21 = function() {
              return addPositionInfo({type: 'JumpStatement_break'});
            },
            peg$c22 = function(a) {
              return addPositionInfo({
                type: 'JumpStatement_return',
                Expression: a
              });
            },
            peg$c23 = function(a, b) {
              return addPositionInfo({
                type: 'Declaration',
                DeclarationSpecifiers: a,
                InitDeclaratorList: b
              });
            },
            peg$c24 = function(a, b, c) {
              return a.concat([b]).concat(c);
            },
            peg$c25 = function(a) {
              return a;
            },
            peg$c26 = function(a) {
              return a;
            },
            peg$c27 = function(a) {
              return a;
            },
            peg$c28 = function(a, x) {
              return x;
            },
            peg$c29 = function(a, b) {
              return [a].concat(b);
            },
            peg$c30 = function(a, b) {
              return addPositionInfo({
                type: 'InitDeclarator',
                Declarator: a,
                Initializers: b
              });
            },
            peg$c31 = function(a) {
              return a;
            },
            peg$c32 = function(a) {
              return addPositionInfo({
                type: 'Identifier',
                Identifier: a
              });
            },
            peg$c33 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_ParameterTypeList',
                ParameterTypeList: a
              });
            },
            peg$c34 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator',
                left: a,
                right: b
              });
            },
            peg$c35 = function(a, b) {
              b.Pointer = a;
              return b;
            },
            peg$c36 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_array',
                Modifier: a || [],
                Expression: b
              });
            },
            peg$c37 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_array',
                Modifier: ['static'].concat(a),
                Expression: b
              });
            },
            peg$c38 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_star_array',
                Modifier: a.concat['*']
              });
            },
            peg$c39 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_IdentifierList',
                IdentifierList: a
              });
            },
            peg$c40 = function(a, b) {
              return addPositionInfo({
                type: 'ParameterTypeList',
                ParameterList: a,
                varargs: b !== null
              });
            },
            peg$c41 = function(a, b) {
              if (a)
                return [a].concat(b);
              else
                return b;
            },
            peg$c42 = function(a, b) {
              return addPositionInfo({
                type: 'ParameterDeclaration',
                DeclarationSpecifiers: a,
                Declarator: b
              });
            },
            peg$c43 = function(a, b) {
              return addPositionInfo({
                type: 'TypeName',
                base: a,
                extra: b
              });
            },
            peg$c44 = function(a) {
              return addPositionInfo({
                type: 'AbstractDeclarator',
                Pointer: a
              });
            },
            peg$c45 = function(a) {
              return addPositionInfo({
                type: 'Initializer_expr',
                Expression: a
              });
            },
            peg$c46 = function(a) {
              return addPositionInfo({
                type: 'Initializer_array',
                Initializers: a
              });
            },
            peg$c47 = function(a, b) {
              return [a].concat(b);
            },
            peg$c48 = function(a) {
              return addPositionInfo({
                type: 'IdentifierExpression',
                Identifier: a
              });
            },
            peg$c49 = function(a) {
              return addPositionInfo({
                type: 'ConstantExpression',
                Expression: a
              });
            },
            peg$c50 = function(a) {
              return addPositionInfo({
                type: 'StringLiteralExpression',
                value: a
              });
            },
            peg$c51 = function(a) {
              return addPositionInfo({
                type: 'ParenthesesExpression',
                Expression: a
              });
            },
            peg$c52 = function(a, c) {
              return [0, c];
            },
            peg$c53 = function(a, c) {
              return [1, c ? c : []];
            },
            peg$c54 = function(a, c) {
              return [2, c];
            },
            peg$c55 = function(a, c) {
              return [3, c];
            },
            peg$c56 = function(a, c) {
              return [4];
            },
            peg$c57 = function(a, c) {
              return [5];
            },
            peg$c58 = function(a, b) {
              if (b.length > 0) {
                var ret = addPositionInfo({Expression: a});
                for (var i = 0; i < b.length; i++) {
                  var o = b[i][1];
                  switch (b[i][0]) {
                    case 0:
                      ret.type = 'PostfixExpression_ArrayAccess';
                      ret.index = o;
                      break;
                    case 1:
                      ret.type = 'PostfixExpression_MethodInvocation';
                      ret.args = o;
                      break;
                    case 2:
                      ret.type = 'PostfixExpression_MemberAccess';
                      ret.member = o;
                      break;
                    case 3:
                      ret.type = 'PostfixExpression_MemberPointerAccess';
                      ret.member = o;
                      break;
                    case 4:
                      ret.type = 'PostfixExpression_PostIncrement';
                      break;
                    case 5:
                      ret.type = 'PostfixExpression_PostDecrement';
                      break;
                  }
                  ret = addPositionInfo({Expression: ret});
                }
                return ret.Expression;
              } else
                return a;
            },
            peg$c59 = function(a, b) {
              var ret = [a];
              for (var i = 0; i < b.length; i++)
                ret.push(b[i][1]);
              return ret;
            },
            peg$c60 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_PreIncrement',
                Expression: a
              });
            },
            peg$c61 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_PreDecrement',
                Expression: a
              });
            },
            peg$c62 = function(a, b) {
              return addPositionInfo({
                type: 'UnaryExpression',
                op: a,
                Expression: b
              });
            },
            peg$c63 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_Sizeof_Expr',
                Expression: a
              });
            },
            peg$c64 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_Sizeof_Type',
                TypeName: a
              });
            },
            peg$c65 = function(a, b) {
              return addPositionInfo({
                type: 'CastExpression',
                TypeName: a[1],
                Expression: b
              });
            },
            peg$c66 = function(a, b) {
              return buildRecursiveBinop(a, b);
            },
            peg$c67 = function(a, b) {
              var ret = a;
              for (var i = 0; i < b.length; i++) {
                ret = addPositionInfo({
                  type: 'ConditionalExpression',
                  cond: ret,
                  t: b[i][1],
                  f: b[i][3]
                });
              }
              return ret;
            },
            peg$c68 = function(a, b, c) {
              return addPositionInfo({
                type: 'BinOpExpression',
                op: b,
                left: a,
                right: c
              });
            },
            peg$c69 = function(a) {
              return a.join('');
            },
            peg$c70 = /^[ \n\r\t\x0B\f]/,
            peg$c71 = {
              type: "class",
              value: "[ \\n\\r\\t\\u000B\\u000C]",
              description: "[ \\n\\r\\t\\u000B\\u000C]"
            },
            peg$c72 = "/*",
            peg$c73 = {
              type: "literal",
              value: "/*",
              description: "\"/*\""
            },
            peg$c74 = "*/",
            peg$c75 = {
              type: "literal",
              value: "*/",
              description: "\"*/\""
            },
            peg$c76 = function(a) {
              return a.join('');
            },
            peg$c77 = "//",
            peg$c78 = {
              type: "literal",
              value: "//",
              description: "\"//\""
            },
            peg$c79 = "\n",
            peg$c80 = {
              type: "literal",
              value: "\n",
              description: "\"\\n\""
            },
            peg$c81 = "auto",
            peg$c82 = {
              type: "literal",
              value: "auto",
              description: "\"auto\""
            },
            peg$c83 = "break",
            peg$c84 = {
              type: "literal",
              value: "break",
              description: "\"break\""
            },
            peg$c85 = "case",
            peg$c86 = {
              type: "literal",
              value: "case",
              description: "\"case\""
            },
            peg$c87 = "char",
            peg$c88 = {
              type: "literal",
              value: "char",
              description: "\"char\""
            },
            peg$c89 = "const",
            peg$c90 = {
              type: "literal",
              value: "const",
              description: "\"const\""
            },
            peg$c91 = "continue",
            peg$c92 = {
              type: "literal",
              value: "continue",
              description: "\"continue\""
            },
            peg$c93 = "default",
            peg$c94 = {
              type: "literal",
              value: "default",
              description: "\"default\""
            },
            peg$c95 = "double",
            peg$c96 = {
              type: "literal",
              value: "double",
              description: "\"double\""
            },
            peg$c97 = "do",
            peg$c98 = {
              type: "literal",
              value: "do",
              description: "\"do\""
            },
            peg$c99 = "else",
            peg$c100 = {
              type: "literal",
              value: "else",
              description: "\"else\""
            },
            peg$c101 = "enum",
            peg$c102 = {
              type: "literal",
              value: "enum",
              description: "\"enum\""
            },
            peg$c103 = "extern",
            peg$c104 = {
              type: "literal",
              value: "extern",
              description: "\"extern\""
            },
            peg$c105 = "float",
            peg$c106 = {
              type: "literal",
              value: "float",
              description: "\"float\""
            },
            peg$c107 = "for",
            peg$c108 = {
              type: "literal",
              value: "for",
              description: "\"for\""
            },
            peg$c109 = "goto",
            peg$c110 = {
              type: "literal",
              value: "goto",
              description: "\"goto\""
            },
            peg$c111 = "if",
            peg$c112 = {
              type: "literal",
              value: "if",
              description: "\"if\""
            },
            peg$c113 = "int",
            peg$c114 = {
              type: "literal",
              value: "int",
              description: "\"int\""
            },
            peg$c115 = "inline",
            peg$c116 = {
              type: "literal",
              value: "inline",
              description: "\"inline\""
            },
            peg$c117 = "long",
            peg$c118 = {
              type: "literal",
              value: "long",
              description: "\"long\""
            },
            peg$c119 = "register",
            peg$c120 = {
              type: "literal",
              value: "register",
              description: "\"register\""
            },
            peg$c121 = "restrict",
            peg$c122 = {
              type: "literal",
              value: "restrict",
              description: "\"restrict\""
            },
            peg$c123 = "return",
            peg$c124 = {
              type: "literal",
              value: "return",
              description: "\"return\""
            },
            peg$c125 = "short",
            peg$c126 = {
              type: "literal",
              value: "short",
              description: "\"short\""
            },
            peg$c127 = "signed",
            peg$c128 = {
              type: "literal",
              value: "signed",
              description: "\"signed\""
            },
            peg$c129 = "sizeof",
            peg$c130 = {
              type: "literal",
              value: "sizeof",
              description: "\"sizeof\""
            },
            peg$c131 = "static",
            peg$c132 = {
              type: "literal",
              value: "static",
              description: "\"static\""
            },
            peg$c133 = "struct",
            peg$c134 = {
              type: "literal",
              value: "struct",
              description: "\"struct\""
            },
            peg$c135 = "switch",
            peg$c136 = {
              type: "literal",
              value: "switch",
              description: "\"switch\""
            },
            peg$c137 = "typedef",
            peg$c138 = {
              type: "literal",
              value: "typedef",
              description: "\"typedef\""
            },
            peg$c139 = "union",
            peg$c140 = {
              type: "literal",
              value: "union",
              description: "\"union\""
            },
            peg$c141 = "unsigned",
            peg$c142 = {
              type: "literal",
              value: "unsigned",
              description: "\"unsigned\""
            },
            peg$c143 = "void",
            peg$c144 = {
              type: "literal",
              value: "void",
              description: "\"void\""
            },
            peg$c145 = "volatile",
            peg$c146 = {
              type: "literal",
              value: "volatile",
              description: "\"volatile\""
            },
            peg$c147 = "while",
            peg$c148 = {
              type: "literal",
              value: "while",
              description: "\"while\""
            },
            peg$c149 = "_Bool",
            peg$c150 = {
              type: "literal",
              value: "_Bool",
              description: "\"_Bool\""
            },
            peg$c151 = "_Complex",
            peg$c152 = {
              type: "literal",
              value: "_Complex",
              description: "\"_Complex\""
            },
            peg$c153 = "_stdcall",
            peg$c154 = {
              type: "literal",
              value: "_stdcall",
              description: "\"_stdcall\""
            },
            peg$c155 = "__declspec",
            peg$c156 = {
              type: "literal",
              value: "__declspec",
              description: "\"__declspec\""
            },
            peg$c157 = "__attribute__",
            peg$c158 = {
              type: "literal",
              value: "__attribute__",
              description: "\"__attribute__\""
            },
            peg$c159 = "namespace",
            peg$c160 = {
              type: "literal",
              value: "namespace",
              description: "\"namespace\""
            },
            peg$c161 = "using",
            peg$c162 = {
              type: "literal",
              value: "using",
              description: "\"using\""
            },
            peg$c163 = "true",
            peg$c164 = {
              type: "literal",
              value: "true",
              description: "\"true\""
            },
            peg$c165 = "false",
            peg$c166 = {
              type: "literal",
              value: "false",
              description: "\"false\""
            },
            peg$c167 = "_Imaginary",
            peg$c168 = {
              type: "literal",
              value: "_Imaginary",
              description: "\"_Imaginary\""
            },
            peg$c169 = function(a, b, c) {
              var scope = a ? "global" : null;
              for (var i = 0; i < b.length; i++) {
                scope = addPositionInfo({
                  type: "ScopedIdentifier",
                  scope: scope,
                  Identifier: b[i]
                });
              }
              return addPositionInfo({
                type: "ScopedIdentifier",
                scope: scope,
                Identifier: c
              });
            },
            peg$c170 = function(a, b) {
              return a + b.join('');
            },
            peg$c171 = /^[a-z]/,
            peg$c172 = {
              type: "class",
              value: "[a-z]",
              description: "[a-z]"
            },
            peg$c173 = /^[A-Z]/,
            peg$c174 = {
              type: "class",
              value: "[A-Z]",
              description: "[A-Z]"
            },
            peg$c175 = /^[_]/,
            peg$c176 = {
              type: "class",
              value: "[_]",
              description: "[_]"
            },
            peg$c177 = /^[0-9]/,
            peg$c178 = {
              type: "class",
              value: "[0-9]",
              description: "[0-9]"
            },
            peg$c179 = "\\u",
            peg$c180 = {
              type: "literal",
              value: "\\u",
              description: "\"\\\\u\""
            },
            peg$c181 = "\\U",
            peg$c182 = {
              type: "literal",
              value: "\\U",
              description: "\"\\\\U\""
            },
            peg$c183 = function(a) {
              return addPositionInfo({
                type: 'BooleanConstant',
                value: a
              });
            },
            peg$c184 = /^[1-9]/,
            peg$c185 = {
              type: "class",
              value: "[1-9]",
              description: "[1-9]"
            },
            peg$c186 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalConstant',
                value: a + b.join("")
              });
            },
            peg$c187 = "0",
            peg$c188 = {
              type: "literal",
              value: "0",
              description: "\"0\""
            },
            peg$c189 = /^[0-7]/,
            peg$c190 = {
              type: "class",
              value: "[0-7]",
              description: "[0-7]"
            },
            peg$c191 = function(a) {
              if (a.length > 0)
                return addPositionInfo({
                  type: 'OctalConstant',
                  value: a.join("")
                });
              else
                return addPositionInfo({
                  type: 'OctalConstant',
                  value: '0'
                });
            },
            peg$c192 = function(a) {
              return addPositionInfo({
                type: 'HexConstant',
                value: a.join("")
              });
            },
            peg$c193 = "0x",
            peg$c194 = {
              type: "literal",
              value: "0x",
              description: "\"0x\""
            },
            peg$c195 = "0X",
            peg$c196 = {
              type: "literal",
              value: "0X",
              description: "\"0X\""
            },
            peg$c197 = /^[a-f]/,
            peg$c198 = {
              type: "class",
              value: "[a-f]",
              description: "[a-f]"
            },
            peg$c199 = /^[A-F]/,
            peg$c200 = {
              type: "class",
              value: "[A-F]",
              description: "[A-F]"
            },
            peg$c201 = "0b",
            peg$c202 = {
              type: "literal",
              value: "0b",
              description: "\"0b\""
            },
            peg$c203 = /^[0-1]/,
            peg$c204 = {
              type: "class",
              value: "[0-1]",
              description: "[0-1]"
            },
            peg$c205 = function(a) {
              return addPositionInfo({
                type: 'BinaryConstant',
                value: a.join("")
              });
            },
            peg$c206 = /^[uU]/,
            peg$c207 = {
              type: "class",
              value: "[uU]",
              description: "[uU]"
            },
            peg$c208 = "ll",
            peg$c209 = {
              type: "literal",
              value: "ll",
              description: "\"ll\""
            },
            peg$c210 = "LL",
            peg$c211 = {
              type: "literal",
              value: "LL",
              description: "\"LL\""
            },
            peg$c212 = /^[lL]/,
            peg$c213 = {
              type: "class",
              value: "[lL]",
              description: "[lL]"
            },
            peg$c214 = function(a, b) {
              if (b)
                return addPositionInfo({
                  type: 'FloatConstant',
                  Expression: a
                });
              else
                return a;
            },
            peg$c215 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalFloatConstant',
                value: a + b || ''
              });
            },
            peg$c216 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalFloatConstant',
                value: a.join('') + b
              });
            },
            peg$c217 = function(a, b, c) {
              return addPositionInfo({
                type: 'HexFloatConstant',
                value: a + b + c || ''
              });
            },
            peg$c218 = function(a, b, c) {
              return addPositionInfo({
                type: 'HexFloatConstant',
                value: a + b.join('') + c
              });
            },
            peg$c219 = ".",
            peg$c220 = {
              type: "literal",
              value: ".",
              description: "\".\""
            },
            peg$c221 = function(a, b) {
              return a.join('') + '.' + b.join('');
            },
            peg$c222 = function(a) {
              return a.join('') + '.';
            },
            peg$c223 = /^[eE]/,
            peg$c224 = {
              type: "class",
              value: "[eE]",
              description: "[eE]"
            },
            peg$c225 = /^[+\-]/,
            peg$c226 = {
              type: "class",
              value: "[+\\-]",
              description: "[+\\-]"
            },
            peg$c227 = function(a, b, c) {
              return a + (b || "") + c.join('');
            },
            peg$c228 = /^[pP]/,
            peg$c229 = {
              type: "class",
              value: "[pP]",
              description: "[pP]"
            },
            peg$c230 = function(a, b) {
              return a + b.join('');
            },
            peg$c231 = /^[flFL]/,
            peg$c232 = {
              type: "class",
              value: "[flFL]",
              description: "[flFL]"
            },
            peg$c233 = function(a) {
              return addPositionInfo({
                type: 'EnumerationConstant',
                Identifier: a
              });
            },
            peg$c234 = "L",
            peg$c235 = {
              type: "literal",
              value: "L",
              description: "\"L\""
            },
            peg$c236 = "'",
            peg$c237 = {
              type: "literal",
              value: "'",
              description: "\"'\""
            },
            peg$c238 = function(a) {
              return addPositionInfo({
                type: 'CharacterConstant',
                Char: a
              });
            },
            peg$c239 = /^['\n\\]/,
            peg$c240 = {
              type: "class",
              value: "['\\n\\\\]",
              description: "['\\n\\\\]"
            },
            peg$c241 = "\\",
            peg$c242 = {
              type: "literal",
              value: "\\",
              description: "\"\\\\\""
            },
            peg$c243 = /^['"?\\abfnrtv]/,
            peg$c244 = {
              type: "class",
              value: "['\\\"?\\\\abfnrtv]",
              description: "['\\\"?\\\\abfnrtv]"
            },
            peg$c245 = function(a, b) {
              return eval('"' + a + b + '"');
            },
            peg$c246 = function(a, b, c, d) {
              var ret = "\"";
              ret += a;
              ret += b;
              if (c)
                ret += c;
              if (d)
                ret += d;
              ret += "\"";
              return eval(ret);
            },
            peg$c247 = "\\x",
            peg$c248 = {
              type: "literal",
              value: "\\x",
              description: "\"\\\\x\""
            },
            peg$c249 = function(a, b) {
              return eval('"' + a + b.join('') + '"');
            },
            peg$c250 = "u8",
            peg$c251 = {
              type: "literal",
              value: "u8",
              description: "\"u8\""
            },
            peg$c252 = "u",
            peg$c253 = {
              type: "literal",
              value: "u",
              description: "\"u\""
            },
            peg$c254 = "U",
            peg$c255 = {
              type: "literal",
              value: "U",
              description: "\"U\""
            },
            peg$c256 = function(a, b) {
              return addPositionInfo({
                type: 'StringLiteral',
                prefix: a,
                value: b
              });
            },
            peg$c257 = "R",
            peg$c258 = {
              type: "literal",
              value: "R",
              description: "\"R\""
            },
            peg$c259 = /^["]/,
            peg$c260 = {
              type: "class",
              value: "[\"]",
              description: "[\"]"
            },
            peg$c261 = function(a) {
              return a.join('');
            },
            peg$c262 = /^["\n]/,
            peg$c263 = {
              type: "class",
              value: "[\\\"\\n]",
              description: "[\\\"\\n]"
            },
            peg$c264 = /^["\n\\]/,
            peg$c265 = {
              type: "class",
              value: "[\\\"\\n\\\\]",
              description: "[\\\"\\n\\\\]"
            },
            peg$c266 = "[",
            peg$c267 = {
              type: "literal",
              value: "[",
              description: "\"[\""
            },
            peg$c268 = "]",
            peg$c269 = {
              type: "literal",
              value: "]",
              description: "\"]\""
            },
            peg$c270 = "(",
            peg$c271 = {
              type: "literal",
              value: "(",
              description: "\"(\""
            },
            peg$c272 = ")",
            peg$c273 = {
              type: "literal",
              value: ")",
              description: "\")\""
            },
            peg$c274 = "{",
            peg$c275 = {
              type: "literal",
              value: "{",
              description: "\"{\""
            },
            peg$c276 = "}",
            peg$c277 = {
              type: "literal",
              value: "}",
              description: "\"}\""
            },
            peg$c278 = "->",
            peg$c279 = {
              type: "literal",
              value: "->",
              description: "\"->\""
            },
            peg$c280 = "++",
            peg$c281 = {
              type: "literal",
              value: "++",
              description: "\"++\""
            },
            peg$c282 = "--",
            peg$c283 = {
              type: "literal",
              value: "--",
              description: "\"--\""
            },
            peg$c284 = "&",
            peg$c285 = {
              type: "literal",
              value: "&",
              description: "\"&\""
            },
            peg$c286 = /^[&]/,
            peg$c287 = {
              type: "class",
              value: "[&]",
              description: "[&]"
            },
            peg$c288 = "*",
            peg$c289 = {
              type: "literal",
              value: "*",
              description: "\"*\""
            },
            peg$c290 = /^[=]/,
            peg$c291 = {
              type: "class",
              value: "[=]",
              description: "[=]"
            },
            peg$c292 = "+",
            peg$c293 = {
              type: "literal",
              value: "+",
              description: "\"+\""
            },
            peg$c294 = /^[+=]/,
            peg$c295 = {
              type: "class",
              value: "[+=]",
              description: "[+=]"
            },
            peg$c296 = "-",
            peg$c297 = {
              type: "literal",
              value: "-",
              description: "\"-\""
            },
            peg$c298 = /^[\-=>]/,
            peg$c299 = {
              type: "class",
              value: "[\\-=>]",
              description: "[\\-=>]"
            },
            peg$c300 = "~",
            peg$c301 = {
              type: "literal",
              value: "~",
              description: "\"~\""
            },
            peg$c302 = "!",
            peg$c303 = {
              type: "literal",
              value: "!",
              description: "\"!\""
            },
            peg$c304 = "/",
            peg$c305 = {
              type: "literal",
              value: "/",
              description: "\"/\""
            },
            peg$c306 = "%",
            peg$c307 = {
              type: "literal",
              value: "%",
              description: "\"%\""
            },
            peg$c308 = /^[=>]/,
            peg$c309 = {
              type: "class",
              value: "[=>]",
              description: "[=>]"
            },
            peg$c310 = "<<",
            peg$c311 = {
              type: "literal",
              value: "<<",
              description: "\"<<\""
            },
            peg$c312 = ">>",
            peg$c313 = {
              type: "literal",
              value: ">>",
              description: "\">>\""
            },
            peg$c314 = "<",
            peg$c315 = {
              type: "literal",
              value: "<",
              description: "\"<\""
            },
            peg$c316 = ">",
            peg$c317 = {
              type: "literal",
              value: ">",
              description: "\">\""
            },
            peg$c318 = "<=",
            peg$c319 = {
              type: "literal",
              value: "<=",
              description: "\"<=\""
            },
            peg$c320 = ">=",
            peg$c321 = {
              type: "literal",
              value: ">=",
              description: "\">=\""
            },
            peg$c322 = "==",
            peg$c323 = {
              type: "literal",
              value: "==",
              description: "\"==\""
            },
            peg$c324 = "!=",
            peg$c325 = {
              type: "literal",
              value: "!=",
              description: "\"!=\""
            },
            peg$c326 = "^",
            peg$c327 = {
              type: "literal",
              value: "^",
              description: "\"^\""
            },
            peg$c328 = "|",
            peg$c329 = {
              type: "literal",
              value: "|",
              description: "\"|\""
            },
            peg$c330 = "&&",
            peg$c331 = {
              type: "literal",
              value: "&&",
              description: "\"&&\""
            },
            peg$c332 = "||",
            peg$c333 = {
              type: "literal",
              value: "||",
              description: "\"||\""
            },
            peg$c334 = "?",
            peg$c335 = {
              type: "literal",
              value: "?",
              description: "\"?\""
            },
            peg$c336 = ":",
            peg$c337 = {
              type: "literal",
              value: ":",
              description: "\":\""
            },
            peg$c338 = /^[>]/,
            peg$c339 = {
              type: "class",
              value: "[>]",
              description: "[>]"
            },
            peg$c340 = ";",
            peg$c341 = {
              type: "literal",
              value: ";",
              description: "\";\""
            },
            peg$c342 = "...",
            peg$c343 = {
              type: "literal",
              value: "...",
              description: "\"...\""
            },
            peg$c344 = "=",
            peg$c345 = {
              type: "literal",
              value: "=",
              description: "\"=\""
            },
            peg$c346 = "*=",
            peg$c347 = {
              type: "literal",
              value: "*=",
              description: "\"*=\""
            },
            peg$c348 = "/=",
            peg$c349 = {
              type: "literal",
              value: "/=",
              description: "\"/=\""
            },
            peg$c350 = "%=",
            peg$c351 = {
              type: "literal",
              value: "%=",
              description: "\"%=\""
            },
            peg$c352 = "+=",
            peg$c353 = {
              type: "literal",
              value: "+=",
              description: "\"+=\""
            },
            peg$c354 = "-=",
            peg$c355 = {
              type: "literal",
              value: "-=",
              description: "\"-=\""
            },
            peg$c356 = "<<=",
            peg$c357 = {
              type: "literal",
              value: "<<=",
              description: "\"<<=\""
            },
            peg$c358 = ">>=",
            peg$c359 = {
              type: "literal",
              value: ">>=",
              description: "\">>=\""
            },
            peg$c360 = "&=",
            peg$c361 = {
              type: "literal",
              value: "&=",
              description: "\"&=\""
            },
            peg$c362 = "^=",
            peg$c363 = {
              type: "literal",
              value: "^=",
              description: "\"^=\""
            },
            peg$c364 = "|=",
            peg$c365 = {
              type: "literal",
              value: "|=",
              description: "\"|=\""
            },
            peg$c366 = ",",
            peg$c367 = {
              type: "literal",
              value: ",",
              description: "\",\""
            },
            peg$c368 = "::",
            peg$c369 = {
              type: "literal",
              value: "::",
              description: "\"::\""
            },
            peg$c370 = {
              type: "any",
              description: "any character"
            },
            peg$currPos = 0,
            peg$savedPos = 0,
            peg$posDetailsCache = [{
              line: 1,
              column: 1,
              seenCR: false
            }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{
            type: "other",
            description: description
          }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p,
              ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildException(message, expected, found, location) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length),
                expectedDesc,
                foundDesc,
                i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
        }
        function peg$parseTranslationUnit() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseExternalDeclaration();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseExternalDeclaration();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExternalDeclaration() {
          var s0;
          s0 = peg$parseNamespace();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTypedefDeclaration();
            if (s0 === peg$FAILED) {
              s0 = peg$parseFunctionDefinition();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDeclaration();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespace() {
          var s0;
          s0 = peg$parseNamespaceDefinition();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUsingDirective();
            if (s0 === peg$FAILED) {
              s0 = peg$parseUsingDeclaration();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNamespaceAliasDefinition();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespaceDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLWING();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseExternalDeclaration();
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseExternalDeclaration();
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseRWING();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c1(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDirective() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNAMESPACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseScopedIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSEMI();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c2(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDeclaration() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseScopedIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSCOPEOP();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c3(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNamespaceAliasDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEQU();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseScopedIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypedefDeclaration() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseTYPEDEF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDeclarationSpecifiers();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$parseCOMMA();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDeclarator();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s6 = peg$c5(s7, s3);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$parseCOMMA();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDeclarator();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c5(s7, s3);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s2, s3, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFunctionDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSTAR();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseFunctionDirectDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parseSEMI();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c7(s1, s2, s3);
                }
                s4 = s5;
                if (s4 === peg$FAILED) {
                  s4 = peg$parseCompoundStatement();
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c8(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationList() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDeclaration();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDeclaration();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStatementORDeclaration() {
          var s0;
          s0 = peg$parseStatement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclaration();
          }
          return s0;
        }
        function peg$parseStatement() {
          var s0;
          s0 = peg$parseLabel();
          if (s0 === peg$FAILED) {
            s0 = peg$parseCompoundStatement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseExpressionStatement();
              if (s0 === peg$FAILED) {
                s0 = peg$parseSelectionStatement();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseIterationStatement();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseJumpStatement();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseLabel() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseCASE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseConditionalExpression();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseCOLON();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c10(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDEFAULT();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCOLON();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseCompoundStatement() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseLWING();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseStatement();
            if (s3 === peg$FAILED) {
              s3 = peg$parseDeclaration();
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseStatement();
              if (s3 === peg$FAILED) {
                s3 = peg$parseDeclaration();
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseRWING();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExpressionStatement() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseExpression();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSEMI();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSelectionStatement() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseIF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$currPos;
                    s7 = peg$parseELSE();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseStatement();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 === peg$FAILED) {
                      s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s3, s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSWITCH();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseExpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseStatement();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c15(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseIterationStatement() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseWHILE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c16(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDO();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseStatement();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseWHILE();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseLPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseExpression();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseRPAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseSEMI();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c17(s2, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseFOR();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLPAR();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseDeclaration();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseExpressionStatement();
                  }
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseExpression();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseSEMI();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseExpression();
                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRPAR();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parseStatement();
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c18(s3, s4, s6, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parseJumpStatement() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseGOTO();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseCONTINUE();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseSEMI();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c20();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseBREAK();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseSEMI();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c21();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseRETURN();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseSEMI();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c22(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parseDeclaration() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInitDeclaratorList();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c23(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationSpecifiers() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parseStorageClassSpecifier();
          if (s3 === peg$FAILED) {
            s3 = peg$parseTypeQualifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseFunctionSpecifier();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseStorageClassSpecifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseTypeQualifier();
              if (s3 === peg$FAILED) {
                s3 = peg$parseFunctionSpecifier();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseIdentifier();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseStorageClassSpecifier();
              if (s5 === peg$FAILED) {
                s5 = peg$parseTypeQualifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseFunctionSpecifier();
                }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseStorageClassSpecifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseTypeQualifier();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseFunctionSpecifier();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c24(s2, s3, s4);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parseStorageClassSpecifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c26(s3);
            }
            s2 = s3;
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseTypeSpecifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c26(s3);
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseTypeQualifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseFunctionSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseStorageClassSpecifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseTypeSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                  if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseTypeQualifier();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c26(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseFunctionSpecifier();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c26(s3);
                      }
                      s2 = s3;
                    }
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseInitDeclaratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInitDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitDeclarator();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitDeclarator();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseInitializer();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c28(s1, s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c30(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStorageClassSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseEXTERN();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTATIC();
            if (s1 === peg$FAILED) {
              s1 = peg$parseAUTO();
              if (s1 === peg$FAILED) {
                s1 = peg$parseREGISTER();
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s2 = peg$parseATTRIBUTE();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseLPAR();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$currPos;
                        peg$silentFails++;
                        s8 = peg$parseRPAR();
                        peg$silentFails--;
                        if (s8 === peg$FAILED) {
                          s7 = void 0;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                          s5.push(s6);
                          s6 = peg$currPos;
                          s7 = peg$currPos;
                          peg$silentFails++;
                          s8 = peg$parseRPAR();
                          peg$silentFails--;
                          if (s8 === peg$FAILED) {
                            s7 = void 0;
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parse_();
                            if (s8 !== peg$FAILED) {
                              s7 = [s7, s8];
                              s6 = s7;
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseRPAR();
                            if (s7 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseTypeSpecifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseVOID();
          if (s1 === peg$FAILED) {
            s1 = peg$parseCHAR();
            if (s1 === peg$FAILED) {
              s1 = peg$parseSHORT();
              if (s1 === peg$FAILED) {
                s1 = peg$parseINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseLONG();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseFLOAT();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseDOUBLE();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseSIGNED();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseUNSIGNED();
                          if (s1 === peg$FAILED) {
                            s1 = peg$parseBOOL();
                            if (s1 === peg$FAILED) {
                              s1 = peg$parseCOMPLEX();
                              if (s1 === peg$FAILED) {
                                s1 = peg$parseStructOrUnionSpecifier();
                                if (s1 === peg$FAILED) {
                                  s1 = peg$parseEnumSpecifier();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructOrUnionSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseStructOrUnion();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseStructDeclaration();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseStructDeclaration();
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRWING();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c27(s3);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructOrUnion() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseSTRUCT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseUNION();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructDeclaration() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseStructDeclaratorList();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpecifierQualifierList() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseTypeQualifier();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseTypeQualifier();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseTypeQualifier();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseTypeQualifier();
              }
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = [];
            s1 = peg$parseTypeSpecifier();
            if (s1 === peg$FAILED) {
              s1 = peg$parseTypeQualifier();
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parseTypeSpecifier();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseTypeQualifier();
                }
              }
            } else {
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseStructDeclaratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseStructDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseStructDeclarator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseStructDeclarator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructDeclarator() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseCOLON();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseConditionalExpression();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclarator();
          }
          return s0;
        }
        function peg$parseEnumSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseENUM();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumeratorList();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOMMA();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRWING();
                    if (s7 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6, s7];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumeratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseEnumerator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEnumerator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumerator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumerator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseEnumerationConstant();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseConditionalExpression();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeQualifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseCONST();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionSpecifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseINLINE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTDCALL();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionDirectDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseLPAR();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseParameterTypeList();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRPAR();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c33(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarator() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDirectDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseTypeQualifier();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseTypeQualifier();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseAssignmentExpression();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseRBRK();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c36(s5, s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSTATIC();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseTypeQualifier();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseTypeQualifier();
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseAssignmentExpression();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseRBRK();
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c37(s6, s7);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseTypeQualifier();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSTATIC();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s5, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseRBRK();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c38(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLPAR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseParameterTypeList();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseRPAR();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c33(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseIdentifierList();
                        if (s5 === peg$FAILED) {
                          s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c39(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseTypeQualifier();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseTypeQualifier();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseAssignmentExpression();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRBRK();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c36(s5, s6);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSTATIC();
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseTypeQualifier();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parseTypeQualifier();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s6, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                    } else {
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTATIC();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseAssignmentExpression();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseRBRK();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c37(s5, s7);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLBRK();
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseTypeQualifier();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseSTAR();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRBRK();
                          if (s7 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c38(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseParameterTypeList();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c33(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseLPAR();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseIdentifierList();
                          if (s5 === peg$FAILED) {
                            s5 = null;
                          }
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parseRPAR();
                            if (s6 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s4 = peg$c39(s5);
                              s3 = s4;
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePointer() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = [];
          s1 = peg$currPos;
          s2 = peg$parseSTAR();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseTypeQualifier();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseTypeQualifier();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c26(s3);
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$currPos;
              s2 = peg$parseSTAR();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseTypeQualifier();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseTypeQualifier();
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterTypeList() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseParameterList();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseCOMMA();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseELLIPSIS();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c40(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseParameterDeclaration();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseParameterDeclaration();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterDeclaration();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c41(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterDeclaration() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInitDeclarator();
            if (s2 === peg$FAILED) {
              s2 = peg$parseAbstractDeclarator();
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifierList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseIdentifier();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseIdentifier();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeName() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAbstractDeclarator();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c43(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAbstractDeclarator() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectAbstractDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePointer();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseDirectAbstractDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseLPAR();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseAbstractDeclarator();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseRPAR();
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLBRK();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 === peg$FAILED) {
                s3 = peg$parseSTAR();
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRBRK();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseParameterTypeList();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 === peg$FAILED) {
                s5 = peg$parseSTAR();
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterTypeList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseSTAR();
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseParameterTypeList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitializer() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c45(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLWING();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseInitializerList();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseCOMMA();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRWING();
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c46(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseInitializerList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInitializer();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitializer();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitializer();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrimaryExpression() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseConstant();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c49(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseStringLiteral();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseLPAR();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseRPAR();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c51(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parsePostfixExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parsePrimaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c52(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseArgumentExpressionList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c53(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseDOT();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseIdentifier();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c54(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePTR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c55(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseINC();
                    if (s4 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c56(s1, s4);
                    }
                    s3 = s4;
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseDEC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c57(s1, s4);
                      }
                      s3 = s4;
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c52(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseArgumentExpressionList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c53(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseDOT();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c54(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parsePTR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseIdentifier();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c55(s1, s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseINC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c56(s1, s4);
                      }
                      s3 = s4;
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseDEC();
                        if (s4 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c57(s1, s4);
                        }
                        s3 = s4;
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c58(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseArgumentExpressionList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUnaryExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$parsePostfixExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseINC();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseUnaryExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseDEC();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseUnaryExpression();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseUnaryOperator();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseCastExpression();
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c62(s1, s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseSIZEOF();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseUnaryExpression();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c63(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseLPAR();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parseTypeName();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseRPAR();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c64(s4);
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c26(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUnaryOperator() {
          var s0;
          s0 = peg$parseAND();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAR();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePLUS();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMINUS();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseTILDA();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseBANG();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseCastExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$parseUnaryExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseTypeName();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCastExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseMultiplicativeExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseCastExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseSTAR();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDIV();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMOD();
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseCastExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseSTAR();
              if (s4 === peg$FAILED) {
                s4 = peg$parseDIV();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseMOD();
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseCastExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAdditiveExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseMultiplicativeExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsePLUS();
            if (s4 === peg$FAILED) {
              s4 = peg$parseMINUS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMultiplicativeExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsePLUS();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMINUS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseMultiplicativeExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseShiftExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAdditiveExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLEFT();
            if (s4 === peg$FAILED) {
              s4 = peg$parseRIGHT();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAdditiveExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLEFT();
              if (s4 === peg$FAILED) {
                s4 = peg$parseRIGHT();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAdditiveExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRelationalExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseShiftExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLE();
            if (s4 === peg$FAILED) {
              s4 = peg$parseGE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseLT();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseGT();
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseShiftExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseGE();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseLT();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parseGT();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseShiftExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEqualityExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseRelationalExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseEQUEQU();
            if (s4 === peg$FAILED) {
              s4 = peg$parseBANGEQU();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseRelationalExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseEQUEQU();
              if (s4 === peg$FAILED) {
                s4 = peg$parseBANGEQU();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRelationalExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseEqualityExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEqualityExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEqualityExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExclusiveORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseHAT();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseHAT();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInclusiveORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseExclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalANDExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseANDAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseANDAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseLogicalANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOROR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseLogicalANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOROR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseLogicalANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConditionalExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseLogicalORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseQUERY();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseCOLON();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseLogicalORExpression();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseQUERY();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOLON();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseLogicalORExpression();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c67(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAssignmentExpression() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseUnaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAssignmentOperator();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c68(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseConditionalExpression();
          }
          return s0;
        }
        function peg$parseAssignmentOperator() {
          var s0;
          s0 = peg$parseEQU();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAREQU();
            if (s0 === peg$FAILED) {
              s0 = peg$parseDIVEQU();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMODEQU();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsePLUSEQU();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseMINUSEQU();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseLEFTEQU();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseRIGHTEQU();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseANDEQU();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseHATEQU();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseOREQU();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c70.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c71);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c72) {
            s1 = peg$c72;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c74) {
              s5 = peg$c74;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c75);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s5 = peg$c74;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s3 = peg$c74;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c79;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c80);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c79;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c80);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c76(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c125) {
            s1 = peg$c125;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c127) {
            s1 = peg$c127;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c129) {
            s1 = peg$c129;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c130);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c131) {
            s1 = peg$c131;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c132);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c135) {
            s1 = peg$c135;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c136);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c137) {
            s1 = peg$c137;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c138);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c139) {
            s1 = peg$c139;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c141) {
            s1 = peg$c141;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c142);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c143) {
            s1 = peg$c143;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c144);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c145) {
            s1 = peg$c145;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c146);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c147) {
            s1 = peg$c147;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c148);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c149) {
            s1 = peg$c149;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c150);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c152);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c153) {
            s1 = peg$c153;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c154);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c155) {
            s1 = peg$c155;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c156);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c157) {
            s1 = peg$c157;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNAMESPACE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 9) === peg$c159) {
            s1 = peg$c159;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c160);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUSING() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c161) {
            s1 = peg$c161;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c162);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTRUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c163) {
            s1 = peg$c163;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFALSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c165) {
            s1 = peg$c165;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c166);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c83) {
              s1 = peg$c83;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c85) {
                s1 = peg$c85;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c87) {
                  s1 = peg$c87;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c88);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c89) {
                    s1 = peg$c89;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c91) {
                      s1 = peg$c91;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c92);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c93) {
                        s1 = peg$c93;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c94);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c95) {
                          s1 = peg$c95;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c97) {
                            s1 = peg$c97;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c98);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c99) {
                              s1 = peg$c99;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c100);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c101) {
                                s1 = peg$c101;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c102);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c103) {
                                  s1 = peg$c103;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c104);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c105) {
                                    s1 = peg$c105;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c106);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c107) {
                                      s1 = peg$c107;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c108);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c109) {
                                        s1 = peg$c109;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c110);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c111) {
                                          s1 = peg$c111;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c112);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c113) {
                                            s1 = peg$c113;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c114);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c115) {
                                              s1 = peg$c115;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c116);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c117) {
                                                s1 = peg$c117;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c118);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c119) {
                                                  s1 = peg$c119;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c120);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c121) {
                                                    s1 = peg$c121;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c122);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c123) {
                                                      s1 = peg$c123;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c124);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c125) {
                                                        s1 = peg$c125;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c126);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c127) {
                                                          s1 = peg$c127;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c128);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c129) {
                                                            s1 = peg$c129;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c130);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c131) {
                                                              s1 = peg$c131;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c132);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c133) {
                                                                s1 = peg$c133;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c134);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c135) {
                                                                  s1 = peg$c135;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c136);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c137) {
                                                                    s1 = peg$c137;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c138);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c139) {
                                                                      s1 = peg$c139;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c140);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c141) {
                                                                        s1 = peg$c141;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c142);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c143) {
                                                                          s1 = peg$c143;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c144);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c145) {
                                                                            s1 = peg$c145;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c146);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c147) {
                                                                              s1 = peg$c147;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c148);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c149) {
                                                                                s1 = peg$c149;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c150);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c151) {
                                                                                  s1 = peg$c151;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c152);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c167) {
                                                                                    s1 = peg$c167;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c168);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c153) {
                                                                                      s1 = peg$c153;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c154);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c155) {
                                                                                        s1 = peg$c155;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c156);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c157) {
                                                                                          s1 = peg$c157;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c158);
                                                                                          }
                                                                                        }
                                                                                        if (s1 === peg$FAILED) {
                                                                                          if (input.substr(peg$currPos, 9) === peg$c159) {
                                                                                            s1 = peg$c159;
                                                                                            peg$currPos += 9;
                                                                                          } else {
                                                                                            s1 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) {
                                                                                              peg$fail(peg$c160);
                                                                                            }
                                                                                          }
                                                                                          if (s1 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 5) === peg$c161) {
                                                                                              s1 = peg$c161;
                                                                                              peg$currPos += 5;
                                                                                            } else {
                                                                                              s1 = peg$FAILED;
                                                                                              if (peg$silentFails === 0) {
                                                                                                peg$fail(peg$c162);
                                                                                              }
                                                                                            }
                                                                                            if (s1 === peg$FAILED) {
                                                                                              if (input.substr(peg$currPos, 4) === peg$c163) {
                                                                                                s1 = peg$c163;
                                                                                                peg$currPos += 4;
                                                                                              } else {
                                                                                                s1 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) {
                                                                                                  peg$fail(peg$c164);
                                                                                                }
                                                                                              }
                                                                                              if (s1 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 5) === peg$c165) {
                                                                                                  s1 = peg$c165;
                                                                                                  peg$currPos += 5;
                                                                                                } else {
                                                                                                  s1 = peg$FAILED;
                                                                                                  if (peg$silentFails === 0) {
                                                                                                    peg$fail(peg$c166);
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseScopedIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSCOPEOP();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseIdentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSCOPEOP();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s4);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseIdentifier();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSCOPEOP();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s4);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c169(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c170(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c175.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c176);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c175.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c176);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c179) {
            s1 = peg$c179;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c180);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c181) {
              s1 = peg$c181;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c182);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexQuad();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseHexQuad();
                if (s3 !== peg$FAILED) {
                  s1 = [s1, s2, s3];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexQuad() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseHexDigit();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHexDigit();
                if (s4 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseIntegerConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseEnumerationConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseCharacterConstant();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseBooleanConstant();
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseBooleanConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseTRUE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseFALSE();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c183(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseIntegerConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseDecimalConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseOctalConstant();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIntegerSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (peg$c184.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c185);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c186(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c187;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c188);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c189.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c190);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c189.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c190);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c191(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c192(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c193) {
            s0 = peg$c193;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c194);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c195) {
              s0 = peg$c195;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c196);
              }
            }
          }
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c197.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c198);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c199.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c200);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseBinaryPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c201) {
            s0 = peg$c201;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c202);
            }
          }
          return s0;
        }
        function peg$parseBinaryDigit() {
          var s0;
          if (peg$c203.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c204);
            }
          }
          return s0;
        }
        function peg$parseBinaryConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseBinaryDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseBinaryDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c205(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIntegerSuffix() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (peg$c206.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c207);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLsuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLsuffix();
            if (s1 !== peg$FAILED) {
              if (peg$c206.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c207);
                }
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLsuffix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c208) {
            s0 = peg$c208;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c209);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c210) {
              s0 = peg$c210;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c211);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c212.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c213);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseFloatConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDecimalFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseHexFloatConstant();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseFloatSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c214(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalFloatConstant() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseFraction();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponent();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c215(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseExponent();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c216(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFloatConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexFraction();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseBinaryExponent();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c217(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseHexPrefix();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseHexDigit();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseBinaryExponent();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c218(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseFraction() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          if (peg$c177.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c178);
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c219;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c220);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c221(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c219;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c220);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFraction() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseHexDigit();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseHexDigit();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c219;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c220);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseHexDigit();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c221(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseHexDigit();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c219;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c220);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c222(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseExponent() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (peg$c223.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c224);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c225.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c226);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c227(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBinaryExponent() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (peg$c228.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c229);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c225.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c226);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c230(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFloatSuffix() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c231.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c232);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEnumerationConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c233(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseCharacterConstant() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c234;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c235);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c236;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c237);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseChar();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s4 = peg$c236;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c237);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c238(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseChar() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseEscape();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c239.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c240);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseEscape() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseSimpleEscape();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOctalEscape();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexEscape();
              if (s1 === peg$FAILED) {
                s1 = peg$parseUniversalCharacter();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSimpleEscape() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c241;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c242);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c243.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c244);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c245(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalEscape() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c241;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c242);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c189.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c190);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c189.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c190);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                if (peg$c189.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c190);
                  }
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c246(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexEscape() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c247) {
            s1 = peg$c247;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c248);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c249(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringLiteral() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c234;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c235);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c250) {
              s1 = peg$c250;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c251);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 117) {
                s1 = peg$c252;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c253);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 85) {
                  s1 = peg$c254;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c255);
                  }
                }
              }
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseRawStringLiteral();
            if (s2 === peg$FAILED) {
              s2 = peg$parseEscapedStringLiteral();
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c256(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRawStringLiteral() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 82) {
            s1 = peg$c257;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c258);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (peg$c259.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c260);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseRawStringChar();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseRawStringChar();
              }
              if (s5 !== peg$FAILED) {
                if (peg$c259.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseSpacing();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c76(s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (peg$c259.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseRawStringChar();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseRawStringChar();
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c259.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseSpacing();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c76(s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c261(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEscapedStringLiteral() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          if (peg$c259.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c260);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseStringChar();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseStringChar();
            }
            if (s4 !== peg$FAILED) {
              if (peg$c259.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c260);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseSpacing();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c76(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              if (peg$c259.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c260);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseStringChar();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseStringChar();
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c259.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c260);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSpacing();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c76(s4);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c261(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseRawStringChar() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (peg$c262.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c263);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringChar() {
          var s0,
              s1,
              s2;
          s0 = peg$parseEscape();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c264.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c265);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLBRK() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c266;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c267);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRBRK() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 93) {
            s1 = peg$c268;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c269);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c270;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c271);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c272;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c273);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLWING() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c274;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c275);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRWING() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 125) {
            s1 = peg$c276;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c277);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOT() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c219;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c220);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePTR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c278) {
            s1 = peg$c278;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c279);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINC() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c280) {
            s1 = peg$c280;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c281);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEC() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c282) {
            s1 = peg$c282;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c283);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAND() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c284;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c285);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c286.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c287);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c288;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c289);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUS() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c292;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c293);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c294.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c295);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUS() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c296;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c297);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c298.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c299);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTILDA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c300;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c301);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c302;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c303);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIV() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c304;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c305);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMOD() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 37) {
            s1 = peg$c306;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c307);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c308.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c309);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c310) {
            s1 = peg$c310;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c311);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c312) {
            s1 = peg$c312;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c313);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c314;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c315);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c316;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c317);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c318) {
            s1 = peg$c318;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c319);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c320) {
            s1 = peg$c320;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c321);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQUEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c322) {
            s1 = peg$c322;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c323);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANGEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c324) {
            s1 = peg$c324;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c325);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 94) {
            s1 = peg$c326;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c327);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 124) {
            s1 = peg$c328;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c329);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDAND() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c330) {
            s1 = peg$c330;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c331);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOROR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c332) {
            s1 = peg$c332;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c333);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUERY() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s1 = peg$c334;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c335);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOLON() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c336;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c337);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c338.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c339);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSEMI() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s1 = peg$c340;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c341);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELLIPSIS() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c342) {
            s1 = peg$c342;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c343);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQU() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c344;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c345);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c344;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c345);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAREQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c346) {
            s1 = peg$c346;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c347);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIVEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c348) {
            s1 = peg$c348;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c349);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMODEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c350) {
            s1 = peg$c350;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c351);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUSEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c352) {
            s1 = peg$c352;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c353);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUSEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c354) {
            s1 = peg$c354;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c355);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFTEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c356) {
            s1 = peg$c356;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c357);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHTEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c358) {
            s1 = peg$c358;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c359);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c360) {
            s1 = peg$c360;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c361);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHATEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c362) {
            s1 = peg$c362;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c363);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOREQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c364) {
            s1 = peg$c364;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c365);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c366;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c367);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSCOPEOP() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c368) {
            s1 = peg$c368;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c369);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0,
              s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c370);
            }
          }
          return s0;
        }
        function buildRecursiveBinop(a, b) {
          var ret = a;
          for (var i = 0; i < b.length; i++) {
            ret = addPositionInfo({
              type: 'BinOpExpression',
              left: ret,
              op: b[i][0],
              right: b[i][1]
            });
          }
          return ret;
        }
        ;
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.eLine = posDetails.line;
          r.eColumn = posDetails.column;
          r.eOffset = peg$currPos;
          posDetails = peg$computePosDetails(peg$savedPos);
          r.sLine = posDetails.line;
          r.sColumn = posDetails.column;
          r.sOffset = peg$savedPos;
          return r;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    })();
  }, {}],
  2: [function(require, module, exports) {
    var Debugger,
        Runtime;
    Runtime = require("./rt");
    Debugger = function() {
      this.src = "";
      this.prevNode = null;
      this.done = false;
      this.conditions = {
        isStatement: function(prevNode, newStmt) {
          return newStmt != null ? newStmt.type.indexOf("Statement" >= 0) : void 0;
        },
        positionChanged: function(prevNode, newStmt) {
          return (prevNode != null ? prevNode.eOffset : void 0) !== newStmt.eOffset || (prevNode != null ? prevNode.sOffset : void 0) !== newStmt.sOffset;
        },
        lineChanged: function(prevNode, newStmt) {
          return (prevNode != null ? prevNode.sLine : void 0) !== newStmt.sLine;
        }
      };
      this.stopConditions = {
        isStatement: false,
        positionChanged: false,
        lineChanged: true
      };
      return this;
    };
    Debugger.prototype.start = function(rt, gen) {
      this.rt = rt;
      return this.gen = gen;
    };
    Debugger.prototype.continue = function() {
      var active,
          curStmt,
          done,
          name,
          ref;
      while (true) {
        done = this.next();
        if (done !== false) {
          return done;
        }
        curStmt = this.nextNode();
        ref = this.stopConditions;
        for (name in ref) {
          active = ref[name];
          if (active) {
            if (this.conditions[name](this.prevNode, curStmt)) {
              return false;
            }
          }
        }
      }
    };
    Debugger.prototype.next = function() {
      var ngen;
      this.prevNode = this.nextNode();
      ngen = this.gen.next();
      if (ngen.done) {
        this.done = true;
        return ngen.value;
      } else {
        return false;
      }
    };
    Debugger.prototype.nextLine = function() {
      var s;
      s = this.nextNode();
      return this.src.slice(s.sOffset, s.eOffset).trim();
    };
    Debugger.prototype.nextNode = function() {
      if (this.done) {
        return {
          sOffset: -1,
          sLine: -1,
          sColumn: -1,
          eOffset: -1,
          eLine: -1,
          eColumn: -1
        };
      } else {
        return this.rt.interp.currentNode;
      }
    };
    Debugger.prototype.setVariable = function(name) {
      return this.rt.writeVar(name);
    };
    Debugger.prototype.variable = function(name) {
      var i,
          ref,
          ref1,
          ret,
          scopeIndex,
          usedName,
          v,
          val;
      if (name) {
        v = this.rt.readVar(name);
        return {
          type: this.rt.makeTypeString(v.t),
          value: v.v
        };
      } else {
        usedName = new Set();
        ret = [];
        for (scopeIndex = i = ref = this.rt.scope.length - 1; i >= 0; scopeIndex = i += -1) {
          ref1 = this.rt.scope[scopeIndex];
          for (name in ref1) {
            val = ref1[name];
            if ((typeof val === 'undefined' ? 'undefined' : $traceurRuntime.typeof(val)) === "object" && "t" in val && "v" in val) {
              if (!usedName.has(name)) {
                usedName.add(name);
                ret.push({
                  name: name,
                  type: this.rt.makeTypeString(val.t),
                  value: this.rt.makeValueString(val)
                });
              }
            }
          }
        }
        return ret;
      }
    };
    module.exports = Debugger;
  }, {"./rt": 29}],
  3: [function(require, module, exports) {
    module.exports = function() {
      var defaultOpHandler,
          defaults;
      defaults = this;
      this.config = {
        specifiers: ["const", "inline", "_stdcall", "extern", "static", "auto", "register"],
        charTypes: ["char", "signed char", "unsigned char", "wchar_t", "unsigned wchar_t", "char16_t", "unsigned char16_t", "char32_t", "unsigned char32_t"],
        intTypes: ["short", "short int", "signed short", "signed short int", "unsigned short", "unsigned short int", "int", "signed int", "unsigned", "unsigned int", "long", "long int", "long int", "signed long", "signed long int", "unsigned long", "unsigned long int", "long long", "long long int", "long long int", "signed long long", "signed long long int", "unsigned long long", "unsigned long long int", "bool"],
        limits: {
          "char": {
            max: 0x7f,
            min: 0x00,
            bytes: 1
          },
          "signed char": {
            max: 0x7f,
            min: -0x80,
            bytes: 1
          },
          "unsigned char": {
            max: 0xff,
            min: 0x00,
            bytes: 1
          },
          "wchar_t": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned wchar_t": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "char16_t": {
            max: 0x7fff,
            min: -0x8000,
            bytes: 4
          },
          "unsigned char16_t": {
            max: 0xffff,
            min: 0x0000,
            bytes: 4
          },
          "char32_t": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned char32_t": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "short": {
            max: 0x7fff,
            min: -0x8000,
            bytes: 2
          },
          "unsigned short": {
            max: 0xffff,
            min: 0x0000,
            bytes: 2
          },
          "int": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "long": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned long": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "long long": {
            max: 0x7fffffffffffffff,
            min: -0x8000000000000000,
            bytes: 8
          },
          "unsigned long long": {
            max: 0xffffffffffffffff,
            min: 0x0000000000000000,
            bytes: 8
          },
          "float": {
            max: 3.40282346638529e+038,
            min: -3.40282346638529e+038,
            bytes: 4
          },
          "double": {
            max: 2e308,
            min: -2e308,
            bytes: 8
          },
          "pointer": {
            max: void 0,
            min: void 0,
            bytes: 4
          },
          "bool": {
            max: 1,
            min: 0,
            bytes: 1
          }
        },
        loadedLibraries: []
      };
      this.config.limits["short int"] = this.config.limits["short"];
      this.config.limits["signed short"] = this.config.limits["short"];
      this.config.limits["signed short int"] = this.config.limits["short"];
      this.config.limits["unsigned short int"] = this.config.limits["unsigned short"];
      this.config.limits["signed int"] = this.config.limits["int"];
      this.config.limits["unsigned int"] = this.config.limits["unsigned"];
      this.config.limits["long int"] = this.config.limits["long"];
      this.config.limits["long int"] = this.config.limits["long"];
      this.config.limits["signed long"] = this.config.limits["long"];
      this.config.limits["signed long int"] = this.config.limits["long"];
      this.config.limits["unsigned long int"] = this.config.limits["unsigned long"];
      this.config.limits["long long int"] = this.config.limits["long long"];
      this.config.limits["long long int"] = this.config.limits["long long"];
      this.config.limits["signed long long"] = this.config.limits["long long"];
      this.config.limits["signed long long int"] = this.config.limits["long long"];
      this.config.limits["unsigned long long int"] = this.config.limits["unsigned long long"];
      this.numericTypeOrder = ["char", "signed char", "short", "short int", "signed short", "signed short int", "int", "signed int", "long", "long int", "long int", "signed long", "signed long int", "long long", "long long int", "long long int", "signed long long", "signed long long int", "float", "double"];
      defaultOpHandler = {
        "o(*)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support * on " + rt.makeTypeString(r.t));
            }
            ret = l.v * r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(/)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support / on " + rt.makeTypeString(r.t));
            }
            ret = l.v / r.v;
            if (rt.isIntegerType(l.t) && rt.isIntegerType(r.t)) {
              ret = Math.floor(ret);
            }
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(%)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support % on " + rt.makeTypeString(r.t));
            }
            ret = l.v % r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(+)": {"#default": function(rt, l, r) {
            var i,
                ret,
                rett;
            if (r === void 0) {
              return l;
            } else {
              if (!rt.isNumericType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support + on " + rt.makeTypeString(r.t));
              }
              if (rt.isArrayType(r.t)) {
                i = rt.cast(rt.intTypeLiteral, l).v;
                return rt.val(r.t, rt.makeArrayPointerValue(r.v.target, r.v.position + i));
              } else {
                ret = l.v + r.v;
                rett = rt.promoteNumeric(l.t, r.t);
                return rt.val(rett, ret);
              }
            }
          }},
        "o(-)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (r === void 0) {
              rett = l.v > 0 ? rt.getSignedType(l.t) : l.t;
              return rt.val(rett, -l.v);
            } else {
              if (!rt.isNumericType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support - on " + rt.makeTypeString(r.t));
              }
              ret = l.v - r.v;
              rett = rt.promoteNumeric(l.t, r.t);
              return rt.val(rett, ret);
            }
          }},
        "o(<<)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support << on " + rt.makeTypeString(r.t));
            }
            ret = l.v << r.v;
            rett = l.t;
            return rt.val(rett, ret);
          }},
        "o(>>)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support >> on " + rt.makeTypeString(r.t));
            }
            ret = l.v >> r.v;
            rett = l.t;
            return rt.val(rett, ret);
          }},
        "o(<)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support < on " + rt.makeTypeString(r.t));
            }
            ret = l.v < r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(<=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support <= on " + rt.makeTypeString(r.t));
            }
            ret = l.v <= r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(>)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support > on " + rt.makeTypeString(r.t));
            }
            ret = l.v > r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(>=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support >= on " + rt.makeTypeString(r.t));
            }
            ret = l.v >= r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(==)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support == on " + rt.makeTypeString(r.t));
            }
            ret = l.v === r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(!=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support != on " + rt.makeTypeString(r.t));
            }
            ret = l.v !== r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var ret,
                rett,
                t;
            if (r === void 0) {
              if (l.array) {
                return rt.val(rt.arrayPointerType(l.t, l.array.length), rt.makeArrayPointerValue(l.array, l.arrayIndex));
              } else {
                t = rt.normalPointerType(l.t);
                return rt.val(t, rt.makeNormalPointerValue(l));
              }
            } else {
              if (!rt.isIntegerType(l.t) || !rt.isNumericType(r.t) || !rt.isIntegerType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support & on " + rt.makeTypeString(r.t));
              }
              ret = l.v & r.v;
              rett = rt.promoteNumeric(l.t, r.t);
              return rt.val(rett, ret);
            }
          }},
        "o(^)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ^ on " + rt.makeTypeString(r.t));
            }
            ret = l.v ^ r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(|)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support | on " + rt.makeTypeString(r.t));
            }
            ret = l.v | r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(,)": {"#default": function(rt, l, r) {
            return r;
          }},
        "o(=)": {"#default": function(rt, l, r) {
            if (l.left) {
              l.v = rt.cast(l.t, r).v;
              return l;
            } else {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
          }},
        "o(+=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(+)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(-=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(-)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(*=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(*)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(/=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(/)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(%=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(%)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(<<=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(<<)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(>>=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(>>)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(&=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(&)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(^=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(^)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(|=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(|)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(++)": {"#default": function(rt, l, dummy) {
            var b;
            if (!rt.isNumericType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support increment");
            }
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              b = l.v;
              l.v = l.v + 1;
              if (rt.inrange(l.t, l.v)) {
                return rt.val(l.t, b);
              }
              rt.raiseException(("overflow during post-increment " + rt.makeValString(l)));
            } else {
              l.v = l.v + 1;
              if (rt.inrange(l.t, l.v)) {
                return l;
              }
              rt.raiseException(("overflow during pre-increment " + rt.makeValString(l)));
            }
          }},
        "o(--)": {"#default": function(rt, l, dummy) {
            var b;
            if (!rt.isNumericType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support decrement");
            }
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              b = l.v;
              l.v = l.v - 1;
              if (rt.inrange(l.t, l.v)) {
                return rt.val(l.t, b);
              }
              rt.raiseException("overflow during post-decrement");
            } else {
              l.v = l.v - 1;
              b = l.v;
              if (rt.inrange(l.t, l.v)) {
                return l;
              }
              rt.raiseException("overflow during pre-decrement");
            }
          }},
        "o(~)": {"#default": function(rt, l, dummy) {
            var ret,
                rett;
            if (!rt.isIntegerType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ~ on itself");
            }
            ret = ~l.v;
            rett = rt.promoteNumeric(l.t, rt.intTypeLiteral);
            return rt.val(rett, ret);
          }},
        "o(!)": {"#default": function(rt, l, dummy) {
            var ret,
                rett;
            if (!rt.isIntegerType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ! on itself");
            }
            ret = l.v ? 0 : 1;
            rett = l.t;
            return rt.val(rett, ret);
          }}
      };
      this.types = {"global": {}};
      this.types["(char)"] = defaultOpHandler;
      this.types["(signed char)"] = defaultOpHandler;
      this.types["(unsigned char)"] = defaultOpHandler;
      this.types["(short)"] = defaultOpHandler;
      this.types["(short int)"] = defaultOpHandler;
      this.types["(signed short)"] = defaultOpHandler;
      this.types["(signed short int)"] = defaultOpHandler;
      this.types["(unsigned short)"] = defaultOpHandler;
      this.types["(unsigned short int)"] = defaultOpHandler;
      this.types["(int)"] = defaultOpHandler;
      this.types["(signed int)"] = defaultOpHandler;
      this.types["(unsigned)"] = defaultOpHandler;
      this.types["(unsigned int)"] = defaultOpHandler;
      this.types["(long)"] = defaultOpHandler;
      this.types["(long int)"] = defaultOpHandler;
      this.types["(long int)"] = defaultOpHandler;
      this.types["(signed long)"] = defaultOpHandler;
      this.types["(signed long int)"] = defaultOpHandler;
      this.types["(unsigned long)"] = defaultOpHandler;
      this.types["(unsigned long int)"] = defaultOpHandler;
      this.types["(long long)"] = defaultOpHandler;
      this.types["(long long int)"] = defaultOpHandler;
      this.types["(long long int)"] = defaultOpHandler;
      this.types["(signed long long)"] = defaultOpHandler;
      this.types["(signed long long int)"] = defaultOpHandler;
      this.types["(unsigned long long)"] = defaultOpHandler;
      this.types["(unsigned long long int)"] = defaultOpHandler;
      this.types["(float)"] = defaultOpHandler;
      this.types["(double)"] = defaultOpHandler;
      this.types["(bool)"] = defaultOpHandler;
      this.types["pointer"] = {
        "o(==)": {"#default": function(rt, l, r) {
            if (rt.isTypeEqualTo(l.t, r.t)) {
              if (l.t.ptrType === "array") {
                return l.v.target === r.v.target && (l.v.target === null || l.v.position === r.v.position);
              } else {
                return l.v.target === r.v.target;
              }
            }
            return false;
          }},
        "o(!=)": {"#default": function(rt, l, r) {
            return !rt.types["pointer"]["=="]["#default"](rt, l, r);
          }},
        "o(,)": {"#default": function(rt, l, r) {
            return r;
          }},
        "o(=)": {"#default": function(rt, l, r) {
            var t;
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            t = rt.cast(l.t, r);
            l.t = t.t;
            l.v = t.v;
            return l;
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var t;
            if (r === void 0) {
              if (l.array) {
                return rt.val(rt.arrayPointerType(l.t, l.array.length), rt.makeArrayPointerValue(l.array, l.arrayIndex));
              } else {
                t = rt.normalPointerType(l.t);
                return rt.val(t, rt.makeNormalPointerValue(l));
              }
            } else {
              rt.raiseException("you cannot cast bitwise and on pointer");
            }
          }},
        "o(())": {"#default": function(rt, l, bindThis, args) {
            if (!rt.isFunctionType(l.v.target)) {
              rt.raiseException(("pointer target(" + rt.makeValueString(l.v.target) + ") is not a function"));
            }
            return rt.types["function"]["o(())"]["default"](rt, l.v.target, bindThis, args);
          }}
      };
      this.types["function"] = {
        "o(())": {"#default": function(rt, l, bindThis, args) {
            if (l.t.type === "pointer" && l.t.targetType.type === "function") {
              l = l.v.target;
            }
            if (l.v.target === null) {
              rt.raiseException(("function " + l.v.name + " does not seem to be implemented"));
            }
            return rt.getCompatibleFunc(l.v.defineType, l.v.name, args).apply((void 0), $traceurRuntime.spread([rt, bindThis], args));
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var t;
            if (r === void 0) {
              t = rt.normalPointerType(l.t);
              return rt.val(t, rt.makeNormalPointerValue(l));
            } else {
              rt.raiseException("you cannot cast bitwise and on function");
            }
          }}
      };
      this.types["pointer_normal"] = {
        "o(*)": {"#default": function(rt, l, r) {
            if (r === void 0) {
              return l.v.target;
            } else {
              rt.raiseException("you cannot multiply a pointer");
            }
          }},
        "o(->)": {"#default": function(rt, l, r) {
            return rt.getMember(l.v.target, r);
          }}
      };
      this.types["pointer_array"] = {
        "o(*)": {"#default": function(rt, l, r) {
            var arr,
                ret;
            if (r === void 0) {
              arr = l.v.target;
              if (l.v.position >= arr.length) {
                rt.raiseException("index out of bound " + l.v.position + " >= " + arr.length);
              } else if (l.v.position < 0) {
                rt.raiseException("negative index " + l.v.position);
              }
              ret = arr[l.v.position];
              ret.array = arr;
              ret.arrayIndex = l.v.position;
              return ret;
            } else {
              rt.raiseException("you cannot multiply a pointer");
            }
          }},
        "o([])": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(+)"]["#default"](rt, l, r);
            return rt.types["pointer_array"]["o(*)"]["#default"](rt, r);
          }},
        "o(->)": {"#default": function(rt, l, r) {
            l = rt.types["pointer_array"]["o(*)"]["#default"](rt, l);
            return rt.getMember(l, r);
          }},
        "o(-)": {"#default": function(rt, l, r) {
            var i;
            if (rt.isNumericType(r.t)) {
              i = rt.cast(rt.intTypeLiteral, r).v;
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position - i));
            } else if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position - r.v.position;
              } else {
                rt.raiseException("you cannot perform minus on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(<)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position < r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(>)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position > r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(<=)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position <= r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(>=)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position >= r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(+)": {"#default": function(rt, l, r) {
            var i;
            if (rt.isNumericType(r.t)) {
              i = rt.cast(rt.intTypeLiteral, r).v;
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position + i));
            } else {
              rt.raiseException("cannot add non-numeric to a pointer");
            }
          }},
        "o(+=)": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(+)"]["#default"](rt, l, r);
            return rt.types["pointer"]["="]["#default"](rt, l, r);
          }},
        "o(-=)": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(-)"]["#default"](rt, l, r);
            return rt.types["pointer"]["="]["#default"](rt, l, r);
          }},
        "o(++)": {"#default": function(rt, l, dummy) {
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position++));
            } else {
              l.v.position++;
              return l;
            }
          }},
        "o(--)": {"#default": function(rt, l, dummy) {
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position--));
            } else {
              l.v.position--;
              return l;
            }
          }}
      };
      return this;
    };
  }, {}],
  4: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _plusX,
            _readBatteryMillivolts,
            type,
            typeSig;
        type = rt.newClass("OrangutanAnalog2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _readBatteryMillivolts = function(rt, _this) {
          return rt.val(rt.intTypeLiteral, 0, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        return rt.regFunc(_readBatteryMillivolts, type, "readBatteryMillivolts", [], rt.intTypeLiteral);
      }};
  }, {}],
  5: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _isPlaying,
            _playFromProgramSpace,
            _plusX,
            pchar,
            type,
            typeSig;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        type = rt.newClass("OrangutanBuzzer2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _playFromProgramSpace = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _isPlaying = function(rt, _this) {
          return rt.val(rt.boolTypeLiteral, 1, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc(_playFromProgramSpace, type, "playFromProgramSpace", [pchar], rt.voidTypeLiteral);
        return rt.regFunc(_isPlaying, type, "isPlaying", [], rt.boolTypeLiteral);
      }};
  }, {}],
  6: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _clear,
            _gotoXY,
            _loadCustomCharacter,
            _print1,
            _print2,
            _print3,
            _printFromProgramSpace,
            pchar,
            type,
            typeSig;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        type = rt.newClass("OrangutanLCD2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _print1 = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _print2 = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _print3 = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _loadCustomCharacter = function(rt, _this, a, b) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _clear = function(rt, _this) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _printFromProgramSpace = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _gotoXY = function(rt, _this, x, y) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        rt.regFunc(_print1, type, "print", [rt.charTypeLiteral], rt.voidTypeLiteral);
        rt.regFunc(_print2, type, "print", [pchar], rt.voidTypeLiteral);
        rt.regFunc(_print3, type, "print", [rt.intTypeLiteral], rt.voidTypeLiteral);
        rt.regFunc(_loadCustomCharacter, type, "loadCustomCharacter", [pchar, rt.intTypeLiteral], rt.voidTypeLiteral);
        rt.regFunc(_clear, type, "clear", [], rt.voidTypeLiteral);
        rt.regFunc(_printFromProgramSpace, type, "printFromProgramSpace", [pchar], rt.voidTypeLiteral);
        return rt.regFunc(_gotoXY, type, "gotoXY", [rt.intTypeLiteral, rt.intTypeLiteral], rt.voidTypeLiteral);
      }};
  }, {}],
  7: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _left,
            _plusX,
            _right,
            type,
            typeSig;
        type = rt.newClass("OrangutanLEDs2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _left = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _right = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc(_left, type, "left", [rt.intTypeLiteral], rt.voidTypeLiteral);
        return rt.regFunc(_right, type, "right", [rt.intTypeLiteral], rt.voidTypeLiteral);
      }};
  }, {}],
  8: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _plusX,
            _setSpeeds,
            type,
            typeSig;
        type = rt.newClass("OrangutanMotors2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }, {
          name: "vright",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 0, true);
          }
        }, {
          name: "vleft",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 0, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _setSpeeds = function(rt, _this, a, b) {
          _this.v.members["vleft"].v = a.v;
          _this.v.members["vright"].v = b.v;
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        return rt.regFunc(_setSpeeds, type, "setSpeeds", [rt.intTypeLiteral, rt.intTypeLiteral], rt.voidTypeLiteral);
      }};
  }, {}],
  9: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _isPressed,
            _plusX,
            _waitForRelease,
            type,
            typeSig;
        type = rt.newClass("OrangutanPushbuttons2", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _isPressed = function(rt, _this, a) {
          return rt.val(rt.boolTypeLiteral, 1, false);
        };
        _waitForRelease = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc(_isPressed, type, "isPressed", [rt.intTypeLiteral], rt.boolTypeLiteral);
        return rt.regFunc(_waitForRelease, type, "waitForRelease", [rt.intTypeLiteral], rt.voidTypeLiteral);
      }};
  }, {}],
  10: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _calibrateLineSensors,
            _init,
            _plusX,
            _readLine,
            puint,
            type,
            typeSig;
        puint = rt.normalPointerType(rt.unsignedintTypeLiteral);
        type = rt.newClass("Pololu3pi", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }, {
          name: "sensorValues",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 0, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        _init = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _calibrateLineSensors = function(rt, _this, a) {
          return rt.val(rt.voidTypeLiteral, 0, false);
        };
        _readLine = function(rt, _this, a, b) {
          var resultValue;
          resultValue = _this.v.members["sensorValues"].v;
          return rt.val(rt.unsignedintTypeLiteral, resultValue, false);
        };
        rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc(_init, type, "init", [rt.intTypeLiteral], rt.voidTypeLiteral);
        rt.regFunc(_calibrateLineSensors, type, "calibrateLineSensors", [rt.intTypeLiteral], rt.voidTypeLiteral);
        return rt.regFunc(_readLine, type, "readLine", [puint, rt.intTypeLiteral], rt.unsignedintTypeLiteral);
      }};
  }, {}],
  11: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _plusX,
            type,
            typeSig;
        type = rt.newClass("PololuQTRSensors", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        return rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
      }};
  }, {}],
  12: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isdigit", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            return rt.getFunc("global", "isalpha", [rt.intTypeLiteral])(rt, _this, x);
          }
          return c;
        }), "global", "isalnum", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isdigit", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isupper", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            return rt.getFunc("global", "islower", [rt.intTypeLiteral])(rt, _this, x);
          }
          return c;
        }), "global", "isalpha", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var ref,
              v;
          v = (ref = x.v) === 0x20 || ref === 0x09 || ref === 0x0a || ref === 0x0b || ref === 0x0c || ref === 0x0d ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isspace", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= 0x00 && x.v <= 0x1f || x.v === 0x7f ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "iscntrl", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v > 0x1f && x.v !== 0x7f ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isprint", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isspace", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            c = rt.getFunc("global", "isgraph", [rt.intTypeLiteral])(rt, _this, x);
            if (!c.v) {
              return rt.val(rt.intTypeLiteral, 1);
            }
          }
          return rt.val(rt.intTypeLiteral, 0);
        }), "global", "isgraph", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "a".charCodeAt(0) && x.v <= "z".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "islower", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "A".charCodeAt(0) && x.v <= "Z".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isupper", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isgraph", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            c = rt.getFunc("global", "isalnum", [rt.intTypeLiteral])(rt, _this, x);
            if (!c.v) {
              return rt.val(rt.intTypeLiteral, 1);
            }
          }
          return rt.val(rt.intTypeLiteral, 0);
        }), "global", "ispunct", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "A".charCodeAt(0) && x.v <= "F".charCodeAt(0) || x.v >= "a".charCodeAt(0) && x.v <= "f".charCodeAt(0) || x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isxdigit", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isupper", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            return rt.val(rt.intTypeLiteral, x.v + 32);
          }
          return x;
        }), "global", "tolower", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "islower", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            return rt.val(rt.intTypeLiteral, x.v - 32);
          }
          return x;
        }), "global", "toupper", [rt.intTypeLiteral], rt.intTypeLiteral);
      }};
  }, {}],
  13: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var g,
            tDouble;
        tDouble = rt.doubleTypeLiteral;
        g = "global";
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.cos(x.v));
        }), g, "cos", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sin(x.v));
        }), g, "sin", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.tan(x.v));
        }), g, "tan", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.acos(x.v));
        }), g, "acos", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.asin(x.v));
        }), g, "asin", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.atan(x.v));
        }), g, "atan", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, y, x) {
          return rt.val(tDouble, Math.atan(y.v / x.v));
        }), g, "atan2", [tDouble, tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.cosh(x.v));
        }), g, "cosh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sinh(x.v));
        }), g, "sinh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.tanh(x.v));
        }), g, "tanh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.acosh(x.v));
        }), g, "acosh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.asinh(x.v));
        }), g, "asinh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.atanh(x.v));
        }), g, "atanh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.exp(x.v));
        }), g, "exp", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.log(x.v));
        }), g, "log", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.log10(x.v));
        }), g, "log10", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x, y) {
          return Math.pow(x.v, y.v);
        }), g, "pow", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sqrt(x.v));
        }), g, "sqrt", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.ceil(x.v));
        }), g, "ceil", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.floor(x.v));
        }), g, "floor", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.abs(x.v));
        }), g, "fabs", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.abs(x.v));
        }), g, "abs", [tDouble], tDouble);
      }};
  }, {}],
  14: [function(require, module, exports) {
    var EOF,
        NULL,
        format_type_map,
        printf,
        validate_format;
    printf = require("printf");
    EOF = 0;
    NULL = -1;
    format_type_map = function(rt, ctrl) {
      switch (ctrl) {
        case "d":
        case "i":
          return rt.intTypeLiteral;
        case "u":
        case "o":
        case "x":
        case "X":
          return rt.unsignedintTypeLiteral;
        case "f":
        case "F":
          return rt.floatTypeLiteral;
        case "e":
        case "E":
        case "g":
        case "G":
        case "a":
        case "A":
          return rt.doubleTypeLiteral;
        case "c":
          return rt.charTypeLiteral;
        case "s":
          return rt.normalPointerType(rt.charTypeLiteral);
        case "p":
          return rt.normalPointerType(rt.voidTypeLiteral);
        case "n":
          return rt.raiseException("%n is not supported");
      }
    };
    validate_format = function(rt, format) {
      for (var params = [],
          $__3 = 2; $__3 < arguments.length; $__3++)
        params[$__3 - 2] = arguments[$__3];
      var casted,
          ctrl,
          i,
          re,
          results,
          target,
          type,
          val;
      i = 0;
      re = /%(?:[-+ #0])?(?:[0-9]+|\*)?(?:\.(?:[0-9]+|\*))?([diuoxXfFeEgGaAcspn])/g;
      results = [];
      while ((ctrl = re.exec(format)) != null) {
        type = format_type_map(rt, ctrl[1]);
        if (params.length <= i) {
          rt.raiseException(("insufficient arguments (at least " + (i + 1) + " is required)"));
        }
        target = params[i++];
        casted = rt.cast(type, target);
        if (rt.isStringType(casted.t)) {
          results.push(val = rt.getStringFromCharArray(casted));
        } else {
          results.push(val = casted.v);
        }
      }
      return results;
    };
    module.exports = {load: function(rt) {
        var _ASCII,
            __printf,
            __scanf,
            _consume_next_char,
            _consume_next_line,
            _deal_type,
            _get_ASCII_char,
            _get_char,
            _get_float,
            _get_hex,
            _get_input,
            _get_integer,
            _get_line,
            _get_octal,
            _get_special_char,
            _get_string,
            _getchar,
            _gets,
            _hex2int,
            _int_at_octal,
            _octal2int,
            _printf,
            _putchar,
            _puts,
            _regslashs,
            _scanf,
            _set_pointer_value,
            _sprintf,
            _sscanf,
            _strcpy,
            _strip_slashes,
            char_pointer,
            input_stream,
            stdio;
        char_pointer = rt.normalPointerType(rt.charTypeLiteral);
        stdio = rt.config.stdio;
        input_stream = stdio.drain();
        _consume_next_char = function() {
          var char_return;
          char_return = "";
          if (input_stream.length > 0) {
            char_return = input_stream[0];
            input_stream = input_stream.substr(1);
            return char_return;
          } else {
            throw "EOF";
          }
        };
        _consume_next_line = function() {
          input_stream;
          var next_line_break,
              retval;
          next_line_break = input_stream.indexOf('\n');
          if (next_line_break > -1) {
            retval = input_stream.substr(0, next_line_break);
            input_stream = input_stream.replace((retval + "\n"), '');
          } else {
            retval = input_stream;
            input_stream = "";
          }
          return retval;
        };
        _strcpy = require("./shared/cstring_strcpy");
        __printf = function(format) {
          for (var params = [],
              $__4 = 1; $__4 < arguments.length; $__4++)
            params[$__4 - 1] = arguments[$__4];
          var parsed_params,
              retval;
          if (rt.isStringType(format.t)) {
            format = rt.getStringFromCharArray(format);
            parsed_params = validate_format.apply((void 0), $traceurRuntime.spread([rt, format], params));
            retval = printf.apply((void 0), $traceurRuntime.spread([format], parsed_params));
            return rt.makeCharArrayFromString(retval);
          } else {
            return rt.raiseException("format must be a string");
          }
        };
        _sprintf = function(rt, _this, target, format) {
          for (var params = [],
              $__5 = 4; $__5 < arguments.length; $__5++)
            params[$__5 - 4] = arguments[$__5];
          var retval;
          retval = __printf.apply((void 0), $traceurRuntime.spread([format], params));
          _strcpy(rt, null, [target, retval]);
          return rt.val(rt.intTypeLiteral, retval.length);
        };
        rt.regFunc(_sprintf, "global", "sprintf", [char_pointer, char_pointer, "?"], rt.intTypeLiteral);
        _printf = function(rt, _this, format) {
          for (var params = [],
              $__6 = 3; $__6 < arguments.length; $__6++)
            params[$__6 - 3] = arguments[$__6];
          var retval;
          retval = __printf.apply((void 0), $traceurRuntime.spread([format], params));
          retval = rt.getStringFromCharArray(retval);
          stdio.write(retval);
          return rt.val(rt.intTypeLiteral, retval.length);
        };
        rt.regFunc(_printf, "global", "printf", [char_pointer, "?"], rt.intTypeLiteral);
        _getchar = function(rt, _this) {
          var char,
              error;
          try {
            char = _consume_next_char();
            return rt.val(rt.intTypeLiteral, char.charCodeAt(0));
          } catch (error1) {
            error = error1;
            return rt.val(rt.intTypeLiteral, EOF);
          }
        };
        rt.regFunc(_getchar, "global", "getchar", [], rt.intTypeLiteral);
        _gets = function(rt, _this, charPtr) {
          var destArray,
              i,
              j,
              ref,
              return_value;
          return_value = _consume_next_line();
          destArray = charPtr.v.target;
          for (i = j = 0, ref = return_value.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            try {
              destArray[i] = rt.val(rt.charTypeLiteral, return_value.charCodeAt(i));
            } catch (error1) {
              destArray[i] = rt.val(rt.charTypeLiteral, 0);
            }
          }
          destArray[return_value.length] = rt.val(rt.charTypeLiteral, 0);
          return rt.val(char_pointer, charPtr);
        };
        rt.regFunc(_gets, "global", "gets", [char_pointer], char_pointer);
        _putchar = function(rt, _this, char) {
          var print_mask;
          print_mask = rt.makeCharArrayFromString("%c");
          _printf(rt, null, print_mask, char);
          return char;
        };
        rt.regFunc(_putchar, "global", "putchar", [rt.charTypeLiteral], rt.intTypeLiteral);
        _puts = function(rt, _this, charPtr) {
          var print_mask;
          print_mask = rt.makeCharArrayFromString("%s");
          _printf(rt, null, print_mask, charPtr);
          return rt.val(rt.intTypeLiteral, 1);
        };
        rt.regFunc(_puts, "global", "puts", [char_pointer], rt.intTypeLiteral);
        _ASCII = {
          a: 'a'.charCodeAt(0),
          f: 'f'.charCodeAt(0),
          A: 'A'.charCodeAt(0),
          F: 'F'.charCodeAt(0),
          0: '0'.charCodeAt(0),
          8: '8'.charCodeAt(0),
          9: '9'.charCodeAt(0)
        };
        _hex2int = function(str) {
          var _int_at_hex,
              digit,
              i,
              j,
              num,
              ref,
              ret;
          ret = 0;
          digit = 0;
          str = str.replace(/^[0O][Xx]/, '');
          for (i = j = ref = str.length - 1; j >= 0; i = j += -1) {
            num = _int_at_hex(str[i], digit++);
            if (num !== null) {
              ret += num;
            } else {
              throw new Error('invalid hex ' + str);
            }
          }
          ret;
          return _int_at_hex = function(c, digit) {
            var ascii;
            ret = null;
            ascii = c.charCodeAt(0);
            if (_ASCII.a <= ascii && ascii <= _ASCII.f) {
              ret = ascii - _ASCII.a(+10);
            } else if (_ASCII.A <= ascii && ascii <= _ASCII.F) {
              ret = ascii - _ASCII.a(+10);
            } else if (_ASCII[0] < ascii && ascii <= _ASCII[9]) {
              ret = ascii - _ASCII[0];
            } else {
              throw new Error(("Ivalid ascii [" + c + "]"));
            }
            num *= Math.pow(16, digit);
            return ret;
          };
        };
        _octal2int = function(str) {
          var digit,
              i,
              j,
              num,
              ref,
              ret;
          str = str.replace(/^0/, '');
          ret = 0;
          digit = 0;
          for (i = j = ref = str.length - 1; j >= 0; i = j += -1) {
            num = _int_at_octal(str[i], digit++);
            if (num !== null) {
              ret += num;
            } else {
              throw new Error(("invalid octal " + str));
            }
          }
          return ret;
        };
        _int_at_octal = function(c, digit) {
          var ascii,
              num;
          num = null;
          ascii = c.charCodeAt(0);
          if (ascii >= _ASCII[0] && ascii <= _ASCII[8]) {
            num = ascii - _ASCII[0];
          } else {
            throw new Error(("invalid char at [" + c + "]"));
          }
          num *= Math.pow(8, digit);
          return num;
        };
        _regslashs = function(pre) {
          return pre.replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\|/g, '\\|');
        };
        _strip_slashes = function(str) {
          return str.replace(/\\([\sA-Za-z\\]|[0-7]{1,3})/g, function(str, c) {
            switch (c) {
              case "\\":
                return "\\";
              case "0":
                return "\u0000";
              default:
                if (/^\w$/.test(c)) {
                  return _get_special_char(c);
                } else if (/^\s$/.test(c)) {
                  return c;
                } else if (/([0-7]{1,3})/.test(c)) {
                  return _get_ASCII_char(c);
                }
                return str;
            }
          });
        };
        _get_ASCII_char = function(str) {
          var num;
          num = _octal2int(str);
          return String.fromCharCode(num);
        };
        _get_special_char = function(letter) {
          switch (letter.toLowerCase()) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return "\n";
            case "r":
              return "\r";
            case "t":
              return "\t";
            case "v":
              return "\v";
            default:
              return letter;
          }
        };
        _get_input = function(pre, next, match, type) {
          var after_match,
              before_match,
              m,
              replace,
              result,
              tmp;
          result = void 0;
          tmp = input_stream;
          replace = ("(" + match + ")");
          if (type === 'STR' && next.trim().length > 0) {
            before_match = _regslashs(pre);
            after_match = _regslashs(next) + '[\\w\\W]*';
            if (before_match.length) {
              tmp = tmp.replace(new RegExp(before_match), '');
            }
            tmp = tmp.replace(new RegExp(after_match), '');
          } else {
            replace = _regslashs(pre) + replace;
          }
          m = tmp.match(new RegExp(replace));
          if (!m) {
            return null;
          }
          result = m[1];
          input_stream = input_stream.substr(input_stream.indexOf(result)).replace(result, '').replace(next, '');
          return result;
        };
        _get_integer = function(pre, next) {
          var text;
          text = _get_input(pre, next, '[-]?[A-Za-z0-9]+');
          if (!text) {
            return null;
          } else if (text[0] === '0') {
            if (text[1] === 'x' || text[1] === 'X') {
              return _hex2int(text);
            } else {
              return _octal2int(text);
            }
          } else {
            return parseInt(text);
          }
        };
        _get_float = function(pre, next) {
          var text;
          text = _get_input(pre, next, '[-]?[0-9]+[\.]?[0-9]*');
          return parseFloat(text);
        };
        _get_hex = function(pre, next) {
          var text;
          text = _get_input(pre, next, '[A-Za-z0-9]+');
          return _hex2int(text);
        };
        _get_octal = function(pre, next) {
          var text;
          text = _get_input(pre, next, '[A-Za-z0-9]+');
          return _octal2int(text);
        };
        _get_string = function(pre, next) {
          var text;
          text = _get_input(pre, next, '([\\w\\]=-]|\\S[^\\][^\\ ])+(\\\\[\\w\\ ][\\w\\:]*)*', 'STR');
          if (/\\/.test(text)) {
            text = _strip_slashes(text);
          }
          return text;
        };
        _get_char = function(pre, next) {
          var text;
          text = _get_input(pre, next, '.', 'STR');
          if (/\\/.test(text)) {
            text = _strip_slashes(text);
          }
          return text;
        };
        _get_line = function(pre, next) {
          var text;
          text = _get_input(pre, next, '[^\n\r]*');
          if (/\\/.test(text)) {
            text = _strip_slashes(text);
          }
          return text;
        };
        _deal_type = function(format) {
          ret;
          var next,
              pre,
              res,
              res2,
              ret,
              type;
          res = format.match(/%[A-Za-z]+/);
          res2 = format.match(/[^%]*/);
          if (!res) {
            return null;
          }
          type = res[0];
          pre;
          if (!!res2) {
            pre = res2[0];
          } else {
            pre = null;
          }
          next = format.substr(format.indexOf(type) + type.length);
          switch (type) {
            case "%d":
            case "%ld":
            case "%llu":
            case "%lu":
            case "%u":
              ret = _get_integer(pre, next);
              break;
            case "%c":
              ret = _get_char(pre, next);
              break;
            case "%s":
              ret = _get_string(pre, next);
              break;
            case "%S":
              ret = _get_line(pre, next);
              break;
            case '%x':
            case '%X':
              ret = _get_hex(pre, next);
              break;
            case '%o':
            case '%O':
              ret = _get_octal(pre, next);
              break;
            case '%f':
              ret = _get_float(pre, next);
              break;
            default:
              throw new Error('Unknown type "' + type + '"');
          }
          return ret;
        };
        _set_pointer_value = function(pointer, value) {
          var i,
              j,
              new_value,
              ref,
              results,
              src_array;
          try {
            switch (pointer.t.ptrType) {
              case "normal":
                if (rt.isNumericType(pointer.t.targetType)) {
                  new_value = rt.val(pointer.t.targetType, value, true);
                  return pointer.v.target.v = new_value.v;
                } else {
                  new_value = rt.val(pointer.t.targetType, value.charCodeAt(0), true);
                  return pointer.v.target.v = new_value.v;
                }
                break;
              case "array":
                src_array = rt.makeCharArrayFromString(value);
                if (src_array.v.target.length > pointer.v.target.length) {
                  return rt.raiseException("Not enough memory on pointer");
                } else {
                  results = [];
                  for (i = j = 0, ref = src_array.v.target.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                    try {
                      results.push(pointer.v.target[i] = src_array.v.target[i]);
                    } catch (error1) {
                      results.push(rt.raiseException("Not enough memory on pointer"));
                    }
                  }
                  return results;
                }
                break;
              default:
                return rt.raiseException("Invalid Pointer Type");
            }
          } catch (error1) {
            return rt.raiseException("Memory overflow");
          }
        };
        __scanf = function(format) {
          var j,
              len,
              re,
              results,
              selectors,
              val;
          re = new RegExp('[^%]*%[A-Za-z][^%]*', 'g');
          selectors = format.match(re);
          results = [];
          for (j = 0, len = selectors.length; j < len; j++) {
            val = selectors[j];
            results.push(_deal_type(val));
          }
          return results;
        };
        _scanf = function(rt, _this, pchar) {
          for (var args = [],
              $__7 = 3; $__7 < arguments.length; $__7++)
            args[$__7 - 3] = arguments[$__7];
          var format,
              i,
              j,
              len,
              matched_values,
              val;
          format = rt.getStringFromCharArray(pchar);
          matched_values = __scanf(format);
          for (i = j = 0, len = matched_values.length; j < len; i = ++j) {
            val = matched_values[i];
            _set_pointer_value(args[i], val);
          }
          return rt.val(rt.intTypeLiteral, matched_values.length);
        };
        rt.regFunc(_scanf, "global", "scanf", [char_pointer, "?"], rt.intTypeLiteral);
        _sscanf = function(rt, _this, original_string_pointer, format_pointer) {
          for (var args = [],
              $__8 = 4; $__8 < arguments.length; $__8++)
            args[$__8 - 4] = arguments[$__8];
          var format,
              i,
              j,
              len,
              matched_values,
              original_input_stream,
              original_string,
              val;
          format = rt.getStringFromCharArray(format_pointer);
          original_string = rt.getStringFromCharArray(original_string_pointer);
          original_input_stream = input_stream;
          input_stream = original_string;
          matched_values = __scanf(format);
          for (i = j = 0, len = matched_values.length; j < len; i = ++j) {
            val = matched_values[i];
            _set_pointer_value(args[i], val);
          }
          input_stream = original_input_stream;
          return rt.val(rt.intTypeLiteral, matched_values.length);
        };
        return rt.regFunc(_sscanf, "global", "sscanf", [char_pointer, char_pointer, "?"], rt.intTypeLiteral);
      }};
  }, {
    "./shared/cstring_strcpy": 22,
    "printf": 40
  }],
  15: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _abs,
            _atof,
            _atoi,
            _atol,
            _bsearch,
            _div,
            _labs,
            _ldiv,
            _qsort,
            _rand,
            _srand,
            _system,
            binary_search,
            cmpType,
            div_t_t,
            ldiv_t_t,
            m_w,
            m_z,
            mask,
            pchar,
            random,
            seed;
        m_w = 123456789;
        m_z = 987654321;
        mask = 0xffffffff;
        seed = function(i) {
          return m_w = i;
        };
        random = function() {
          var result;
          m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
          m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
          result = ((m_z << 16) + m_w) & mask;
          return result / 4294967296 + 0.5;
        };
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        _atof = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseFloat(str);
            return rt.val(rt.floatTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atof, "global", "atof", [pchar], rt.floatTypeLiteral);
        _atoi = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseInt(str);
            return rt.val(rt.intTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atoi, "global", "atoi", [pchar], rt.intTypeLiteral);
        _atol = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseInt(str);
            return rt.val(rt.longTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atol, "global", "atol", [pchar], rt.longTypeLiteral);
        if (rt.scope[0]["RAND_MAX"] == null) {
          rt.scope[0]["RAND_MAX"] = 0x7fffffff;
        }
        _rand = function(rt, _this) {
          var val;
          val = Math.floor(random() * (rt.scope[0]["RAND_MAX"] + 1));
          return rt.val(rt.intTypeLiteral, val);
        };
        rt.regFunc(_rand, "global", "rand", [], rt.intTypeLiteral);
        _srand = function(rt, _this, i) {
          return seed(i.v);
        };
        rt.regFunc(_srand, "global", "srand", [rt.unsignedintTypeLiteral], rt.voidTypeLiteral);
        _system = function(rt, _this, command) {
          var e,
              ret,
              str;
          if (command === rt.nullPointer) {
            return rt.val(rt.intTypeLiteral, 1);
          } else if (rt.isStringType(command.t)) {
            str = rt.getStringFromCharArray(str);
            try {
              ret = eval(str);
              if (ret != null) {
                console.log(ret);
              }
              return rt.val(rt.intTypeLiteral, 1);
            } catch (error) {
              e = error;
              return rt.val(rt.intTypeLiteral, 0);
            }
          } else {
            return rt.raiseException("command is not a string");
          }
        };
        rt.regFunc(_system, "global", "system", [pchar], rt.intTypeLiteral);
        rt.scope[0]["NULL"] = rt.nullPointer;
        binary_search = function(val, L, cmp) {
          var cmpResult,
              mid;
          if (L.length === 0) {
            return false;
          }
          mid = Math.floor(L.length / 2);
          cmpResult = cmp(val, L[mid], mid);
          if (cmpResult === 0) {
            return mid;
          } else if (cmpResult > 0) {
            return binary_search(val, L.slice(mid + 1, +L.length + 1 || 9e9));
          } else {
            return binary_search(val, L.slice(0, +(mid - 1) + 1 || 9e9));
          }
        };
        _bsearch = function(rt, _this, key, base, num, size, cmp) {
          var L,
              bsRet,
              val,
              wrapper;
          if (rt.isArrayType(base)) {
            L = base.v.target;
            val = key;
            wrapper = function(a, b, indexB) {
              var pbType,
                  pbVal,
                  pointerB;
              pbType = base.t;
              pbVal = rt.makeArrayPointerValue(L, indexB);
              pointerB = rt.val(pbType, pbVal);
              return cmp(rt, null, a, pointerB).v;
            };
            bsRet = binary_search(val, L, wrapper);
            if (bsRet === false) {
              return rt.nullPointer;
            } else {
              return rt.val(base.t, rt.makeArrayPointerValue(L, bsRet));
            }
          } else {
            return rt.raiseException("base must be an array");
          }
        };
        cmpType = rt.functionPointerType(rt.intTypeLiteral, [rt.voidPointerType, rt.voidPointerType]);
        rt.regFunc(_bsearch, "global", "bsearch", [rt.voidPointerType, rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidPointerType);
        _qsort = function(rt, _this, base, num, size, cmp) {
          var L,
              ele,
              i,
              j,
              len,
              wrapper;
          if (rt.isArrayType(base)) {
            L = base.v.target;
            for (i = j = 0, len = L.length; j < len; i = ++j) {
              ele = L[i];
              ele.index = i;
            }
            wrapper = function(a, b) {
              var pType,
                  paVal,
                  pbVal,
                  pointerA,
                  pointerB;
              pType = base.t;
              pbVal = rt.makeArrayPointerValue(L, b.index);
              paVal = rt.makeArrayPointerValue(L, a.index);
              pointerB = rt.val(pType, pbVal);
              pointerA = rt.val(pType, pbVal);
              return cmp(rt, null, pointerA, pointerB).v;
            };
            L.sort(wrapper);
          } else {
            return rt.raiseException("base must be an array");
          }
        };
        rt.regFunc(_qsort, "global", "qsort", [rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidTypeLiteral);
        _abs = function(rt, _this, n) {
          return rt.val(rt.intTypeLiteral, Math.abs(n.v));
        };
        rt.regFunc(_abs, "global", "abs", [rt.intTypeLiteral], rt.intTypeLiteral);
        _div = function(rt, _this, numer, denom) {
          var quot,
              rem;
          if (denom.v === 0) {
            rt.raiseException("divided by zero");
          }
          quot = rt.val(rt.intTypeLiteral, Math.floor(numer.v / denom.v));
          rem = rt.val(rt.intTypeLiteral, numer.v % denom.v);
          return {
            t: div_t_t,
            v: {members: {
                quot: quot,
                rem: rem
              }}
          };
        };
        div_t_t = rt.newClass("div_t", [{
          type: rt.intTypeLiteral,
          name: "quot"
        }, {
          type: rt.intTypeLiteral,
          name: "rem"
        }]);
        rt.regFunc(_div, "global", "div", [rt.intTypeLiteral, rt.intTypeLiteral], div_t_t);
        _labs = function(rt, _this, n) {
          return rt.val(rt.longTypeLiteral, Math.abs(n.v));
        };
        rt.regFunc(_labs, "global", "labs", [rt.longTypeLiteral], rt.longTypeLiteral);
        _ldiv = function(rt, _this, numer, denom) {
          var quot,
              rem;
          if (denom.v === 0) {
            rt.raiseException("divided by zero");
          }
          quot = rt.val(rt.longTypeLiteral, Math.floor(numer.v / denom.v));
          rem = rt.val(rt.longTypeLiteral, numer.v % denom.v);
          return {
            t: ldiv_t_t,
            v: {members: {
                quot: quot,
                rem: rem
              }}
          };
        };
        ldiv_t_t = rt.newClass("ldiv_t", [{
          type: rt.longTypeLiteral,
          name: "quot"
        }, {
          type: rt.longTypeLiteral,
          name: "rem"
        }]);
        return rt.regFunc(_ldiv, "global", "ldiv", [rt.longTypeLiteral, rt.longTypeLiteral], ldiv_t_t);
      }};
  }, {}],
  16: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _strcpy,
            pchar,
            sizet;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        sizet = rt.primitiveType("unsigned int");
        _strcpy = require("./shared/cstring_strcpy");
        rt.regFunc(_strcpy, "global", "strcpy", [pchar, pchar], pchar);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (num > 0 && i < srcarr.length && j < destarr.length - 1 && srcarr[i].v !== 0) {
              destarr[j] = rt.clone(srcarr[i]);
              num--;
              i++;
              j++;
            }
            if (srcarr[i].v === 0) {
              while (num > 0 && j < destarr.length) {
                destarr[j++] = rt.val(rt.charTypeLiteral, 0);
              }
            }
            if (i === srcarr.length) {
              rt.raiseException("source string does not have a pending \"\\0\"");
            } else if (j === destarr.length - 1) {
              rt.raiseException("destination array is not big enough");
            }
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strncpy", [pchar, pchar, sizet], pchar);
        rt.regFunc((function(rt, _this, dest, src) {
          var destarr,
              i,
              j,
              lendest,
              lensrc,
              newDest,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            destarr = dest.v.target;
            if (srcarr === destarr) {
              i = src.v.position;
              j = dest.v.position;
              if (i < j) {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (i + lensrc + 1 >= j) {
                  rt.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
                if (j + lensrc + lendest + 1 >= i) {
                  rt.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
            newDest = rt.val(pchar, rt.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt.getFunc("global", "strcpy", [pchar, pchar])(rt, null, [newDest, src]);
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strcat", [pchar, pchar], pchar);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              lendest,
              lensrc,
              newDest,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            destarr = dest.v.target;
            if (srcarr === destarr) {
              i = src.v.position;
              j = dest.v.position;
              if (i < j) {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (lensrc > num) {
                  lensrc = num;
                }
                if (i + lensrc + 1 >= j) {
                  rt.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (lensrc > num) {
                  lensrc = num;
                }
                lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
                if (j + lensrc + lendest + 1 >= i) {
                  rt.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
            newDest = rt.val(pchar, rt.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt.getFunc("global", "strncpy", [pchar, pchar, sizet])(rt, null, [newDest, src, num]);
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strncat", [pchar, pchar, sizet], pchar);
        rt.regFunc((function(rt, _this, str) {
          var arr,
              i;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            while (i < arr.length && arr[i].v !== 0) {
              i++;
            }
            if (i === arr.length) {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            } else {
              return rt.val(rt.intTypeLiteral, i - str.v.position);
            }
          } else {
            return rt.raiseException("target is not an array");
          }
        }), "global", "strlen", [pchar], sizet);
        rt.regFunc((function(rt, _this, dest, src) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (i < srcarr.length && j < destarr.length && srcarr[i].v === destarr[i].v) {
              i++;
              j++;
            }
            return rt.val(rt.intTypeLiteral, destarr[i].v - srcarr[i].v);
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strcmp", [pchar, pchar], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (num > 0 && i < srcarr.length && j < destarr.length && srcarr[i].v === destarr[i].v) {
              i++;
              j++;
              num--;
            }
            return rt.val(rt.intTypeLiteral, destarr[i].v - srcarr[i].v);
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strncmp", [pchar, pchar, sizet], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, str, ch) {
          var arr,
              i;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            while (i < arr.length && arr[i].v !== 0 && arr[i].v !== ch.v) {
              i++;
            }
            if (arr[i].v === 0) {
              return rt.val(pchar, rt.nullPointerValue);
            } else if (arr[i].v === ch.v) {
              return rt.val(pchar, rt.makeArrayPointerValue(arr, i));
            } else {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strchr", [pchar, rt.charTypeLiteral], pchar);
        rt.regFunc((function(rt, _this, str, ch) {
          var arr,
              i,
              lastpos;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            lastpos = -1;
            while (i < arr.length && arr[i].v !== 0) {
              if (arr[i].v === ch.v) {
                lastpos = i;
              }
              i++;
            }
            if (arr[i].v === 0) {
              if (lastpos >= 0) {
                return rt.val(pchar, rt.makeArrayPointerValue(arr, lastpos));
              } else {
                return rt.val(pchar, rt.nullPointerValue);
              }
            } else {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strrchr", [pchar, rt.charTypeLiteral], pchar);
        return rt.regFunc((function(rt, _this, str1, str2) {
          var _i,
              arr,
              i,
              j,
              tar;
          if (rt.isArrayType(str1.t) && rt.isArrayType(str2.t)) {
            arr = str1.v.target;
            i = str1.v.position;
            tar = str2.v.target;
            while (i < arr.length && arr[i].v !== 0) {
              j = str2.v.position;
              _i = i;
              while (j < tar.length && str1[_i].v === str2[j]) {
                _i++;
                j++;
              }
              if (j === tar.length) {
                break;
              }
              i++;
            }
            if (arr[i].v === 0) {
              return rt.val(pchar, rt.nullPointerValue);
            } else if (i === arr.length) {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            } else {
              return rt.val(pchar, rt.makeArrayPointerValue(arr, i));
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strstr", [pchar, rt.charTypeLiteral], pchar);
      }};
  }, {"./shared/cstring_strcpy": 22}],
  17: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _time;
        _time = function(rt, _this, i) {
          var val;
          val = Math.floor(Date.now() / 1000);
          return rt.val(rt.intTypeLiteral, val);
        };
        return rt.regFunc(_time, "global", "time", [rt.longTypeLiteral], rt.longTypeLiteral);
      }};
  }, {}],
  18: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _plusX,
            type,
            typeSig;
        type = rt.newClass("Foo", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        return rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
      }};
  }, {}],
  19: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _addManipulator,
            _fixed,
            _setfill,
            _setprecesion,
            _setw,
            oType,
            type;
        type = rt.newClass("iomanipulator", []);
        oType = rt.simpleType("ostream", []);
        _setprecesion = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setprecision",
                f: function(config) {
                  return config.setprecision = x.v;
                }
              }},
            left: false
          };
        };
        rt.regFunc(_setprecesion, "global", "setprecision", [rt.intTypeLiteral], type);
        _fixed = {
          t: type,
          v: {members: {
              name: "fixed",
              f: function(config) {
                return config.fixed = true;
              }
            }}
        };
        rt.scope[0]["fixed"] = _fixed;
        _setw = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setw",
                f: function(config) {
                  return config.setw = x.v;
                }
              }}
          };
        };
        rt.regFunc(_setw, "global", "setw", [rt.intTypeLiteral], type);
        _setfill = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setfill",
                f: function(config) {
                  return config.setfill = String.fromCharCode(x.v);
                }
              }}
          };
        };
        rt.regFunc(_setfill, "global", "setfill", [rt.charTypeLiteral], type);
        _addManipulator = function(rt, _cout, m) {
          _cout.manipulators || (_cout.manipulators = {
            config: {},
            active: {},
            use: function(o) {
              var fill,
                  i,
                  j,
                  prec,
                  ref,
                  tarStr;
              if (rt.isNumericType(o.t) && !rt.isIntegerType(o.t)) {
                if (this.active.fixed) {
                  prec = this.active.setprecision != null ? this.config.setprecision : 6;
                  tarStr = o.v.toFixed(prec);
                } else if (this.active.setprecision != null) {
                  tarStr = o.v.toPrecision(this.config.setprecision).replace(/0+$/, "");
                }
              }
              if (this.active.setw != null) {
                if (this.active.setfill != null) {
                  fill = this.config.setfill;
                } else {
                  fill = " ";
                }
                if (!(rt.isTypeEqualTo(o.t, rt.charTypeLiteral) && (o.v === 10 || o.v === 13))) {
                  tarStr || (tarStr = rt.isPrimitiveType(o.t) ? o.t.name.indexOf("char") >= 0 ? String.fromCharCode(o.v) : o.t.name === "bool" ? o.v ? "1" : "0" : o.v.toString() : rt.isStringType(o.t) ? rt.getStringFromCharArray(o) : rt.raiseException("<< operator in ostream cannot accept " + rt.makeTypeString(o.t)));
                  for (i = j = 0, ref = this.config.setw - tarStr.length; j < ref; i = j += 1) {
                    tarStr = fill + tarStr;
                  }
                  delete this.active.setw;
                }
              }
              if (tarStr != null) {
                return rt.makeCharArrayFromString(tarStr);
              } else {
                return o;
              }
            }
          });
          m.v.members.f(_cout.manipulators.config);
          _cout.manipulators.active[m.v.members.name] = m.v.members.f;
          return _cout;
        };
        rt.regOperator(_addManipulator, oType, "<<", [type], oType);
      }};
  }, {}],
  20: [function(require, module, exports) {
    var _read,
        _skipSpace;
    _skipSpace = function(s) {
      var r;
      r = /^\s*/.exec(s);
      if (r && r.length > 0) {
        return s.substring(r[0].length);
      } else {
        return s;
      }
    };
    _read = function(rt, reg, buf, type) {
      var r;
      r = reg.exec(buf);
      if ((r == null) || r.length === 0) {
        return rt.raiseException("input format mismatch " + rt.makeTypeString(type) + " with buffer=" + buf);
      } else {
        return r;
      }
    };
    module.exports = {load: function(rt) {
        var _bool,
            _cinString,
            _get,
            _getline,
            cin,
            cout,
            endl,
            pchar,
            stdio,
            type;
        stdio = rt.config.stdio;
        type = rt.newClass("istream", []);
        cin = {
          t: type,
          v: {
            buf: stdio.drain(),
            istream: stdio,
            members: {}
          },
          left: false
        };
        rt.scope[0]["cin"] = cin;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        rt.types[rt.getTypeSignature(type)] = {
          "#father": "object",
          "o(>>)": {"#default": function(rt, _cin, t) {
              var b,
                  len,
                  r,
                  v;
              if (!t.left) {
                rt.raiseException("only left value can be used as storage");
              }
              if (!rt.isPrimitiveType(t.t)) {
                rt.raiseException(">> operator in istream cannot accept " + rt.makeTypeString(t.t));
              }
              b = _cin.v.buf;
              _cin.v.eofbit = b.length === 0;
              switch (t.t.name) {
                case "char":
                case "signed char":
                case "unsigned char":
                  b = _skipSpace(b);
                  r = _read(rt, /^./, b, t.t);
                  v = r[0].charCodeAt(0);
                  break;
                case "short":
                case "short int":
                case "signed short":
                case "signed short int":
                case "unsigned short":
                case "unsigned short int":
                case "int":
                case "signed int":
                case "unsigned":
                case "unsigned int":
                case "long":
                case "long int":
                case "long int":
                case "signed long":
                case "signed long int":
                case "unsigned long":
                case "unsigned long int":
                case "long long":
                case "long long int":
                case "long long int":
                case "signed long long":
                case "signed long long int":
                case "unsigned long long":
                case "unsigned long long int":
                  b = _skipSpace(b);
                  r = _read(rt, /^[-+]?(?:([0-9]*)([eE]\+?[0-9]+)?)|0/, b, t.t);
                  v = parseInt(r[0]);
                  break;
                case "float":
                case "double":
                  b = _skipSpace(b);
                  r = _read(rt, /^[-+]?(?:[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?)|(?:([1-9][0-9]*)([eE]\+?[0-9]+)?)/, b, t.t);
                  v = parseFloat(r[0]);
                  break;
                case "bool":
                  b = _skipSpace(b);
                  r = _read(rt, /^(true|false)/, b, t.t);
                  v = r[0] === "true";
                  break;
                default:
                  rt.raiseException(">> operator in istream cannot accept " + rt.makeTypeString(t.t));
              }
              len = r[0].length;
              _cin.v.failbit = len === 0;
              if (!_cin.v.failbit) {
                t.v = rt.val(t.t, v).v;
                _cin.v.buf = b.substring(len);
              }
              return _cin;
            }}
        };
        _cinString = function(rt, _cin, t) {
          var b,
              i,
              initialPos,
              j,
              r,
              ref,
              tar;
          if (!rt.isStringType(t.t)) {
            rt.raiseException("only a pointer to string can be used as storage");
          }
          b = _cin.v.buf;
          _cin.v.eofbit = b.length === 0;
          b = _skipSpace(b);
          r = _read(rt, /^\S*/, b, t.t)[0];
          _cin.v.failbit = r.length === 0;
          _cin.v.buf = b.substring(r.length);
          initialPos = t.v.position;
          tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt.raiseException(("target string buffer is " + (r.length - (tar.length - initialPos)) + " too short"));
          }
          for (i = j = 0, ref = r.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            tar[i + initialPos] = rt.val(rt.charTypeLiteral, r.charCodeAt(i));
          }
          tar[r.length + initialPos] = rt.val(rt.charTypeLiteral, 0);
          return _cin;
        };
        rt.regOperator(_cinString, cin.t, ">>", [pchar], cin.t);
        _getline = function(rt, _cin, t, limit, delim) {
          var b,
              i,
              initialPos,
              j,
              r,
              ref,
              removeDelim,
              tar;
          if (!rt.isStringType(t.t)) {
            rt.raiseException("only a pointer to string can be used as storage");
          }
          limit = limit.v;
          delim = delim != null ? delim.v : '\n';
          b = _cin.v.buf;
          _cin.v.eofbit = b.length === 0;
          r = _read(rt, new RegExp(("^[^" + delim + "]*")), b, t.t)[0];
          if (r.length + 1 > limit) {
            r = r.substring(0, limit - 1);
          }
          if (b.charAt(r.length) === delim.charAt(0)) {
            removeDelim = true;
            _cin.v.failbit = false;
          } else {
            _cin.v.failbit = r.length === 0;
          }
          _cin.v.buf = b.substring(r.length + (removeDelim ? 1 : 0));
          initialPos = t.v.position;
          tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt.raiseException(("target string buffer is " + (r.length - (tar.length - initialPos)) + " too short"));
          }
          for (i = j = 0, ref = r.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            tar[i + initialPos] = rt.val(rt.charTypeLiteral, r.charCodeAt(i));
          }
          tar[r.length + initialPos] = rt.val(rt.charTypeLiteral, 0);
          return _cin;
        };
        rt.regFunc(_getline, cin.t, "getline", [pchar, rt.intTypeLiteral, rt.charTypeLiteral], cin.t);
        rt.regFunc(_getline, cin.t, "getline", [pchar, rt.intTypeLiteral], cin.t);
        _get = function(rt, _cin) {
          var b,
              r,
              v;
          b = _cin.v.buf;
          _cin.v.eofbit = b.length === 0;
          if (_cin.v.eofbit) {
            return rt.val(rt.intTypeLiteral, -1);
          } else {
            r = _read(rt, /^.|[\r\n]/, b, rt.charTypeLiteral);
            _cin.v.buf = b.substring(r.length);
            v = r[0].charCodeAt(0);
            return rt.val(rt.intTypeLiteral, v);
          }
        };
        rt.regFunc(_get, cin.t, "get", [], rt.intTypeLiteral);
        _bool = function(rt, _cin) {
          return rt.val(rt.boolTypeLiteral, !_cin.v.failbit);
        };
        rt.regOperator(_bool, cin.t, "bool", [], rt.boolTypeLiteral);
        type = rt.newClass("ostream", []);
        cout = {
          t: rt.simpleType("ostream"),
          v: {
            ostream: stdio,
            members: {}
          },
          left: false
        };
        rt.scope[0]["cout"] = cout;
        rt.types[rt.getTypeSignature(cout.t)] = {
          "#father": "object",
          "o(<<)": {"#default": function(rt, _cout, t) {
              var r;
              if (_cout.manipulators != null) {
                t = _cout.manipulators.use(t);
              }
              if (rt.isPrimitiveType(t.t)) {
                if (t.t.name.indexOf("char") >= 0) {
                  r = String.fromCharCode(t.v);
                } else if (t.t.name === "bool") {
                  r = t.v ? "1" : "0";
                } else {
                  r = t.v.toString();
                }
              } else if (rt.isStringType(t.t)) {
                r = rt.getStringFromCharArray(t);
              } else {
                rt.raiseException("<< operator in ostream cannot accept " + rt.makeTypeString(t.t));
              }
              _cout.v.ostream.write(r);
              return _cout;
            }}
        };
        endl = rt.val(rt.charTypeLiteral, "\n".charCodeAt(0));
        rt.scope[0]["endl"] = endl;
      }};
  }, {}],
  21: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _plusX,
            type,
            typeSig;
        type = rt.newClass("pgmspace", [{
          name: "x",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, 2, true);
          }
        }, {
          name: "y",
          t: rt.intTypeLiteral,
          initialize: function(rt, _this) {
            return rt.val(rt.intTypeLiteral, -2, true);
          }
        }]);
        typeSig = rt.getTypeSignature(type);
        rt.types[typeSig]["#father"] = "object";
        _plusX = function(rt, _this, a) {
          var newValue;
          newValue = _this.v.members["x"].v + a.v;
          return rt.val(rt.intTypeLiteral, newValue, false);
        };
        return rt.regFunc(_plusX, type, "plusX", [rt.intTypeLiteral], rt.intTypeLiteral);
      }};
  }, {}],
  22: [function(require, module, exports) {
    module.exports = function(rt, _this, dest, src) {
      var destarr,
          i,
          j,
          srcarr;
      if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
        srcarr = src.v.target;
        i = src.v.position;
        destarr = dest.v.target;
        j = dest.v.position;
        while (i < srcarr.length && j < destarr.length && srcarr[i].v !== 0) {
          destarr[j] = rt.clone(srcarr[i]);
          i++;
          j++;
        }
        if (i === srcarr.length) {
          rt.raiseException("source string does not have a pending \"\\0\"");
        } else if (j === destarr.length - 1) {
          rt.raiseException("destination array is not big enough");
        } else {
          destarr[j] = rt.val(rt.charTypeLiteral, 0);
        }
      } else {
        rt.raiseException("destination or source is not an array");
      }
      return dest;
    };
  }, {}],
  23: [function(require, module, exports) {
    JSCPP = require('./main');
  }, {"./main": 26}],
  24: [function(require, module, exports) {
    var Interpreter,
        isGenerator,
        isGeneratorFunction,
        sampleGenerator,
        sampleGeneratorFunction;
    sampleGeneratorFunction = $traceurRuntime.initGeneratorFunction(function $__11() {
      var $__12;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return null;
            case 2:
              $__12 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $ctx.returnValue = $__12;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__11, this);
    });
    sampleGenerator = sampleGeneratorFunction();
    isGenerator = function(g) {
      return (g != null ? g.constructor : void 0) === sampleGenerator.constructor;
    };
    isGeneratorFunction = function(f) {
      return (f != null ? f.constructor : void 0) === sampleGeneratorFunction.constructor;
    };
    Interpreter = function(rt) {
      this.rt = rt;
      this.visitors = {
        TranslationUnit: $traceurRuntime.initGeneratorFunction(function $__13(interp, s, param) {
          var dec,
              i,
              $__14,
              $__15;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  i = 0;
                  $ctx.state = 19;
                  break;
                case 19:
                  $ctx.state = (i < s.ExternalDeclarations.length) ? 13 : -2;
                  break;
                case 13:
                  dec = s.ExternalDeclarations[i];
                  $ctx.state = 14;
                  break;
                case 14:
                  $__14 = $ctx.wrapYieldStar(interp.visit(interp, dec)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__15 = $__14[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__15.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__15.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__15.value;
                case 10:
                  i++;
                  $ctx.state = 19;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__13, this);
        }),
        DirectDeclarator: $traceurRuntime.initGeneratorFunction(function $__16(interp, s, param) {
          var _basetype,
              _param,
              _pointer,
              _type,
              argTypes,
              basetype,
              dim,
              dimensions,
              j,
              k,
              l,
              len,
              len1,
              len2,
              m,
              ptl,
              ref,
              ref1,
              ref2,
              ret,
              right,
              varargs,
              $__17,
              $__18,
              $__19,
              $__20,
              $__21,
              $__22,
              $__23,
              $__24,
              $__25,
              $__26,
              $__27,
              $__28,
              $__29,
              $__30,
              $__31,
              $__32,
              $__33,
              $__34,
              $__35,
              $__36,
              $__37,
              $__38,
              $__39,
              $__40,
              $__41,
              $__42;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = param.basetype;
                  basetype = interp.buildRecursivePointerType(s.Pointer, basetype, 0);
                  $ctx.state = 115;
                  break;
                case 115:
                  $ctx.state = (s.right.length === 1) ? 51 : 49;
                  break;
                case 51:
                  right = s.right[0];
                  ptl = null;
                  if (right.type === "DirectDeclarator_modifier_ParameterTypeList") {
                    ptl = right.ParameterTypeList;
                    varargs = ptl.varargs;
                  } else if (right.type === "DirectDeclarator_modifier_IdentifierList" && right.IdentifierList === null) {
                    ptl = right.ParameterTypeList;
                    varargs = false;
                  }
                  $ctx.state = 52;
                  break;
                case 52:
                  $ctx.state = (ptl != null) ? 46 : 49;
                  break;
                case 46:
                  argTypes = [];
                  ref = ptl.ParameterList;
                  $ctx.state = 47;
                  break;
                case 47:
                  k = 0, len = ref.length;
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = (k < len) ? 39 : 43;
                  break;
                case 42:
                  k++;
                  $ctx.state = 45;
                  break;
                case 39:
                  _param = ref[k];
                  _basetype = rt.simpleType(_param.DeclarationSpecifiers);
                  $ctx.state = 40;
                  break;
                case 40:
                  $ctx.state = (_param.Declarator != null) ? 34 : 36;
                  break;
                case 34:
                  _pointer = _param.Declarator.Pointer;
                  _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
                  $ctx.state = 35;
                  break;
                case 35:
                  $ctx.state = ((_param.Declarator.right != null) && _param.Declarator.right.length > 0) ? 29 : 32;
                  break;
                case 29:
                  dimensions = [];
                  ref1 = _param.Declarator.right;
                  $ctx.state = 30;
                  break;
                case 30:
                  j = l = 0, len1 = ref1.length;
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = (l < len1) ? 22 : 26;
                  break;
                case 25:
                  j = ++l;
                  $ctx.state = 28;
                  break;
                case 22:
                  dim = ref1[j];
                  dim = _param.Declarator.right[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization", dim);
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (dim.Expression !== null) ? 15 : 19;
                  break;
                case 15:
                  $__17 = rt.cast;
                  $__18 = rt.intTypeLiteral;
                  $__19 = interp.visit;
                  $__20 = dim.Expression;
                  $__21 = $__19.call(interp, interp, $__20, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__25 = $ctx.wrapYieldStar($__21[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__26 = $__25[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__26.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__26.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__26.value;
                case 10:
                  $__22 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__23 = $__17.call(rt, $__18, $__22);
                  $__24 = $__23.v;
                  dim = $__24;
                  $ctx.state = 18;
                  break;
                case 19:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  $ctx.state = 25;
                  break;
                case 26:
                  _type = interp.arrayType(dimensions, 0, _type);
                  $ctx.state = 32;
                  break;
                case 36:
                  _type = _basetype;
                  $ctx.state = 32;
                  break;
                case 32:
                  argTypes.push(_type);
                  $ctx.state = 42;
                  break;
                case 43:
                  basetype = rt.functionType(basetype, argTypes);
                  $ctx.state = 49;
                  break;
                case 49:
                  $ctx.state = (s.right.length > 0 && s.right[0].type === "DirectDeclarator_modifier_array") ? 82 : 85;
                  break;
                case 82:
                  dimensions = [];
                  ref2 = s.right;
                  $ctx.state = 83;
                  break;
                case 83:
                  j = m = 0, len2 = ref2.length;
                  $ctx.state = 81;
                  break;
                case 81:
                  $ctx.state = (m < len2) ? 75 : 79;
                  break;
                case 78:
                  j = ++m;
                  $ctx.state = 81;
                  break;
                case 75:
                  dim = ref2[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization", dim);
                  }
                  $ctx.state = 76;
                  break;
                case 76:
                  $ctx.state = (dim.Expression !== null) ? 68 : 72;
                  break;
                case 68:
                  $__27 = rt.cast;
                  $__28 = rt.intTypeLiteral;
                  $__29 = interp.visit;
                  $__30 = dim.Expression;
                  $__31 = $__29.call(interp, interp, $__30, param);
                  $ctx.state = 69;
                  break;
                case 69:
                  $__35 = $ctx.wrapYieldStar($__31[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 65;
                  break;
                case 65:
                  $__36 = $__35[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 62;
                  break;
                case 62:
                  $ctx.state = ($__36.done) ? 56 : 55;
                  break;
                case 56:
                  $ctx.sent = $__36.value;
                  $ctx.state = 63;
                  break;
                case 55:
                  $ctx.state = 65;
                  return $__36.value;
                case 63:
                  $__32 = $ctx.sentIgnoreThrow;
                  $ctx.state = 67;
                  break;
                case 67:
                  $__33 = $__27.call(rt, $__28, $__32);
                  $__34 = $__33.v;
                  dim = $__34;
                  $ctx.state = 71;
                  break;
                case 72:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 71;
                  break;
                case 71:
                  dimensions.push(dim);
                  $ctx.state = 78;
                  break;
                case 79:
                  basetype = interp.arrayType(dimensions, 0, basetype);
                  $ctx.state = 85;
                  break;
                case 85:
                  $ctx.state = (s.left.type === "Identifier") ? 87 : 109;
                  break;
                case 87:
                  $ctx.returnValue = {
                    type: basetype,
                    name: s.left.Identifier
                  };
                  $ctx.state = -2;
                  break;
                case 109:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 110;
                  break;
                case 110:
                  $__37 = interp.visit;
                  $__38 = s.left;
                  $__39 = $__37.call(interp, interp, $__38, param);
                  $ctx.state = 104;
                  break;
                case 104:
                  $__41 = $ctx.wrapYieldStar($__39[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 100;
                  break;
                case 100:
                  $__42 = $__41[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 97;
                  break;
                case 97:
                  $ctx.state = ($__42.done) ? 91 : 90;
                  break;
                case 91:
                  $ctx.sent = $__42.value;
                  $ctx.state = 98;
                  break;
                case 90:
                  $ctx.state = 100;
                  return $__42.value;
                case 98:
                  $__40 = $ctx.sentIgnoreThrow;
                  $ctx.state = 102;
                  break;
                case 102:
                  ret = $__40;
                  $ctx.state = 106;
                  break;
                case 106:
                  param.basetype = _basetype;
                  $ctx.state = 112;
                  break;
                case 112:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__16, this);
        }),
        TypedefDeclaration: $traceurRuntime.initGeneratorFunction(function $__43(interp, s, param) {
          var $__9,
              _basetype,
              basetype,
              declarator,
              k,
              len,
              name,
              ref,
              type,
              $__44,
              $__45,
              $__46,
              $__47,
              $__48,
              $__49,
              $__50;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  ref = s.Declarators;
                  $ctx.state = 27;
                  break;
                case 27:
                  k = 0, len = ref.length;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = (k < len) ? 19 : 23;
                  break;
                case 22:
                  k++;
                  $ctx.state = 25;
                  break;
                case 19:
                  declarator = ref[k];
                  $ctx.state = 20;
                  break;
                case 20:
                  $__44 = interp.visit;
                  $__45 = $__44.call(interp, interp, declarator, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__49 = $ctx.wrapYieldStar($__45[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__50 = $__49[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__50.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__50.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__50.value;
                case 10:
                  $__46 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__9 = $__46;
                  $__47 = $__9.type;
                  type = $__47;
                  $__48 = $__9.name;
                  name = $__48;
                  $ctx.state = 18;
                  break;
                case 18:
                  rt.registerTypedef(type, name);
                  $ctx.state = 22;
                  break;
                case 23:
                  param.basetype = _basetype;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__43, this);
        }),
        FunctionDefinition: $traceurRuntime.initGeneratorFunction(function $__51(interp, s, param) {
          var _basetype,
              _init,
              _name,
              _param,
              _pointer,
              _type,
              argNames,
              argTypes,
              basetype,
              dim,
              dimensions,
              i,
              j,
              name,
              optionalArgs,
              pointer,
              ptl,
              scope,
              stat,
              varargs,
              $__52,
              $__53,
              $__54,
              $__55,
              $__56,
              $__57,
              $__58,
              $__59,
              $__60,
              $__61;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope = param.scope;
                  name = s.Declarator.left.Identifier;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  pointer = s.Declarator.Pointer;
                  basetype = interp.buildRecursivePointerType(pointer, basetype, 0);
                  argTypes = [];
                  argNames = [];
                  optionalArgs = [];
                  ptl = void 0;
                  varargs = void 0;
                  if (s.Declarator.right.type === "DirectDeclarator_modifier_ParameterTypeList") {
                    ptl = s.Declarator.right.ParameterTypeList;
                    varargs = ptl.varargs;
                  } else if (s.Declarator.right.type === "DirectDeclarator_modifier_IdentifierList" && s.Declarator.right.IdentifierList === null) {
                    ptl = {ParameterList: []};
                    varargs = false;
                  } else {
                    rt.raiseException("unacceptable argument list", s.Declarator.right);
                  }
                  i = 0;
                  $ctx.state = 38;
                  break;
                case 38:
                  $ctx.state = (i < ptl.ParameterList.length) ? 32 : 36;
                  break;
                case 32:
                  _param = ptl.ParameterList[i];
                  if (_param.Declarator == null) {
                    rt.raiseException("missing declarator for argument", _param);
                  }
                  _init = _param.Declarator.Initializers;
                  _pointer = _param.Declarator.Declarator.Pointer;
                  _basetype = rt.simpleType(_param.DeclarationSpecifiers);
                  _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
                  _name = _param.Declarator.Declarator.left.Identifier;
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.state = (_param.Declarator.Declarator.right.length > 0) ? 27 : 30;
                  break;
                case 27:
                  dimensions = [];
                  j = 0;
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = (j < _param.Declarator.Declarator.right.length) ? 22 : 26;
                  break;
                case 22:
                  dim = _param.Declarator.Declarator.right[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization", dim);
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (dim.Expression !== null) ? 15 : 19;
                  break;
                case 15:
                  $__52 = rt.cast;
                  $__53 = rt.intTypeLiteral;
                  $__54 = interp.visit;
                  $__55 = dim.Expression;
                  $__56 = $__54.call(interp, interp, $__55, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__60 = $ctx.wrapYieldStar($__56[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__61 = $__60[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__61.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__61.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__61.value;
                case 10:
                  $__57 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__58 = $__52.call(rt, $__53, $__57);
                  $__59 = $__58.v;
                  dim = $__59;
                  $ctx.state = 18;
                  break;
                case 19:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  j++;
                  $ctx.state = 28;
                  break;
                case 26:
                  _type = interp.arrayType(dimensions, 0, _type);
                  $ctx.state = 30;
                  break;
                case 30:
                  if (_init != null) {
                    optionalArgs.push({
                      type: _type,
                      name: _name,
                      expression: _init.Expression
                    });
                  } else {
                    if (optionalArgs.length > 0) {
                      rt.raiseException("all default arguments must be at the end of arguments list", _param);
                    }
                    argTypes.push(_type);
                    argNames.push(_name);
                  }
                  i++;
                  $ctx.state = 38;
                  break;
                case 36:
                  stat = s.CompoundStatement;
                  rt.defFunc(scope, name, basetype, argTypes, argNames, stat, interp, optionalArgs);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__51, this);
        }),
        Declaration: $traceurRuntime.initGeneratorFunction(function $__62(interp, s, param) {
          var $__9,
              $__10,
              _basetype,
              basetype,
              dec,
              dim,
              dimensions,
              i,
              init,
              initializer,
              j,
              k,
              l,
              len,
              len1,
              name,
              ref,
              ref1,
              type,
              $__63,
              $__64,
              $__65,
              $__66,
              $__67,
              $__68,
              $__69,
              $__70,
              $__71,
              $__72,
              $__73,
              $__74,
              $__75,
              $__76,
              $__77,
              $__78,
              $__79,
              $__80,
              $__81,
              $__82,
              $__83,
              $__84,
              $__85,
              $__86,
              $__87,
              $__88,
              $__89,
              $__90,
              $__91,
              $__92,
              $__93,
              $__94,
              $__95,
              $__96,
              $__97,
              $__98,
              $__99,
              $__100,
              $__101,
              $__102,
              $__103,
              $__104;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  ref = s.InitDeclaratorList;
                  $ctx.state = 147;
                  break;
                case 147:
                  i = k = 0, len = ref.length;
                  $ctx.state = 145;
                  break;
                case 145:
                  $ctx.state = (k < len) ? 141 : -2;
                  break;
                case 94:
                  i = ++k;
                  $ctx.state = 145;
                  break;
                case 141:
                  dec = ref[i];
                  init = dec.Initializers;
                  $ctx.state = 142;
                  break;
                case 142:
                  $ctx.state = (dec.Declarator.right.length > 0 && dec.Declarator.right[0].type === "DirectDeclarator_modifier_array") ? 89 : 134;
                  break;
                case 89:
                  dimensions = [];
                  ref1 = dec.Declarator.right;
                  $ctx.state = 90;
                  break;
                case 90:
                  j = l = 0, len1 = ref1.length;
                  $ctx.state = 52;
                  break;
                case 52:
                  $ctx.state = (l < len1) ? 46 : 50;
                  break;
                case 49:
                  j = ++l;
                  $ctx.state = 52;
                  break;
                case 46:
                  dim = ref1[j];
                  $ctx.state = 47;
                  break;
                case 47:
                  $ctx.state = (dim.Expression !== null) ? 15 : 44;
                  break;
                case 15:
                  $__63 = rt.cast;
                  $__64 = rt.intTypeLiteral;
                  $__65 = interp.visit;
                  $__66 = dim.Expression;
                  $__67 = $__65.call(interp, interp, $__66, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__71 = $ctx.wrapYieldStar($__67[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__72 = $__71[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__72.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__72.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__72.value;
                case 10:
                  $__68 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__69 = $__63.call(rt, $__64, $__68);
                  $__70 = $__69.v;
                  dim = $__70;
                  $ctx.state = 18;
                  break;
                case 44:
                  $ctx.state = (j > 0) ? 42 : 41;
                  break;
                case 42:
                  rt.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  $ctx.state = 18;
                  break;
                case 41:
                  $ctx.state = (init.type === "Initializer_expr") ? 33 : 39;
                  break;
                case 33:
                  $__73 = interp.visit;
                  $__74 = $__73.call(interp, interp, init, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__76 = $ctx.wrapYieldStar($__74[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__77 = $__76[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__77.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__77.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__77.value;
                case 28:
                  $__75 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  initializer = $__75;
                  $ctx.state = 36;
                  break;
                case 36:
                  if (rt.isCharType(basetype) && rt.isArrayType(initializer.t) && rt.isCharType(initializer.t.eleType)) {
                    dim = initializer.v.target.length;
                    init = {
                      type: "Initializer_array",
                      Initializers: initializer.v.target.map(function(e) {
                        return {
                          type: "Initializer_expr",
                          shorthand: e
                        };
                      })
                    };
                  } else {
                    rt.raiseException("cannot initialize an array to " + rt.makeValString(initializer), init);
                  }
                  $ctx.state = 18;
                  break;
                case 39:
                  dim = init.Initializers.length;
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  $ctx.state = 49;
                  break;
                case 50:
                  $__78 = interp.arrayInit;
                  $__79 = $__78.call(interp, dimensions, init, 0, basetype, param);
                  $ctx.state = 68;
                  break;
                case 68:
                  $__81 = $ctx.wrapYieldStar($__79[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 64;
                  break;
                case 64:
                  $__82 = $__81[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = ($__82.done) ? 55 : 54;
                  break;
                case 55:
                  $ctx.sent = $__82.value;
                  $ctx.state = 62;
                  break;
                case 54:
                  $ctx.state = 64;
                  return $__82.value;
                case 62:
                  $__80 = $ctx.sentIgnoreThrow;
                  $ctx.state = 66;
                  break;
                case 66:
                  init = $__80;
                  $ctx.state = 70;
                  break;
                case 70:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 92;
                  break;
                case 92:
                  $__83 = interp.visit;
                  $__84 = dec.Declarator;
                  $__85 = $__83.call(interp, interp, $__84, param);
                  $ctx.state = 86;
                  break;
                case 86:
                  $__89 = $ctx.wrapYieldStar($__85[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 82;
                  break;
                case 82:
                  $__90 = $__89[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 79;
                  break;
                case 79:
                  $ctx.state = ($__90.done) ? 73 : 72;
                  break;
                case 73:
                  $ctx.sent = $__90.value;
                  $ctx.state = 80;
                  break;
                case 72:
                  $ctx.state = 82;
                  return $__90.value;
                case 80:
                  $__86 = $ctx.sentIgnoreThrow;
                  $ctx.state = 84;
                  break;
                case 84:
                  $__9 = $__86;
                  $__87 = $__9.name;
                  name = $__87;
                  $__88 = $__9.type;
                  type = $__88;
                  $ctx.state = 88;
                  break;
                case 88:
                  param.basetype = _basetype;
                  rt.defVar(name, init.t, init);
                  $ctx.state = 94;
                  break;
                case 134:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 135;
                  break;
                case 135:
                  $__91 = interp.visit;
                  $__92 = dec.Declarator;
                  $__93 = $__91.call(interp, interp, $__92, param);
                  $ctx.state = 110;
                  break;
                case 110:
                  $__97 = $ctx.wrapYieldStar($__93[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 106;
                  break;
                case 106:
                  $__98 = $__97[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 103;
                  break;
                case 103:
                  $ctx.state = ($__98.done) ? 97 : 96;
                  break;
                case 97:
                  $ctx.sent = $__98.value;
                  $ctx.state = 104;
                  break;
                case 96:
                  $ctx.state = 106;
                  return $__98.value;
                case 104:
                  $__94 = $ctx.sentIgnoreThrow;
                  $ctx.state = 108;
                  break;
                case 108:
                  $__10 = $__94;
                  $__95 = $__10.name;
                  name = $__95;
                  $__96 = $__10.type;
                  type = $__96;
                  $ctx.state = 112;
                  break;
                case 112:
                  param.basetype = _basetype;
                  $ctx.state = 137;
                  break;
                case 137:
                  $ctx.state = (init == null) ? 131 : 127;
                  break;
                case 131:
                  init = rt.defaultValue(type, true);
                  $ctx.state = 132;
                  break;
                case 127:
                  $__99 = interp.visit;
                  $__100 = init.Expression;
                  $__101 = $__99.call(interp, interp, $__100);
                  $ctx.state = 128;
                  break;
                case 128:
                  $__103 = $ctx.wrapYieldStar($__101[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 124;
                  break;
                case 124:
                  $__104 = $__103[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 121;
                  break;
                case 121:
                  $ctx.state = ($__104.done) ? 115 : 114;
                  break;
                case 115:
                  $ctx.sent = $__104.value;
                  $ctx.state = 122;
                  break;
                case 114:
                  $ctx.state = 124;
                  return $__104.value;
                case 122:
                  $__102 = $ctx.sentIgnoreThrow;
                  $ctx.state = 126;
                  break;
                case 126:
                  init = $__102;
                  $ctx.state = 132;
                  break;
                case 132:
                  rt.defVar(name, type, init);
                  $ctx.state = 94;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__62, this);
        }),
        Initializer_expr: $traceurRuntime.initGeneratorFunction(function $__105(interp, s, param) {
          var $__106,
              $__107,
              $__108,
              $__109,
              $__110,
              $__111;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__106 = interp.visit;
                  $__107 = s.Expression;
                  $__108 = $__106.call(interp, interp, $__107, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__110 = $ctx.wrapYieldStar($__108[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__111 = $__110[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__111.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__111.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__111.value;
                case 10:
                  $__109 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__109;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__105, this);
        }),
        Label_case: $traceurRuntime.initGeneratorFunction(function $__112(interp, s, param) {
          var ce,
              $__113,
              $__114,
              $__115,
              $__116,
              $__117,
              $__118;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 25;
                  break;
                case 25:
                  $__113 = interp.visit;
                  $__114 = s.ConstantExpression;
                  $__115 = $__113.call(interp, interp, $__114);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__117 = $ctx.wrapYieldStar($__115[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__118 = $__117[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__118.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__118.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__118.value;
                case 10:
                  $__116 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ce = $__116;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (param["switch"] === void 0) {
                    rt.raiseException("you cannot use case outside switch block");
                  }
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = (param.scope === "SelectionStatement_switch_cs") ? 19 : 21;
                  break;
                case 19:
                  $ctx.returnValue = ["switch", rt.cast(ce.t, param["switch"]).v === ce.v];
                  $ctx.state = -2;
                  break;
                case 21:
                  rt.raiseException("you can only use case directly in a switch block");
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__112, this);
        }),
        Label_default: function(interp, s, param) {
          rt = interp.rt;
          if (param["switch"] === void 0) {
            rt.raiseException("you cannot use default outside switch block");
          }
          if (param.scope === "SelectionStatement_switch_cs") {
            return ["switch", true];
          } else {
            rt.raiseException("you can only use default directly in a switch block");
          }
        },
        CompoundStatement: $traceurRuntime.initGeneratorFunction(function $__119(interp, s, param) {
          var _scope,
              i,
              k,
              len,
              r,
              stmt,
              stmts,
              switchon,
              $__120,
              $__121,
              $__122,
              $__123,
              $__124,
              $__125,
              $__126,
              $__127,
              $__128,
              $__129,
              $__130,
              $__131,
              $__132,
              $__133,
              $__134;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  stmts = s.Statements;
                  r = void 0;
                  i = void 0;
                  _scope = param.scope;
                  $ctx.state = 87;
                  break;
                case 87:
                  $ctx.state = (param.scope === "SelectionStatement_switch") ? 49 : 81;
                  break;
                case 49:
                  param.scope = "SelectionStatement_switch_cs";
                  rt.enterScope(param.scope);
                  switchon = false;
                  i = 0;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.state = (i < stmts.length) ? 44 : 48;
                  break;
                case 44:
                  stmt = stmts[i];
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = (stmt.type === "Label_case" || stmt.type === "Label_default") ? 15 : 42;
                  break;
                case 15:
                  $__120 = interp.visit;
                  $__121 = $__120.call(interp, interp, stmt, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__123 = $ctx.wrapYieldStar($__121[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__124 = $__123[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__124.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__124.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__124.value;
                case 10:
                  $__122 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  r = $__122;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (r[1]) {
                    switchon = true;
                  }
                  $ctx.state = 20;
                  break;
                case 42:
                  $ctx.state = (switchon) ? 35 : 20;
                  break;
                case 35:
                  $__125 = interp.visit;
                  $__126 = $__125.call(interp, interp, stmt, param);
                  $ctx.state = 36;
                  break;
                case 36:
                  $__128 = $ctx.wrapYieldStar($__126[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 32;
                  break;
                case 32:
                  $__129 = $__128[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.state = ($__129.done) ? 23 : 22;
                  break;
                case 23:
                  $ctx.sent = $__129.value;
                  $ctx.state = 30;
                  break;
                case 22:
                  $ctx.state = 32;
                  return $__129.value;
                case 30:
                  $__127 = $ctx.sentIgnoreThrow;
                  $ctx.state = 34;
                  break;
                case 34:
                  r = $__127;
                  $ctx.state = 38;
                  break;
                case 38:
                  $ctx.state = (r instanceof Array) ? 39 : 20;
                  break;
                case 39:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 20:
                  i++;
                  $ctx.state = 50;
                  break;
                case 48:
                  rt.exitScope(param.scope);
                  param.scope = _scope;
                  $ctx.state = -2;
                  break;
                case 81:
                  param.scope = "CompoundStatement";
                  rt.enterScope(param.scope);
                  $ctx.state = 82;
                  break;
                case 82:
                  k = 0, len = stmts.length;
                  $ctx.state = 78;
                  break;
                case 78:
                  $ctx.state = (k < len) ? 74 : 76;
                  break;
                case 72:
                  k++;
                  $ctx.state = 78;
                  break;
                case 74:
                  stmt = stmts[k];
                  $ctx.state = 75;
                  break;
                case 75:
                  $__130 = interp.visit;
                  $__131 = $__130.call(interp, interp, stmt, param);
                  $ctx.state = 68;
                  break;
                case 68:
                  $__133 = $ctx.wrapYieldStar($__131[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 64;
                  break;
                case 64:
                  $__134 = $__133[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = ($__134.done) ? 55 : 54;
                  break;
                case 55:
                  $ctx.sent = $__134.value;
                  $ctx.state = 62;
                  break;
                case 54:
                  $ctx.state = 64;
                  return $__134.value;
                case 62:
                  $__132 = $ctx.sentIgnoreThrow;
                  $ctx.state = 66;
                  break;
                case 66:
                  r = $__132;
                  $ctx.state = 70;
                  break;
                case 70:
                  $ctx.state = (r instanceof Array) ? 76 : 72;
                  break;
                case 76:
                  rt.exitScope(param.scope);
                  param.scope = _scope;
                  $ctx.state = 84;
                  break;
                case 84:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__119, this);
        }),
        ExpressionStatement: $traceurRuntime.initGeneratorFunction(function $__135(interp, s, param) {
          var $__136,
              $__137;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 15;
                  break;
                case 15:
                  $ctx.state = (s.Expression != null) ? 11 : -2;
                  break;
                case 11:
                  $__136 = $ctx.wrapYieldStar(interp.visit(interp, s.Expression, param)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__137 = $__136[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__137.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__137.value;
                  $ctx.state = -2;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__137.value;
                default:
                  return $ctx.end();
              }
          }, $__135, this);
        }),
        SelectionStatement_if: $traceurRuntime.initGeneratorFunction(function $__138(interp, s, param) {
          var e,
              ret,
              scope_bak,
              $__139,
              $__140,
              $__141,
              $__142,
              $__143,
              $__144,
              $__145,
              $__146,
              $__147,
              $__148,
              $__149,
              $__150,
              $__151,
              $__152,
              $__153,
              $__154,
              $__155,
              $__156;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "SelectionStatement_if";
                  rt.enterScope(param.scope);
                  $ctx.state = 60;
                  break;
                case 60:
                  $__139 = interp.visit;
                  $__140 = s.Expression;
                  $__141 = $__139.call(interp, interp, $__140, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__143 = $ctx.wrapYieldStar($__141[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__144 = $__143[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__144.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__144.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__144.value;
                case 10:
                  $__142 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  e = $__142;
                  $ctx.state = 18;
                  break;
                case 18:
                  ret = void 0;
                  $ctx.state = 62;
                  break;
                case 62:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, e).v) ? 33 : 55;
                  break;
                case 33:
                  $__145 = interp.visit;
                  $__146 = s.Statement;
                  $__147 = $__145.call(interp, interp, $__146, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__149 = $ctx.wrapYieldStar($__147[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__150 = $__149[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__150.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__150.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__150.value;
                case 28:
                  $__148 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  ret = $__148;
                  $ctx.state = 36;
                  break;
                case 55:
                  $ctx.state = (s.ElseStatement) ? 51 : 36;
                  break;
                case 51:
                  $__151 = interp.visit;
                  $__152 = s.ElseStatement;
                  $__153 = $__151.call(interp, interp, $__152, param);
                  $ctx.state = 52;
                  break;
                case 52:
                  $__155 = $ctx.wrapYieldStar($__153[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__156 = $__155[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__156.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__156.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__156.value;
                case 46:
                  $__154 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  ret = $__154;
                  $ctx.state = 36;
                  break;
                case 36:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 64;
                  break;
                case 64:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__138, this);
        }),
        SelectionStatement_switch: $traceurRuntime.initGeneratorFunction(function $__157(interp, s, param) {
          var e,
              r,
              ret,
              scope_bak,
              switch_bak,
              $__158,
              $__159,
              $__160,
              $__161,
              $__162,
              $__163,
              $__164,
              $__165,
              $__166,
              $__167,
              $__168,
              $__169;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "SelectionStatement_switch";
                  rt.enterScope(param.scope);
                  $ctx.state = 40;
                  break;
                case 40:
                  $__158 = interp.visit;
                  $__159 = s.Expression;
                  $__160 = $__158.call(interp, interp, $__159, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__162 = $ctx.wrapYieldStar($__160[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__163 = $__162[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__163.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__163.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__163.value;
                case 10:
                  $__161 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  e = $__161;
                  $ctx.state = 18;
                  break;
                case 18:
                  switch_bak = param["switch"];
                  param["switch"] = e;
                  $ctx.state = 42;
                  break;
                case 42:
                  $__164 = interp.visit;
                  $__165 = s.Statement;
                  $__166 = $__164.call(interp, interp, $__165, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__168 = $ctx.wrapYieldStar($__166[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__169 = $__168[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__169.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__169.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__169.value;
                case 28:
                  $__167 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  r = $__167;
                  $ctx.state = 36;
                  break;
                case 36:
                  param["switch"] = switch_bak;
                  ret = void 0;
                  if (r instanceof Array) {
                    if (r[0] !== "break") {
                      ret = r;
                    }
                  }
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 44;
                  break;
                case 44:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__157, this);
        }),
        IterationStatement_while: $traceurRuntime.initGeneratorFunction(function $__170(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__171,
              $__172,
              $__173,
              $__174,
              $__175,
              $__176,
              $__177,
              $__178,
              $__179,
              $__180,
              $__181,
              $__182;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_while";
                  rt.enterScope(param.scope);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = (true) ? 24 : 57;
                  break;
                case 24:
                  $ctx.state = (s.Expression != null) ? 15 : 20;
                  break;
                case 15:
                  $__171 = interp.visit;
                  $__172 = s.Expression;
                  $__173 = $__171.call(interp, interp, $__172, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__175 = $ctx.wrapYieldStar($__173[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__176 = $__175[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__176.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__176.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__176.value;
                case 10:
                  $__174 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  cond = $__174;
                  $ctx.state = 18;
                  break;
                case 18:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (!cond) ? 57 : 20;
                  break;
                case 20:
                  $__177 = interp.visit;
                  $__178 = s.Statement;
                  $__179 = $__177.call(interp, interp, $__178, param);
                  $ctx.state = 40;
                  break;
                case 40:
                  $__181 = $ctx.wrapYieldStar($__179[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 36;
                  break;
                case 36:
                  $__182 = $__181[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.state = ($__182.done) ? 27 : 26;
                  break;
                case 27:
                  $ctx.sent = $__182.value;
                  $ctx.state = 34;
                  break;
                case 26:
                  $ctx.state = 36;
                  return $__182.value;
                case 34:
                  $__180 = $ctx.sentIgnoreThrow;
                  $ctx.state = 38;
                  break;
                case 38:
                  r = $__180;
                  $ctx.state = 42;
                  break;
                case 42:
                  $ctx.state = (r instanceof Array) ? 49 : 61;
                  break;
                case 49:
                  switch (r[0]) {
                    default:
                      $ctx.state = 50;
                      break;
                    case "continue":
                      $ctx.state = 50;
                      break;
                    case "break":
                      $ctx.state = 47;
                      break;
                    case "return":
                      $ctx.state = 51;
                      break;
                  }
                  break;
                case 47:
                  end_loop = true;
                  $ctx.state = 50;
                  break;
                case 51:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.state = (end_loop) ? 57 : 61;
                  break;
                case 57:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 63;
                  break;
                case 63:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__170, this);
        }),
        IterationStatement_do: $traceurRuntime.initGeneratorFunction(function $__183(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__184,
              $__185,
              $__186,
              $__187,
              $__188,
              $__189,
              $__190,
              $__191,
              $__192,
              $__193,
              $__194,
              $__195;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_do";
                  rt.enterScope(param.scope);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = (true) ? 15 : 57;
                  break;
                case 15:
                  $__184 = interp.visit;
                  $__185 = s.Statement;
                  $__186 = $__184.call(interp, interp, $__185, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__188 = $ctx.wrapYieldStar($__186[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__189 = $__188[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__189.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__189.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__189.value;
                case 10:
                  $__187 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  r = $__187;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = (r instanceof Array) ? 25 : 30;
                  break;
                case 25:
                  switch (r[0]) {
                    default:
                      $ctx.state = 26;
                      break;
                    case "continue":
                      $ctx.state = 26;
                      break;
                    case "break":
                      $ctx.state = 23;
                      break;
                    case "return":
                      $ctx.state = 27;
                      break;
                  }
                  break;
                case 23:
                  end_loop = true;
                  $ctx.state = 26;
                  break;
                case 27:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = (end_loop) ? 57 : 30;
                  break;
                case 30:
                  $ctx.state = (s.Expression != null) ? 47 : 61;
                  break;
                case 47:
                  $__190 = interp.visit;
                  $__191 = s.Expression;
                  $__192 = $__190.call(interp, interp, $__191, param);
                  $ctx.state = 48;
                  break;
                case 48:
                  $__194 = $ctx.wrapYieldStar($__192[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 44;
                  break;
                case 44:
                  $__195 = $__194[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = ($__195.done) ? 35 : 34;
                  break;
                case 35:
                  $ctx.sent = $__195.value;
                  $ctx.state = 42;
                  break;
                case 34:
                  $ctx.state = 44;
                  return $__195.value;
                case 42:
                  $__193 = $ctx.sentIgnoreThrow;
                  $ctx.state = 46;
                  break;
                case 46:
                  cond = $__193;
                  $ctx.state = 50;
                  break;
                case 50:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 55;
                  break;
                case 55:
                  $ctx.state = (!cond) ? 57 : 61;
                  break;
                case 57:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 63;
                  break;
                case 63:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__183, this);
        }),
        IterationStatement_for: $traceurRuntime.initGeneratorFunction(function $__196(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__197,
              $__198,
              $__199,
              $__200,
              $__201,
              $__202,
              $__203,
              $__204,
              $__205,
              $__206,
              $__207,
              $__208,
              $__209,
              $__210,
              $__211,
              $__212,
              $__213,
              $__214;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_for";
                  rt.enterScope(param.scope);
                  $ctx.state = 100;
                  break;
                case 100:
                  $ctx.state = (s.Initializer) ? 25 : 10;
                  break;
                case 25:
                  $ctx.state = (s.Initializer.type === "Declaration") ? 11 : 23;
                  break;
                case 11:
                  $__197 = $ctx.wrapYieldStar(interp.visit(interp, s.Initializer, param)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__198 = $__197[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__198.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__198.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__198.value;
                case 23:
                  $__199 = $ctx.wrapYieldStar(interp.visit(interp, s.Initializer, param)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 24;
                  break;
                case 24:
                  $__200 = $__199[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 21;
                  break;
                case 21:
                  $ctx.state = ($__200.done) ? 15 : 14;
                  break;
                case 15:
                  $ctx.sent = $__200.value;
                  $ctx.state = 10;
                  break;
                case 14:
                  $ctx.state = 24;
                  return $__200.value;
                case 10:
                  $ctx.state = (true) ? 50 : 96;
                  break;
                case 50:
                  $ctx.state = (s.Expression != null) ? 41 : 46;
                  break;
                case 41:
                  $__201 = interp.visit;
                  $__202 = s.Expression;
                  $__203 = $__201.call(interp, interp, $__202, param);
                  $ctx.state = 42;
                  break;
                case 42:
                  $__205 = $ctx.wrapYieldStar($__203[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 38;
                  break;
                case 38:
                  $__206 = $__205[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 35;
                  break;
                case 35:
                  $ctx.state = ($__206.done) ? 29 : 28;
                  break;
                case 29:
                  $ctx.sent = $__206.value;
                  $ctx.state = 36;
                  break;
                case 28:
                  $ctx.state = 38;
                  return $__206.value;
                case 36:
                  $__204 = $ctx.sentIgnoreThrow;
                  $ctx.state = 40;
                  break;
                case 40:
                  cond = $__204;
                  $ctx.state = 44;
                  break;
                case 44:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 49;
                  break;
                case 49:
                  $ctx.state = (!cond) ? 96 : 46;
                  break;
                case 46:
                  $__207 = interp.visit;
                  $__208 = s.Statement;
                  $__209 = $__207.call(interp, interp, $__208, param);
                  $ctx.state = 66;
                  break;
                case 66:
                  $__211 = $ctx.wrapYieldStar($__209[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 62;
                  break;
                case 62:
                  $__212 = $__211[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 59;
                  break;
                case 59:
                  $ctx.state = ($__212.done) ? 53 : 52;
                  break;
                case 53:
                  $ctx.sent = $__212.value;
                  $ctx.state = 60;
                  break;
                case 52:
                  $ctx.state = 62;
                  return $__212.value;
                case 60:
                  $__210 = $ctx.sentIgnoreThrow;
                  $ctx.state = 64;
                  break;
                case 64:
                  r = $__210;
                  $ctx.state = 68;
                  break;
                case 68:
                  $ctx.state = (r instanceof Array) ? 75 : 80;
                  break;
                case 75:
                  switch (r[0]) {
                    default:
                      $ctx.state = 76;
                      break;
                    case "continue":
                      $ctx.state = 76;
                      break;
                    case "break":
                      $ctx.state = 73;
                      break;
                    case "return":
                      $ctx.state = 77;
                      break;
                  }
                  break;
                case 73:
                  end_loop = true;
                  $ctx.state = 76;
                  break;
                case 77:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 76;
                  break;
                case 76:
                  $ctx.state = (end_loop) ? 96 : 80;
                  break;
                case 80:
                  $ctx.state = (s.Loop) ? 93 : 10;
                  break;
                case 93:
                  $__213 = $ctx.wrapYieldStar(interp.visit(interp, s.Loop, param)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 94;
                  break;
                case 94:
                  $__214 = $__213[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 91;
                  break;
                case 91:
                  $ctx.state = ($__214.done) ? 85 : 84;
                  break;
                case 85:
                  $ctx.sent = $__214.value;
                  $ctx.state = 10;
                  break;
                case 84:
                  $ctx.state = 94;
                  return $__214.value;
                case 96:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 102;
                  break;
                case 102:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__196, this);
        }),
        JumpStatement_goto: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        JumpStatement_continue: function(interp, s, param) {
          rt = interp.rt;
          return ["continue"];
        },
        JumpStatement_break: function(interp, s, param) {
          rt = interp.rt;
          return ["break"];
        },
        JumpStatement_return: $traceurRuntime.initGeneratorFunction(function $__215(interp, s, param) {
          var ret,
              $__216,
              $__217,
              $__218,
              $__219,
              $__220,
              $__221;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = (s.Expression) ? 15 : 20;
                  break;
                case 15:
                  $__216 = interp.visit;
                  $__217 = s.Expression;
                  $__218 = $__216.call(interp, interp, $__217, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__220 = $ctx.wrapYieldStar($__218[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__221 = $__220[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__221.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__221.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__221.value;
                case 10:
                  $__219 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__219;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = ["return", ret];
                  $ctx.state = -2;
                  break;
                case 20:
                  $ctx.returnValue = ["return"];
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__215, this);
        }),
        IdentifierExpression: function(interp, s, param) {
          rt = interp.rt;
          return rt.readVar(s.Identifier);
        },
        ParenthesesExpression: $traceurRuntime.initGeneratorFunction(function $__222(interp, s, param) {
          var $__223,
              $__224,
              $__225,
              $__226,
              $__227,
              $__228;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__223 = interp.visit;
                  $__224 = s.Expression;
                  $__225 = $__223.call(interp, interp, $__224, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__227 = $ctx.wrapYieldStar($__225[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__228 = $__227[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__228.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__228.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__228.value;
                case 10:
                  $__226 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__226;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__222, this);
        }),
        PostfixExpression_ArrayAccess: $traceurRuntime.initGeneratorFunction(function $__229(interp, s, param) {
          var index,
              r,
              ret,
              $__230,
              $__231,
              $__232,
              $__233,
              $__234,
              $__235,
              $__236,
              $__237,
              $__238,
              $__239,
              $__240,
              $__241,
              $__242,
              $__243,
              $__244;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__230 = interp.visit;
                  $__231 = s.Expression;
                  $__232 = $__230.call(interp, interp, $__231, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__234 = $ctx.wrapYieldStar($__232[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__235 = $__234[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__235.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__235.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__235.value;
                case 10:
                  $__233 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__233;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__236 = interp.visit;
                  $__237 = s.index;
                  $__238 = $__236.call(interp, interp, $__237, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__240 = $ctx.wrapYieldStar($__238[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__241 = $__240[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__241.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__241.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__241.value;
                case 28:
                  $__239 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  index = $__239;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("[]"), [index.t])(rt, ret, index);
                  $ctx.state = 59;
                  break;
                case 59:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__243 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__244 = $__243[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__244.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__244.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__244.value;
                case 46:
                  $__242 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__242;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__229, this);
        }),
        PostfixExpression_MethodInvocation: $traceurRuntime.initGeneratorFunction(function $__245(interp, s, param) {
          var args,
              bindThis,
              e,
              r,
              ret,
              thisArg,
              $__252,
              $__253,
              $__254,
              $__255,
              $__256,
              $__257,
              $__258,
              $__259,
              $__260,
              $__261,
              $__262,
              $__263,
              $__264,
              $__265,
              $__266,
              $__267;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__252 = interp.visit;
                  $__253 = s.Expression;
                  $__254 = $__252.call(interp, interp, $__253, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__256 = $ctx.wrapYieldStar($__254[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__257 = $__256[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__257.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__257.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__257.value;
                case 10:
                  $__255 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__255;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__258 = $traceurRuntime.initGeneratorFunction;
                  $__259 = function $__246() {
                    var k,
                        len,
                        ref,
                        results,
                        $__247,
                        $__248,
                        $__249,
                        $__250,
                        $__251;
                    return $traceurRuntime.createGeneratorInstance(function($ctx) {
                      while (true)
                        switch ($ctx.state) {
                          case 0:
                            ref = s.args;
                            results = [];
                            $ctx.state = 29;
                            break;
                          case 29:
                            k = 0, len = ref.length;
                            $ctx.state = 25;
                            break;
                          case 25:
                            $ctx.state = (k < len) ? 19 : 23;
                            break;
                          case 22:
                            k++;
                            $ctx.state = 25;
                            break;
                          case 19:
                            e = ref[k];
                            $ctx.state = 20;
                            break;
                          case 20:
                            $__247 = interp.visit;
                            $__248 = $__247.call(interp, interp, e, param);
                            $ctx.state = 16;
                            break;
                          case 16:
                            $__250 = $ctx.wrapYieldStar($__248[Symbol.iterator]());
                            $ctx.sent = void 0;
                            $ctx.action = 'next';
                            $ctx.state = 12;
                            break;
                          case 12:
                            $__251 = $__250[$ctx.action]($ctx.sentIgnoreThrow);
                            $ctx.state = 9;
                            break;
                          case 9:
                            $ctx.state = ($__251.done) ? 3 : 2;
                            break;
                          case 3:
                            $ctx.sent = $__251.value;
                            $ctx.state = 10;
                            break;
                          case 2:
                            $ctx.state = 12;
                            return $__251.value;
                          case 10:
                            $__249 = $ctx.sentIgnoreThrow;
                            $ctx.state = 14;
                            break;
                          case 14:
                            thisArg = $__249;
                            $ctx.state = 18;
                            break;
                          case 18:
                            results.push(thisArg);
                            $ctx.state = 22;
                            break;
                          case 23:
                            $ctx.returnValue = results;
                            $ctx.state = -2;
                            break;
                          default:
                            return $ctx.end();
                        }
                    }, $__246, this);
                  };
                  $__260 = $__258.call($traceurRuntime, $__259);
                  $__261 = $__260();
                  $ctx.state = 34;
                  break;
                case 34:
                  $__263 = $ctx.wrapYieldStar($__261[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__264 = $__263[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__264.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__264.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__264.value;
                case 28:
                  $__262 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  args = $__262;
                  $ctx.state = 36;
                  break;
                case 36:
                  if (ret.v.bindThis != null) {
                    bindThis = ret.v.bindThis;
                  } else {
                    bindThis = ret;
                  }
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("()"), args.map(function(e) {
                    return e.t;
                  }))(rt, ret, bindThis, args);
                  $ctx.state = 59;
                  break;
                case 59:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__266 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__267 = $__266[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__267.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__267.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__267.value;
                case 46:
                  $__265 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__265;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__245, this);
        }),
        PostfixExpression_MemberAccess: $traceurRuntime.initGeneratorFunction(function $__246(interp, s, param) {
          var ret,
              $__268,
              $__269,
              $__270,
              $__271,
              $__272,
              $__273;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__268 = interp.visit;
                  $__269 = s.Expression;
                  $__270 = $__268.call(interp, interp, $__269, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__272 = $ctx.wrapYieldStar($__270[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__273 = $__272[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__273.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__273.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__273.value;
                case 10:
                  $__271 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__271;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.getMember(ret, s.member);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__246, this);
        }),
        PostfixExpression_MemberPointerAccess: $traceurRuntime.initGeneratorFunction(function $__274(interp, s, param) {
          var member,
              r,
              ret,
              $__275,
              $__276,
              $__277,
              $__278,
              $__279,
              $__280,
              $__281,
              $__282,
              $__283,
              $__284,
              $__285,
              $__286,
              $__287,
              $__288,
              $__289,
              $__290,
              $__291,
              $__292,
              $__293;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__275 = interp.visit;
                  $__276 = s.Expression;
                  $__277 = $__275.call(interp, interp, $__276, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__279 = $ctx.wrapYieldStar($__277[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__280 = $__279[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__280.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__280.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__280.value;
                case 10:
                  $__278 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__278;
                  $ctx.state = 18;
                  break;
                case 18:
                  member = void 0;
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = (rt.isPointerType(ret.t) && !rt.isFunctionType(ret.t)) ? 38 : 54;
                  break;
                case 38:
                  member = s.member;
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("->"), [])(rt, ret, member);
                  $ctx.state = 39;
                  break;
                case 39:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__282 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__283 = $__282[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__283.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__283.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__283.value;
                case 28:
                  $__281 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__281;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 54:
                  $__284 = interp.visit;
                  $__285 = s.member;
                  $__286 = {
                    type: "IdentifierExpression",
                    Identifier: $__285
                  };
                  $__287 = $__284.call(interp, interp, $__286, param);
                  $ctx.state = 55;
                  break;
                case 55:
                  $__289 = $ctx.wrapYieldStar($__287[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 51;
                  break;
                case 51:
                  $__290 = $__289[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 48;
                  break;
                case 48:
                  $ctx.state = ($__290.done) ? 42 : 41;
                  break;
                case 42:
                  $ctx.sent = $__290.value;
                  $ctx.state = 49;
                  break;
                case 41:
                  $ctx.state = 51;
                  return $__290.value;
                case 49:
                  $__288 = $ctx.sentIgnoreThrow;
                  $ctx.state = 53;
                  break;
                case 53:
                  member = $__288;
                  $ctx.state = 57;
                  break;
                case 57:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("->"), [member.t])(rt, ret, member);
                  $ctx.state = 78;
                  break;
                case 78:
                  $ctx.state = (isGenerator(r)) ? 68 : 74;
                  break;
                case 68:
                  $__292 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 69;
                  break;
                case 69:
                  $__293 = $__292[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 66;
                  break;
                case 66:
                  $ctx.state = ($__293.done) ? 60 : 59;
                  break;
                case 60:
                  $ctx.sent = $__293.value;
                  $ctx.state = 67;
                  break;
                case 59:
                  $ctx.state = 69;
                  return $__293.value;
                case 67:
                  $__291 = $ctx.sentIgnoreThrow;
                  $ctx.state = 71;
                  break;
                case 71:
                  $ctx.returnValue = $__291;
                  $ctx.state = -2;
                  break;
                case 74:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__274, this);
        }),
        PostfixExpression_PostIncrement: $traceurRuntime.initGeneratorFunction(function $__294(interp, s, param) {
          var r,
              ret,
              $__295,
              $__296,
              $__297,
              $__298,
              $__299,
              $__300,
              $__301,
              $__302,
              $__303;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__295 = interp.visit;
                  $__296 = s.Expression;
                  $__297 = $__295.call(interp, interp, $__296, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__299 = $ctx.wrapYieldStar($__297[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__300 = $__299[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__300.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__300.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__300.value;
                case 10:
                  $__298 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__298;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("++"), ["dummy"])(rt, ret, {
                    t: "dummy",
                    v: null
                  });
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__302 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__303 = $__302[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__303.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__303.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__303.value;
                case 28:
                  $__301 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__301;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__294, this);
        }),
        PostfixExpression_PostDecrement: $traceurRuntime.initGeneratorFunction(function $__304(interp, s, param) {
          var r,
              ret,
              $__305,
              $__306,
              $__307,
              $__308,
              $__309,
              $__310,
              $__311,
              $__312,
              $__313;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__305 = interp.visit;
                  $__306 = s.Expression;
                  $__307 = $__305.call(interp, interp, $__306, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__309 = $ctx.wrapYieldStar($__307[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__310 = $__309[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__310.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__310.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__310.value;
                case 10:
                  $__308 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__308;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("--"), ["dummy"])(rt, ret, {
                    t: "dummy",
                    v: null
                  });
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__312 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__313 = $__312[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__313.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__313.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__313.value;
                case 28:
                  $__311 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__311;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__304, this);
        }),
        UnaryExpression_PreIncrement: $traceurRuntime.initGeneratorFunction(function $__314(interp, s, param) {
          var r,
              ret,
              $__315,
              $__316,
              $__317,
              $__318,
              $__319,
              $__320,
              $__321,
              $__322,
              $__323;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__315 = interp.visit;
                  $__316 = s.Expression;
                  $__317 = $__315.call(interp, interp, $__316, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__319 = $ctx.wrapYieldStar($__317[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__320 = $__319[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__320.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__320.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__320.value;
                case 10:
                  $__318 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__318;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("++"), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__322 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__323 = $__322[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__323.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__323.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__323.value;
                case 28:
                  $__321 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__321;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__314, this);
        }),
        UnaryExpression_PreDecrement: $traceurRuntime.initGeneratorFunction(function $__324(interp, s, param) {
          var r,
              ret,
              $__325,
              $__326,
              $__327,
              $__328,
              $__329,
              $__330,
              $__331,
              $__332,
              $__333;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__325 = interp.visit;
                  $__326 = s.Expression;
                  $__327 = $__325.call(interp, interp, $__326, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__329 = $ctx.wrapYieldStar($__327[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__330 = $__329[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__330.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__330.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__330.value;
                case 10:
                  $__328 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__328;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("--"), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__332 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__333 = $__332[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__333.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__333.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__333.value;
                case 28:
                  $__331 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__331;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__324, this);
        }),
        UnaryExpression: $traceurRuntime.initGeneratorFunction(function $__334(interp, s, param) {
          var r,
              ret,
              $__335,
              $__336,
              $__337,
              $__338,
              $__339,
              $__340,
              $__341,
              $__342,
              $__343;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__335 = interp.visit;
                  $__336 = s.Expression;
                  $__337 = $__335.call(interp, interp, $__336, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__339 = $ctx.wrapYieldStar($__337[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__340 = $__339[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__340.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__340.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__340.value;
                case 10:
                  $__338 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__338;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName(s.op), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__342 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__343 = $__342[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__343.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__343.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__343.value;
                case 28:
                  $__341 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__341;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__334, this);
        }),
        UnaryExpression_Sizeof_Expr: $traceurRuntime.initGeneratorFunction(function $__344(interp, s, param) {
          var ret,
              $__345,
              $__346,
              $__347,
              $__348,
              $__349,
              $__350;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__345 = interp.visit;
                  $__346 = s.Expression;
                  $__347 = $__345.call(interp, interp, $__346, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__349 = $ctx.wrapYieldStar($__347[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__350 = $__349[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__350.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__350.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__350.value;
                case 10:
                  $__348 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__348;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.intTypeLiteral, rt.getSize(ret));
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__344, this);
        }),
        UnaryExpression_Sizeof_Type: $traceurRuntime.initGeneratorFunction(function $__351(interp, s, param) {
          var type,
              $__352,
              $__353,
              $__354,
              $__355,
              $__356,
              $__357;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__352 = interp.visit;
                  $__353 = s.TypeName;
                  $__354 = $__352.call(interp, interp, $__353, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__356 = $ctx.wrapYieldStar($__354[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__357 = $__356[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__357.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__357.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__357.value;
                case 10:
                  $__355 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  type = $__355;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.intTypeLiteral, rt.getSizeByType(type));
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__351, this);
        }),
        CastExpression: $traceurRuntime.initGeneratorFunction(function $__358(interp, s, param) {
          var ret,
              type,
              $__359,
              $__360,
              $__361,
              $__362,
              $__363,
              $__364,
              $__365,
              $__366,
              $__367,
              $__368,
              $__369,
              $__370;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 40;
                  break;
                case 40:
                  $__359 = interp.visit;
                  $__360 = s.Expression;
                  $__361 = $__359.call(interp, interp, $__360, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__363 = $ctx.wrapYieldStar($__361[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__364 = $__363[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__364.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__364.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__364.value;
                case 10:
                  $__362 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__362;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__365 = interp.visit;
                  $__366 = s.TypeName;
                  $__367 = $__365.call(interp, interp, $__366, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__369 = $ctx.wrapYieldStar($__367[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__370 = $__369[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__370.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__370.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__370.value;
                case 28:
                  $__368 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  type = $__368;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.returnValue = rt.cast(type, ret);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__358, this);
        }),
        TypeName: function(interp, s, param) {
          var baseType,
              k,
              len,
              ref,
              typename;
          rt = interp.rt;
          typename = [];
          ref = s.base;
          for (k = 0, len = ref.length; k < len; k++) {
            baseType = ref[k];
            if (baseType !== "const") {
              typename.push(baseType);
            }
          }
          return rt.simpleType(typename);
        },
        BinOpExpression: $traceurRuntime.initGeneratorFunction(function $__371(interp, s, param) {
          var left,
              op,
              r,
              right,
              $__372,
              $__373,
              $__374,
              $__375,
              $__376,
              $__377,
              $__378,
              $__379,
              $__380,
              $__381,
              $__382,
              $__383,
              $__384,
              $__385,
              $__386,
              $__387,
              $__388,
              $__389,
              $__390,
              $__391,
              $__392,
              $__393,
              $__394,
              $__395,
              $__396;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  op = s.op;
                  $ctx.state = 101;
                  break;
                case 101:
                  $ctx.state = (op === "&&") ? 19 : 98;
                  break;
                case 19:
                  s.type = "LogicalANDExpression";
                  $ctx.state = 20;
                  break;
                case 20:
                  $__372 = interp.visit;
                  $__373 = $__372.call(interp, interp, s, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__375 = $ctx.wrapYieldStar($__373[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__376 = $__375[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__376.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__376.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__376.value;
                case 10:
                  $__374 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__374;
                  $ctx.state = -2;
                  break;
                case 98:
                  $ctx.state = (op === "||") ? 39 : 55;
                  break;
                case 39:
                  s.type = "LogicalORExpression";
                  $ctx.state = 40;
                  break;
                case 40:
                  $__377 = interp.visit;
                  $__378 = $__377.call(interp, interp, s, param);
                  $ctx.state = 36;
                  break;
                case 36:
                  $__380 = $ctx.wrapYieldStar($__378[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 32;
                  break;
                case 32:
                  $__381 = $__380[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.state = ($__381.done) ? 23 : 22;
                  break;
                case 23:
                  $ctx.sent = $__381.value;
                  $ctx.state = 30;
                  break;
                case 22:
                  $ctx.state = 32;
                  return $__381.value;
                case 30:
                  $__379 = $ctx.sentIgnoreThrow;
                  $ctx.state = 34;
                  break;
                case 34:
                  $ctx.returnValue = $__379;
                  $ctx.state = -2;
                  break;
                case 55:
                  $__382 = interp.visit;
                  $__383 = s.left;
                  $__384 = $__382.call(interp, interp, $__383, param);
                  $ctx.state = 56;
                  break;
                case 56:
                  $__386 = $ctx.wrapYieldStar($__384[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 52;
                  break;
                case 52:
                  $__387 = $__386[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 49;
                  break;
                case 49:
                  $ctx.state = ($__387.done) ? 43 : 42;
                  break;
                case 43:
                  $ctx.sent = $__387.value;
                  $ctx.state = 50;
                  break;
                case 42:
                  $ctx.state = 52;
                  return $__387.value;
                case 50:
                  $__385 = $ctx.sentIgnoreThrow;
                  $ctx.state = 54;
                  break;
                case 54:
                  left = $__385;
                  $ctx.state = 58;
                  break;
                case 58:
                  $__388 = interp.visit;
                  $__389 = s.right;
                  $__390 = $__388.call(interp, interp, $__389, param);
                  $ctx.state = 74;
                  break;
                case 74:
                  $__392 = $ctx.wrapYieldStar($__390[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 70;
                  break;
                case 70:
                  $__393 = $__392[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 67;
                  break;
                case 67:
                  $ctx.state = ($__393.done) ? 61 : 60;
                  break;
                case 61:
                  $ctx.sent = $__393.value;
                  $ctx.state = 68;
                  break;
                case 60:
                  $ctx.state = 70;
                  return $__393.value;
                case 68:
                  $__391 = $ctx.sentIgnoreThrow;
                  $ctx.state = 72;
                  break;
                case 72:
                  right = $__391;
                  $ctx.state = 76;
                  break;
                case 76:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName(op), [right.t])(rt, left, right);
                  $ctx.state = 97;
                  break;
                case 97:
                  $ctx.state = (isGenerator(r)) ? 87 : 93;
                  break;
                case 87:
                  $__395 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 88;
                  break;
                case 88:
                  $__396 = $__395[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 85;
                  break;
                case 85:
                  $ctx.state = ($__396.done) ? 79 : 78;
                  break;
                case 79:
                  $ctx.sent = $__396.value;
                  $ctx.state = 86;
                  break;
                case 78:
                  $ctx.state = 88;
                  return $__396.value;
                case 86:
                  $__394 = $ctx.sentIgnoreThrow;
                  $ctx.state = 90;
                  break;
                case 90:
                  $ctx.returnValue = $__394;
                  $ctx.state = -2;
                  break;
                case 93:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__371, this);
        }),
        LogicalANDExpression: $traceurRuntime.initGeneratorFunction(function $__397(interp, s, param) {
          var left,
              lt,
              r,
              right,
              $__398,
              $__399,
              $__400,
              $__401,
              $__402,
              $__403,
              $__404,
              $__405,
              $__406,
              $__407,
              $__408,
              $__409,
              $__410,
              $__411,
              $__412,
              $__413,
              $__414,
              $__415,
              $__416,
              $__417,
              $__418;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__398 = interp.visit;
                  $__399 = s.left;
                  $__400 = $__398.call(interp, interp, $__399, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__402 = $ctx.wrapYieldStar($__400[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__403 = $__402[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__403.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__403.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__403.value;
                case 10:
                  $__401 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  left = $__401;
                  $ctx.state = 18;
                  break;
                case 18:
                  lt = rt.types[rt.getTypeSignature(left.t)];
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = ("&&" in lt) ? 33 : 78;
                  break;
                case 33:
                  $__404 = interp.visit;
                  $__405 = s.right;
                  $__406 = $__404.call(interp, interp, $__405, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__408 = $ctx.wrapYieldStar($__406[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__409 = $__408[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__409.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__409.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__409.value;
                case 28:
                  $__407 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  right = $__407;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName("&&"), [right.t])(rt, left, right);
                  $ctx.state = 57;
                  break;
                case 57:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__411 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__412 = $__411[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__412.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__412.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__412.value;
                case 46:
                  $__410 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__410;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 78:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, left).v) ? 72 : 76;
                  break;
                case 72:
                  $__413 = interp.visit;
                  $__414 = s.right;
                  $__415 = $__413.call(interp, interp, $__414, param);
                  $ctx.state = 73;
                  break;
                case 73:
                  $__417 = $ctx.wrapYieldStar($__415[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 69;
                  break;
                case 69:
                  $__418 = $__417[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 66;
                  break;
                case 66:
                  $ctx.state = ($__418.done) ? 60 : 59;
                  break;
                case 60:
                  $ctx.sent = $__418.value;
                  $ctx.state = 67;
                  break;
                case 59:
                  $ctx.state = 69;
                  return $__418.value;
                case 67:
                  $__416 = $ctx.sentIgnoreThrow;
                  $ctx.state = 71;
                  break;
                case 71:
                  $ctx.returnValue = $__416;
                  $ctx.state = -2;
                  break;
                case 76:
                  $ctx.returnValue = left;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__397, this);
        }),
        LogicalORExpression: $traceurRuntime.initGeneratorFunction(function $__419(interp, s, param) {
          var left,
              lt,
              r,
              right,
              $__420,
              $__421,
              $__422,
              $__423,
              $__424,
              $__425,
              $__426,
              $__427,
              $__428,
              $__429,
              $__430,
              $__431,
              $__432,
              $__433,
              $__434,
              $__435,
              $__436,
              $__437,
              $__438,
              $__439,
              $__440;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__420 = interp.visit;
                  $__421 = s.left;
                  $__422 = $__420.call(interp, interp, $__421, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__424 = $ctx.wrapYieldStar($__422[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__425 = $__424[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__425.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__425.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__425.value;
                case 10:
                  $__423 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  left = $__423;
                  $ctx.state = 18;
                  break;
                case 18:
                  lt = rt.types[rt.getTypeSignature(left.t)];
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = ("||" in lt) ? 33 : 78;
                  break;
                case 33:
                  $__426 = interp.visit;
                  $__427 = s.right;
                  $__428 = $__426.call(interp, interp, $__427, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__430 = $ctx.wrapYieldStar($__428[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__431 = $__430[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__431.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__431.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__431.value;
                case 28:
                  $__429 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  right = $__429;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName("||"), [right.t])(rt, left, right);
                  $ctx.state = 57;
                  break;
                case 57:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__433 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__434 = $__433[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__434.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__434.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__434.value;
                case 46:
                  $__432 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__432;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 78:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, left).v) ? 58 : 74;
                  break;
                case 58:
                  $ctx.returnValue = left;
                  $ctx.state = -2;
                  break;
                case 74:
                  $__435 = interp.visit;
                  $__436 = s.right;
                  $__437 = $__435.call(interp, interp, $__436, param);
                  $ctx.state = 75;
                  break;
                case 75:
                  $__439 = $ctx.wrapYieldStar($__437[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 71;
                  break;
                case 71:
                  $__440 = $__439[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 68;
                  break;
                case 68:
                  $ctx.state = ($__440.done) ? 62 : 61;
                  break;
                case 62:
                  $ctx.sent = $__440.value;
                  $ctx.state = 69;
                  break;
                case 61:
                  $ctx.state = 71;
                  return $__440.value;
                case 69:
                  $__438 = $ctx.sentIgnoreThrow;
                  $ctx.state = 73;
                  break;
                case 73:
                  $ctx.returnValue = $__438;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__419, this);
        }),
        ConditionalExpression: $traceurRuntime.initGeneratorFunction(function $__441(interp, s, param) {
          var cond,
              $__442,
              $__443,
              $__444,
              $__445,
              $__446,
              $__447,
              $__448,
              $__449,
              $__450,
              $__451,
              $__452,
              $__453,
              $__454,
              $__455,
              $__456,
              $__457,
              $__458,
              $__459,
              $__460,
              $__461,
              $__462,
              $__463;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__442 = rt.cast;
                  $__443 = rt.boolTypeLiteral;
                  $__444 = interp.visit;
                  $__445 = s.cond;
                  $__446 = $__444.call(interp, interp, $__445, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__450 = $ctx.wrapYieldStar($__446[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__451 = $__450[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__451.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__451.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__451.value;
                case 10:
                  $__447 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__448 = $__442.call(rt, $__443, $__447);
                  $__449 = $__448.v;
                  cond = $__449;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = (cond) ? 33 : 51;
                  break;
                case 33:
                  $__452 = interp.visit;
                  $__453 = s.t;
                  $__454 = $__452.call(interp, interp, $__453, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__456 = $ctx.wrapYieldStar($__454[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__457 = $__456[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__457.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__457.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__457.value;
                case 28:
                  $__455 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__455;
                  $ctx.state = -2;
                  break;
                case 51:
                  $__458 = interp.visit;
                  $__459 = s.f;
                  $__460 = $__458.call(interp, interp, $__459, param);
                  $ctx.state = 52;
                  break;
                case 52:
                  $__462 = $ctx.wrapYieldStar($__460[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__463 = $__462[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__463.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__463.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__463.value;
                case 46:
                  $__461 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__461;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__441, this);
        }),
        ConstantExpression: $traceurRuntime.initGeneratorFunction(function $__464(interp, s, param) {
          var $__465,
              $__466,
              $__467,
              $__468,
              $__469,
              $__470;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__465 = interp.visit;
                  $__466 = s.Expression;
                  $__467 = $__465.call(interp, interp, $__466, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__469 = $ctx.wrapYieldStar($__467[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__470 = $__469[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__470.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__470.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__470.value;
                case 10:
                  $__468 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__468;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__464, this);
        }),
        StringLiteralExpression: $traceurRuntime.initGeneratorFunction(function $__471(interp, s, param) {
          var $__472,
              $__473,
              $__474,
              $__475,
              $__476,
              $__477;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__472 = interp.visit;
                  $__473 = s.value;
                  $__474 = $__472.call(interp, interp, $__473, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__476 = $ctx.wrapYieldStar($__474[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__477 = $__476[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__477.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__477.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__477.value;
                case 10:
                  $__475 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__475;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__471, this);
        }),
        StringLiteral: function(interp, s, param) {
          var code,
              i,
              k,
              len,
              limits,
              maxCode,
              minCode,
              ref,
              typeName;
          rt = interp.rt;
          switch (s.prefix) {
            case null:
              maxCode = -1;
              minCode = 1;
              ref = s.value;
              for (k = 0, len = ref.length; k < len; k++) {
                i = ref[k];
                code = i.charCodeAt(0);
                if (maxCode < code) {
                  maxCode = code;
                }
                if (minCode > code) {
                  minCode = code;
                }
              }
              limits = rt.config.limits;
              typeName = maxCode <= limits["char"].max && minCode >= limits["char"].min ? "char" : "wchar_t";
              return rt.makeCharArrayFromString(s.value, typeName);
            case "L":
              return rt.makeCharArrayFromString(s.value, "wchar_t");
            case "u8":
              return rt.makeCharArrayFromString(s.value, "char");
            case "u":
              return rt.makeCharArrayFromString(s.value, "char16_t");
            case "U":
              return rt.makeCharArrayFromString(s.value, "char32_t");
          }
        },
        BooleanConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.boolTypeLiteral, s.value === "true" ? 1 : 0);
        },
        CharacterConstant: function(interp, s, param) {
          var a;
          rt = interp.rt;
          a = s.Char;
          if (a.length !== 1) {
            rt.raiseException("a character constant must have and only have one character.");
          }
          return rt.val(rt.charTypeLiteral, a[0].charCodeAt(0));
        },
        FloatConstant: $traceurRuntime.initGeneratorFunction(function $__478(interp, s, param) {
          var val,
              $__479,
              $__480,
              $__481,
              $__482,
              $__483,
              $__484;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__479 = interp.visit;
                  $__480 = s.Expression;
                  $__481 = $__479.call(interp, interp, $__480, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__483 = $ctx.wrapYieldStar($__481[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__484 = $__483[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__484.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__484.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__484.value;
                case 10:
                  $__482 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  val = $__482;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.floatTypeLiteral, val.v);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__478, this);
        }),
        DecimalConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 10));
        },
        HexConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 16));
        },
        BinaryConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 2));
        },
        DecimalFloatConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.doubleTypeLiteral, parseFloat(s.value));
        },
        HexFloatConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.doubleTypeLiteral, parseFloat(s.value, 16));
        },
        OctalConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 8));
        },
        NamespaceDefinition: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        UsingDirective: function(interp, s, param) {
          var id;
          rt = interp.rt;
          id = s.Identifier;
        },
        UsingDeclaration: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        NamespaceAliasDefinition: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        unknown: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("unhandled syntax " + s.type);
        }
      };
    };
    Interpreter.prototype.visit = $traceurRuntime.initGeneratorFunction(function $__13(interp, s, param) {
      var _node,
          f,
          ret,
          rt,
          $__485,
          $__486,
          $__487,
          $__488;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              rt = interp.rt;
              $ctx.state = 39;
              break;
            case 39:
              $ctx.state = ("type" in s) ? 29 : 33;
              break;
            case 29:
              if (param === void 0) {
                param = {scope: "global"};
              }
              _node = this.currentNode;
              this.currentNode = s;
              $ctx.state = 30;
              break;
            case 30:
              $ctx.state = (s.type in this.visitors) ? 24 : 26;
              break;
            case 24:
              f = this.visitors[s.type];
              $ctx.state = 25;
              break;
            case 25:
              $ctx.state = (isGeneratorFunction(f)) ? 15 : 19;
              break;
            case 15:
              $__485 = f(interp, s, param);
              $ctx.state = 16;
              break;
            case 16:
              $__487 = $ctx.wrapYieldStar($__485[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__488 = $__487[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__488.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__488.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__488.value;
            case 10:
              $__486 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              ret = $__486;
              $ctx.state = 18;
              break;
            case 19:
              $ctx.state = 20;
              return (ret = f(interp, s, param));
            case 20:
              $ctx.maybeThrow();
              $ctx.state = 18;
              break;
            case 26:
              ret = this.visitors["unknown"](interp, s, param);
              $ctx.state = 18;
              break;
            case 18:
              this.currentNode = _node;
              $ctx.state = 32;
              break;
            case 33:
              this.currentNode = s;
              this.rt.raiseException("untyped syntax structure");
              $ctx.state = 32;
              break;
            case 32:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__13, this);
    });
    Interpreter.prototype.run = $traceurRuntime.initGeneratorFunction(function $__16(tree) {
      var $__489,
          $__490,
          $__491,
          $__492,
          $__493;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              this.rt.interp = this;
              $ctx.state = 20;
              break;
            case 20:
              $__489 = this.visit;
              $__490 = $__489.call(this, this, tree);
              $ctx.state = 16;
              break;
            case 16:
              $__492 = $ctx.wrapYieldStar($__490[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__493 = $__492[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__493.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__493.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__493.value;
            case 10:
              $__491 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              $ctx.returnValue = $__491;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__16, this);
    });
    Interpreter.prototype.arrayInit = $traceurRuntime.initGeneratorFunction(function $__43(dimensions, init, level, type, param) {
      var _init,
          arr,
          curDim,
          i,
          initializer,
          initval,
          ret,
          val,
          $__494,
          $__495,
          $__496,
          $__497,
          $__498,
          $__499,
          $__500,
          $__501,
          $__502,
          $__503,
          $__504,
          $__505,
          $__506,
          $__507,
          $__508,
          $__509,
          $__510,
          $__511,
          $__512,
          $__513,
          $__514,
          $__515,
          $__516,
          $__517,
          $__518,
          $__519,
          $__520,
          $__521,
          $__522,
          $__523,
          $__524,
          $__525,
          $__526,
          $__527,
          $__528,
          $__529,
          $__530,
          $__531,
          $__532,
          $__533,
          $__534;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              arr = void 0;
              i = void 0;
              ret = void 0;
              initval = void 0;
              $ctx.state = 163;
              break;
            case 163:
              $ctx.state = (dimensions.length > level) ? 127 : 157;
              break;
            case 127:
              curDim = dimensions[level];
              $ctx.state = 128;
              break;
            case 128:
              $ctx.state = (init) ? 83 : 53;
              break;
            case 83:
              $ctx.state = (init.type === "Initializer_array" && curDim >= init.Initializers.length && (init.Initializers.length === 0 || init.Initializers[0].type === "Initializer_expr")) ? 54 : 82;
              break;
            case 54:
              $ctx.state = (init.Initializers.length === 0) ? 52 : 51;
              break;
            case 52:
              arr = new Array(curDim);
              i = 0;
              while (i < curDim) {
                arr[i] = {
                  type: "Initializer_expr",
                  shorthand: this.rt.defaultValue(type)
                };
                i++;
              }
              init.Initializers = arr;
              $ctx.state = 53;
              break;
            case 51:
              $ctx.state = (init.Initializers.length === 1 && this.rt.isIntegerType(type)) ? 15 : 47;
              break;
            case 15:
              $__494 = this.rt;
              $__495 = $__494.cast;
              $__496 = this.visit;
              $__497 = init.Initializers;
              $__498 = $__497[0];
              $__499 = $__498.Expression;
              $__500 = $__496.call(this, this, $__499, param);
              $ctx.state = 16;
              break;
            case 16:
              $__503 = $ctx.wrapYieldStar($__500[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__504 = $__503[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__504.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__504.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__504.value;
            case 10:
              $__501 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              $__502 = $__495.call($__494, type, $__501);
              val = $__502;
              $ctx.state = 18;
              break;
            case 18:
              if (val.v === -1 || val.v === 0) {
                arr = new Array(curDim);
                i = 0;
                while (i < curDim) {
                  arr[i] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.val(type, val.v)
                  };
                  i++;
                }
                init.Initializers = arr;
              } else {
                arr = new Array(curDim);
                arr[0] = this.rt.val(type, -1);
                i = 1;
                while (i < curDim) {
                  arr[i] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.defaultValue(type)
                  };
                  i++;
                }
                init.Initializers = arr;
              }
              $ctx.state = 53;
              break;
            case 47:
              arr = new Array(curDim);
              i = 0;
              $ctx.state = 48;
              break;
            case 48:
              $ctx.state = (i < init.Initializers.length) ? 42 : 46;
              break;
            case 42:
              _init = init.Initializers[i];
              $ctx.state = 43;
              break;
            case 43:
              $ctx.state = ("shorthand" in _init) ? 39 : 35;
              break;
            case 39:
              initval = _init;
              $ctx.state = 40;
              break;
            case 35:
              $__505 = this.visit;
              $__506 = _init.Expression;
              $__507 = $__505.call(this, this, $__506, param);
              $ctx.state = 36;
              break;
            case 36:
              $__510 = $ctx.wrapYieldStar($__507[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 32;
              break;
            case 32:
              $__511 = $__510[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 29;
              break;
            case 29:
              $ctx.state = ($__511.done) ? 23 : 22;
              break;
            case 23:
              $ctx.sent = $__511.value;
              $ctx.state = 30;
              break;
            case 22:
              $ctx.state = 32;
              return $__511.value;
            case 30:
              $__508 = $ctx.sentIgnoreThrow;
              $ctx.state = 34;
              break;
            case 34:
              $__509 = {
                type: "Initializer_expr",
                shorthand: $__508
              };
              initval = $__509;
              $ctx.state = 40;
              break;
            case 40:
              arr[i] = initval;
              i++;
              $ctx.state = 48;
              break;
            case 46:
              i = init.Initializers.length;
              while (i < curDim) {
                arr[i] = {
                  type: "Initializer_expr",
                  shorthand: this.rt.defaultValue(type)
                };
                i++;
              }
              init.Initializers = arr;
              $ctx.state = 53;
              break;
            case 82:
              $ctx.state = (init.type === "Initializer_expr") ? 76 : 80;
              break;
            case 76:
              initializer = void 0;
              $ctx.state = 77;
              break;
            case 77:
              $ctx.state = ("shorthand" in init) ? 73 : 69;
              break;
            case 73:
              initializer = init.shorthand;
              $ctx.state = 74;
              break;
            case 69:
              $__512 = this.visit;
              $__513 = $__512.call(this, this, init, param);
              $ctx.state = 70;
              break;
            case 70:
              $__515 = $ctx.wrapYieldStar($__513[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 66;
              break;
            case 66:
              $__516 = $__515[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 63;
              break;
            case 63:
              $ctx.state = ($__516.done) ? 57 : 56;
              break;
            case 57:
              $ctx.sent = $__516.value;
              $ctx.state = 64;
              break;
            case 56:
              $ctx.state = 66;
              return $__516.value;
            case 64:
              $__514 = $ctx.sentIgnoreThrow;
              $ctx.state = 68;
              break;
            case 68:
              initializer = $__514;
              $ctx.state = 74;
              break;
            case 74:
              if (this.rt.isCharType(type) && this.rt.isArrayType(initializer.t) && this.rt.isCharType(initializer.t.eleType)) {
                init = {
                  type: "Initializer_array",
                  Initializers: initializer.v.target.map(function(e) {
                    return {
                      type: "Initializer_expr",
                      shorthand: e
                    };
                  })
                };
              } else {
                this.rt.raiseException("cannot initialize an array to " + this.rt.makeValString(initializer), init);
              }
              $ctx.state = 53;
              break;
            case 80:
              this.rt.raiseException("dimensions do not agree, " + curDim + " != " + init.Initializers.length);
              $ctx.state = 53;
              break;
            case 53:
              arr = [];
              ret = this.rt.val(this.arrayType(dimensions, level, type), this.rt.makeArrayPointerValue(arr, 0), true);
              i = 0;
              $ctx.state = 130;
              break;
            case 130:
              $ctx.state = (i < curDim) ? 121 : 124;
              break;
            case 121:
              $ctx.state = (init && i < init.Initializers.length) ? 99 : 117;
              break;
            case 99:
              $__517 = this.arrayInit;
              $__518 = init.Initializers;
              $__519 = $__518[i];
              $__520 = $__517.call(this, dimensions, $__519, level + 1, type, param);
              $ctx.state = 100;
              break;
            case 100:
              $__522 = $ctx.wrapYieldStar($__520[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 96;
              break;
            case 96:
              $__523 = $__522[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 93;
              break;
            case 93:
              $ctx.state = ($__523.done) ? 87 : 86;
              break;
            case 87:
              $ctx.sent = $__523.value;
              $ctx.state = 94;
              break;
            case 86:
              $ctx.state = 96;
              return $__523.value;
            case 94:
              $__521 = $ctx.sentIgnoreThrow;
              $ctx.state = 98;
              break;
            case 98:
              arr[i] = $__521;
              $ctx.state = 102;
              break;
            case 117:
              $__524 = this.arrayInit;
              $__525 = $__524.call(this, dimensions, null, level + 1, type, param);
              $ctx.state = 118;
              break;
            case 118:
              $__527 = $ctx.wrapYieldStar($__525[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 114;
              break;
            case 114:
              $__528 = $__527[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 111;
              break;
            case 111:
              $ctx.state = ($__528.done) ? 105 : 104;
              break;
            case 105:
              $ctx.sent = $__528.value;
              $ctx.state = 112;
              break;
            case 104:
              $ctx.state = 114;
              return $__528.value;
            case 112:
              $__526 = $ctx.sentIgnoreThrow;
              $ctx.state = 116;
              break;
            case 116:
              arr[i] = $__526;
              $ctx.state = 102;
              break;
            case 102:
              i++;
              $ctx.state = 130;
              break;
            case 124:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            case 157:
              if (init && init.type !== "Initializer_expr") {
                this.rt.raiseException("dimensions do not agree, too few initializers", init);
              }
              $ctx.state = 158;
              break;
            case 158:
              $ctx.state = (init) ? 151 : 152;
              break;
            case 151:
              $ctx.state = ("shorthand" in init) ? 149 : 145;
              break;
            case 149:
              initval = init.shorthand;
              $ctx.state = 150;
              break;
            case 145:
              $__529 = this.visit;
              $__530 = init.Expression;
              $__531 = $__529.call(this, this, $__530, param);
              $ctx.state = 146;
              break;
            case 146:
              $__533 = $ctx.wrapYieldStar($__531[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 142;
              break;
            case 142:
              $__534 = $__533[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 139;
              break;
            case 139:
              $ctx.state = ($__534.done) ? 133 : 132;
              break;
            case 133:
              $ctx.sent = $__534.value;
              $ctx.state = 140;
              break;
            case 132:
              $ctx.state = 142;
              return $__534.value;
            case 140:
              $__532 = $ctx.sentIgnoreThrow;
              $ctx.state = 144;
              break;
            case 144:
              initval = $__532;
              $ctx.state = 150;
              break;
            case 152:
              initval = this.rt.defaultValue(type);
              $ctx.state = 150;
              break;
            case 150:
              ret = this.rt.cast(type, initval);
              ret.left = true;
              $ctx.state = 160;
              break;
            case 160:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__43, this);
    });
    Interpreter.prototype.arrayType = function(dimensions, level, type) {
      if (dimensions.length > level) {
        return this.rt.arrayPointerType(this.arrayType(dimensions, level + 1, type), dimensions[level]);
      } else {
        return type;
      }
    };
    Interpreter.prototype.buildRecursivePointerType = function(pointer, basetype, level) {
      var type;
      if (pointer && pointer.length > level) {
        type = this.rt.normalPointerType(basetype);
        return this.buildRecursivePointerType(pointer, type, level + 1);
      } else {
        return basetype;
      }
    };
    module.exports = Interpreter;
  }, {}],
  25: [function(require, module, exports) {
    (function(process) {
      var CRuntime,
          Debugger,
          Interpreter,
          PEGUtil,
          alias,
          ast,
          headerAlias,
          includes,
          mergeConfig,
          preprocessor,
          realName;
      CRuntime = require("./rt");
      Interpreter = require("./interpreter");
      ast = require("./ast");
      preprocessor = require("./preprocessor");
      Debugger = require("./debugger");
      PEGUtil = require("pegjs-util");
      mergeConfig = function(a, b) {
        var o;
        for (o in b) {
          if (o in a && $traceurRuntime.typeof(b[o]) === "object") {
            mergeConfig(a[o], b[o]);
          } else {
            a[o] = b[o];
          }
        }
      };
      includes = {
        iostream: require("./includes/iostream"),
        cctype: require("./includes/cctype"),
        cstring: require("./includes/cstring"),
        cmath: require("./includes/cmath"),
        cstdio: require("./includes/cstdio"),
        cstdlib: require("./includes/cstdlib"),
        ctime: require("./includes/ctime"),
        iomanip: require("./includes/iomanip"),
        foo: require("./includes/dummy_class_foo"),
        Pololu3pi: require("./includes/Pololu3pi"),
        PololuQTRSensors: require("./includes/PololuQTRSensors"),
        OrangutanMotors2: require("./includes/OrangutanMotors2"),
        OrangutanAnalog2: require("./includes/OrangutanAnalog2"),
        OrangutanLEDs2: require("./includes/OrangutanLEDs2"),
        OrangutanLCD2: require("./includes/OrangutanLCD2"),
        OrangutanPushbuttons2: require("./includes/OrangutanPushbuttons2"),
        OrangutanBuzzer2: require("./includes/OrangutanBuzzer2"),
        pgmspace: require("./includes/pgmspace")
      };
      headerAlias = {
        "ctype.h": "cctype",
        "string.h": "cstring",
        "math.h": "cmath",
        "stdio.h": "cstdio",
        "stdlib.h": "cstdlib",
        "time.h": "ctime",
        "Pololu3pi.h": "Pololu3pi",
        "PololuQTRSensors.h": "PololuQTRSensors",
        "OrangutanMotors.h": "OrangutanMotors2",
        "OrangutanAnalog.h": "OrangutanAnalog2",
        "OrangutanLEDs.h": "OrangutanLEDs2",
        "OrangutanLCD.h": "OrangutanLCD2",
        "OrangutanPushbuttons.h": "OrangutanPushbuttons2",
        "OrangutanBuzzer.h": "OrangutanBuzzer2",
        "avr/pgmspace.h": "pgmspace"
      };
      for (alias in headerAlias) {
        realName = headerAlias[alias];
        includes[alias] = includes[realName];
      }
      module.exports = {
        includes: includes,
        run: function(code, input, config) {
          var _config,
              defGen,
              inputbuffer,
              interpreter,
              mainGen,
              mydebugger,
              result,
              rt,
              self,
              step;
          inputbuffer = input.toString();
          self = this;
          _config = {
            stdio: {
              drain: function() {
                var x;
                x = inputbuffer;
                inputbuffer = null;
                return x;
              },
              write: function(s) {
                process.stdout.write(s);
              }
            },
            includes: self.includes
          };
          mergeConfig(_config, config);
          rt = new CRuntime(_config);
          code = code.toString();
          code = preprocessor.parse(rt, code);
          mydebugger = new Debugger();
          if (_config.debug) {
            mydebugger.src = code;
          }
          result = PEGUtil.parse(ast, code);
          if (result.error != null) {
            throw "ERROR: Parsing Failure:\n" + PEGUtil.errorMessage(result.error, true);
          }
          interpreter = new Interpreter(rt);
          defGen = interpreter.run(result.ast);
          while (true) {
            step = defGen.next();
            if (step.done) {
              break;
            }
          }
          mainGen = rt.getFunc("global", "main", [])(rt, null, []);
          if (_config.debug) {
            mydebugger.start(rt, mainGen);
            return mydebugger;
          } else {
            while (true) {
              step = mainGen.next();
              if (step.done) {
                break;
              }
            }
            return step.value.v;
          }
        }
      };
    }).call(this, require('_process'));
  }, {
    "./ast": 1,
    "./debugger": 2,
    "./includes/OrangutanAnalog2": 4,
    "./includes/OrangutanBuzzer2": 5,
    "./includes/OrangutanLCD2": 6,
    "./includes/OrangutanLEDs2": 7,
    "./includes/OrangutanMotors2": 8,
    "./includes/OrangutanPushbuttons2": 9,
    "./includes/Pololu3pi": 10,
    "./includes/PololuQTRSensors": 11,
    "./includes/cctype": 12,
    "./includes/cmath": 13,
    "./includes/cstdio": 14,
    "./includes/cstdlib": 15,
    "./includes/cstring": 16,
    "./includes/ctime": 17,
    "./includes/dummy_class_foo": 18,
    "./includes/iomanip": 19,
    "./includes/iostream": 20,
    "./includes/pgmspace": 21,
    "./interpreter": 24,
    "./preprocessor": 28,
    "./rt": 29,
    "_process": 42,
    "pegjs-util": 39
  }],
  26: [function(require, module, exports) {
    module.exports = require("./launcher");
  }, {"./launcher": 25}],
  27: [function(require, module, exports) {
    module.exports = (function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            parser = this,
            peg$FAILED = {},
            peg$startRuleFunctions = {TranslationUnit: peg$parseTranslationUnit},
            peg$startRuleFunction = peg$parseTranslationUnit,
            peg$c0 = function(a, b) {
              return addPositionInfo({
                type: 'Code',
                val: a,
                space: b
              });
            },
            peg$c1 = function(a) {
              return addPositionInfo({
                type: 'TranslationUnit',
                lines: a
              });
            },
            peg$c2 = function(a, b) {
              a.space = b;
              return a;
            },
            peg$c3 = function(a) {
              return addPositionInfo({
                type: 'PrepUndef',
                Identifier: a
              });
            },
            peg$c4 = function(a, b) {
              return addPositionInfo({
                type: 'PrepSimpleMacro',
                Identifier: a,
                Replacement: b
              });
            },
            peg$c5 = function(a, b, c) {
              return addPositionInfo({
                type: 'PrepFunctionMacro',
                Identifier: a,
                Args: b,
                Replacement: c
              });
            },
            peg$c6 = function(a) {
              return a;
            },
            peg$c7 = function(a, b) {
              return [a].concat(b);
            },
            peg$c8 = function(a, b, c) {
              return {
                type: 'PrepFunctionMacroCall',
                Identifier: a,
                Args: b,
                space: c
              };
            },
            peg$c9 = function(a) {
              var ret = [];
              var lastString = null;
              for (var i = 0; i < a.length; i++) {
                if (a[i].type === 'Seperator') {
                  if (lastString === null) {
                    lastString = a[i];
                  } else {
                    lastString.val += lastString.space + a[i].val;
                    lastString.space = a[i].space;
                  }
                } else {
                  if (lastString !== null) {
                    ret.push(lastString);
                    lastString = null;
                  }
                  ret.push(a[i]);
                }
              }
              if (lastString !== null)
                ret.push(lastString);
              return ret;
            },
            peg$c10 = function(a) {
              return addPositionInfo({
                type: 'PrepIncludeLib',
                name: a
              });
            },
            peg$c11 = function(a) {
              return addPositionInfo({
                type: 'PrepIncludeLocal',
                name: a
              });
            },
            peg$c12 = /^[\/\\.]/,
            peg$c13 = {
              type: "class",
              value: "[/\\\\.]",
              description: "[/\\\\.]"
            },
            peg$c14 = function(a) {
              return a.join('');
            },
            peg$c15 = function(a) {
              return addPositionInfo({
                type: 'PrepIfdef',
                Identifier: a
              });
            },
            peg$c16 = function(a) {
              return addPositionInfo({
                type: 'PrepIfndef',
                Identifier: a
              });
            },
            peg$c17 = function() {
              return addPositionInfo({type: 'PrepEndif'});
            },
            peg$c18 = function() {
              return addPositionInfo({type: 'PrepElse'});
            },
            peg$c19 = "#",
            peg$c20 = {
              type: "literal",
              value: "#",
              description: "\"#\""
            },
            peg$c21 = "define",
            peg$c22 = {
              type: "literal",
              value: "define",
              description: "\"define\""
            },
            peg$c23 = "undef",
            peg$c24 = {
              type: "literal",
              value: "undef",
              description: "\"undef\""
            },
            peg$c25 = "include",
            peg$c26 = {
              type: "literal",
              value: "include",
              description: "\"include\""
            },
            peg$c27 = "ifdef",
            peg$c28 = {
              type: "literal",
              value: "ifdef",
              description: "\"ifdef\""
            },
            peg$c29 = "ifndef",
            peg$c30 = {
              type: "literal",
              value: "ifndef",
              description: "\"ifndef\""
            },
            peg$c31 = "endif",
            peg$c32 = {
              type: "literal",
              value: "endif",
              description: "\"endif\""
            },
            peg$c33 = "else",
            peg$c34 = {
              type: "literal",
              value: "else",
              description: "\"else\""
            },
            peg$c35 = function(a) {
              return a.join('');
            },
            peg$c36 = /^[ \t\x0B\f]/,
            peg$c37 = {
              type: "class",
              value: "[ \\t\\u000B\\u000C]",
              description: "[ \\t\\u000B\\u000C]"
            },
            peg$c38 = /^[ \n\r\t\x0B\f]/,
            peg$c39 = {
              type: "class",
              value: "[ \\n\\r\\t\\u000B\\u000C]",
              description: "[ \\n\\r\\t\\u000B\\u000C]"
            },
            peg$c40 = "/*",
            peg$c41 = {
              type: "literal",
              value: "/*",
              description: "\"/*\""
            },
            peg$c42 = "*/",
            peg$c43 = {
              type: "literal",
              value: "*/",
              description: "\"*/\""
            },
            peg$c44 = function(a) {
              return '';
            },
            peg$c45 = "//",
            peg$c46 = {
              type: "literal",
              value: "//",
              description: "\"//\""
            },
            peg$c47 = "\n",
            peg$c48 = {
              type: "literal",
              value: "\n",
              description: "\"\\n\""
            },
            peg$c49 = "auto",
            peg$c50 = {
              type: "literal",
              value: "auto",
              description: "\"auto\""
            },
            peg$c51 = "break",
            peg$c52 = {
              type: "literal",
              value: "break",
              description: "\"break\""
            },
            peg$c53 = "case",
            peg$c54 = {
              type: "literal",
              value: "case",
              description: "\"case\""
            },
            peg$c55 = "char",
            peg$c56 = {
              type: "literal",
              value: "char",
              description: "\"char\""
            },
            peg$c57 = "const",
            peg$c58 = {
              type: "literal",
              value: "const",
              description: "\"const\""
            },
            peg$c59 = "continue",
            peg$c60 = {
              type: "literal",
              value: "continue",
              description: "\"continue\""
            },
            peg$c61 = "default",
            peg$c62 = {
              type: "literal",
              value: "default",
              description: "\"default\""
            },
            peg$c63 = "double",
            peg$c64 = {
              type: "literal",
              value: "double",
              description: "\"double\""
            },
            peg$c65 = "do",
            peg$c66 = {
              type: "literal",
              value: "do",
              description: "\"do\""
            },
            peg$c67 = "enum",
            peg$c68 = {
              type: "literal",
              value: "enum",
              description: "\"enum\""
            },
            peg$c69 = "extern",
            peg$c70 = {
              type: "literal",
              value: "extern",
              description: "\"extern\""
            },
            peg$c71 = "float",
            peg$c72 = {
              type: "literal",
              value: "float",
              description: "\"float\""
            },
            peg$c73 = "for",
            peg$c74 = {
              type: "literal",
              value: "for",
              description: "\"for\""
            },
            peg$c75 = "goto",
            peg$c76 = {
              type: "literal",
              value: "goto",
              description: "\"goto\""
            },
            peg$c77 = "if",
            peg$c78 = {
              type: "literal",
              value: "if",
              description: "\"if\""
            },
            peg$c79 = "int",
            peg$c80 = {
              type: "literal",
              value: "int",
              description: "\"int\""
            },
            peg$c81 = "inline",
            peg$c82 = {
              type: "literal",
              value: "inline",
              description: "\"inline\""
            },
            peg$c83 = "long",
            peg$c84 = {
              type: "literal",
              value: "long",
              description: "\"long\""
            },
            peg$c85 = "register",
            peg$c86 = {
              type: "literal",
              value: "register",
              description: "\"register\""
            },
            peg$c87 = "restrict",
            peg$c88 = {
              type: "literal",
              value: "restrict",
              description: "\"restrict\""
            },
            peg$c89 = "return",
            peg$c90 = {
              type: "literal",
              value: "return",
              description: "\"return\""
            },
            peg$c91 = "short",
            peg$c92 = {
              type: "literal",
              value: "short",
              description: "\"short\""
            },
            peg$c93 = "signed",
            peg$c94 = {
              type: "literal",
              value: "signed",
              description: "\"signed\""
            },
            peg$c95 = "sizeof",
            peg$c96 = {
              type: "literal",
              value: "sizeof",
              description: "\"sizeof\""
            },
            peg$c97 = "static",
            peg$c98 = {
              type: "literal",
              value: "static",
              description: "\"static\""
            },
            peg$c99 = "struct",
            peg$c100 = {
              type: "literal",
              value: "struct",
              description: "\"struct\""
            },
            peg$c101 = "switch",
            peg$c102 = {
              type: "literal",
              value: "switch",
              description: "\"switch\""
            },
            peg$c103 = "typedef",
            peg$c104 = {
              type: "literal",
              value: "typedef",
              description: "\"typedef\""
            },
            peg$c105 = "union",
            peg$c106 = {
              type: "literal",
              value: "union",
              description: "\"union\""
            },
            peg$c107 = "unsigned",
            peg$c108 = {
              type: "literal",
              value: "unsigned",
              description: "\"unsigned\""
            },
            peg$c109 = "void",
            peg$c110 = {
              type: "literal",
              value: "void",
              description: "\"void\""
            },
            peg$c111 = "volatile",
            peg$c112 = {
              type: "literal",
              value: "volatile",
              description: "\"volatile\""
            },
            peg$c113 = "while",
            peg$c114 = {
              type: "literal",
              value: "while",
              description: "\"while\""
            },
            peg$c115 = "_Bool",
            peg$c116 = {
              type: "literal",
              value: "_Bool",
              description: "\"_Bool\""
            },
            peg$c117 = "_Complex",
            peg$c118 = {
              type: "literal",
              value: "_Complex",
              description: "\"_Complex\""
            },
            peg$c119 = "_stdcall",
            peg$c120 = {
              type: "literal",
              value: "_stdcall",
              description: "\"_stdcall\""
            },
            peg$c121 = "__declspec",
            peg$c122 = {
              type: "literal",
              value: "__declspec",
              description: "\"__declspec\""
            },
            peg$c123 = "__attribute__",
            peg$c124 = {
              type: "literal",
              value: "__attribute__",
              description: "\"__attribute__\""
            },
            peg$c125 = "_Imaginary",
            peg$c126 = {
              type: "literal",
              value: "_Imaginary",
              description: "\"_Imaginary\""
            },
            peg$c127 = function(a, b, c) {
              return {
                type: 'Identifier',
                val: a + b.join(''),
                space: c
              };
            },
            peg$c128 = /^[\r\n,)]/,
            peg$c129 = {
              type: "class",
              value: "[\\r\\n,)]",
              description: "[\\r\\n,)]"
            },
            peg$c130 = function(a, b) {
              return {
                type: 'Seperator',
                val: a,
                space: b
              };
            },
            peg$c131 = /^[\r\n]/,
            peg$c132 = {
              type: "class",
              value: "[\\r\\n]",
              description: "[\\r\\n]"
            },
            peg$c133 = /^[a-z]/,
            peg$c134 = {
              type: "class",
              value: "[a-z]",
              description: "[a-z]"
            },
            peg$c135 = /^[A-Z]/,
            peg$c136 = {
              type: "class",
              value: "[A-Z]",
              description: "[A-Z]"
            },
            peg$c137 = /^[_]/,
            peg$c138 = {
              type: "class",
              value: "[_]",
              description: "[_]"
            },
            peg$c139 = /^[0-9]/,
            peg$c140 = {
              type: "class",
              value: "[0-9]",
              description: "[0-9]"
            },
            peg$c141 = "\\u",
            peg$c142 = {
              type: "literal",
              value: "\\u",
              description: "\"\\\\u\""
            },
            peg$c143 = function(a) {
              return String.fromCharCode(a);
            },
            peg$c144 = "\\U",
            peg$c145 = {
              type: "literal",
              value: "\\U",
              description: "\"\\\\U\""
            },
            peg$c146 = function(a) {
              return parseInt(a.join(''), 16);
            },
            peg$c147 = /^[a-f]/,
            peg$c148 = {
              type: "class",
              value: "[a-f]",
              description: "[a-f]"
            },
            peg$c149 = /^[A-F]/,
            peg$c150 = {
              type: "class",
              value: "[A-F]",
              description: "[A-F]"
            },
            peg$c151 = "(",
            peg$c152 = {
              type: "literal",
              value: "(",
              description: "\"(\""
            },
            peg$c153 = ")",
            peg$c154 = {
              type: "literal",
              value: ")",
              description: "\")\""
            },
            peg$c155 = ",",
            peg$c156 = {
              type: "literal",
              value: ",",
              description: "\",\""
            },
            peg$c157 = "<",
            peg$c158 = {
              type: "literal",
              value: "<",
              description: "\"<\""
            },
            peg$c159 = /^[=]/,
            peg$c160 = {
              type: "class",
              value: "[=]",
              description: "[=]"
            },
            peg$c161 = ">",
            peg$c162 = {
              type: "literal",
              value: ">",
              description: "\">\""
            },
            peg$c163 = "\"",
            peg$c164 = {
              type: "literal",
              value: "\"",
              description: "\"\\\"\""
            },
            peg$c165 = {
              type: "any",
              description: "any character"
            },
            peg$currPos = 0,
            peg$savedPos = 0,
            peg$posDetailsCache = [{
              line: 1,
              column: 1,
              seenCR: false
            }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{
            type: "other",
            description: description
          }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p,
              ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildException(message, expected, found, location) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length),
                expectedDesc,
                foundDesc,
                i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
        }
        function peg$parseTranslationUnit() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsePreprocessor();
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parsePrepMacroText();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSpacing();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c0(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsePreprocessor();
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePrepMacroText();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseSpacing();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c0(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePreprocessor() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePrepDefine();
          if (s1 === peg$FAILED) {
            s1 = peg$parsePrepInclude();
            if (s1 === peg$FAILED) {
              s1 = peg$parseConditionalInclusion();
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c2(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepDefine() {
          var s0;
          s0 = peg$parsePrepFunctionMacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepSimpleMacro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepUndef();
            }
          }
          return s0;
        }
        function peg$parsePrepUndef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseUNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c3(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepSimpleMacro() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepMacroText();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c4(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacro() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsePrepMacroText();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s3, s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseIdentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseIdentifier();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroCallArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsePrepMacroMacroCallText();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsePrepMacroMacroCallText();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsePrepMacroMacroCallText();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepMacroMacroCallText() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperatorArgs();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperatorArgs();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepMacroText() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperator();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperator();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepInclude() {
          var s0;
          s0 = peg$parsePrepIncludeLib();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIncludeLocal();
          }
          return s0;
        }
        function peg$parsePrepIncludeLib() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLT();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseGT();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIncludeLocal() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseQUO();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseQUO();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFilename() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIdChar();
          if (s2 === peg$FAILED) {
            if (peg$c12.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIdChar();
              if (s2 === peg$FAILED) {
                if (peg$c12.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseConditionalInclusion() {
          var s0;
          s0 = peg$parsePrepIfdef();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIfndef();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepEndif();
              if (s0 === peg$FAILED) {
                s0 = peg$parsePrepElse();
              }
            }
          }
          return s0;
        }
        function peg$parsePrepIfdef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIfndef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepEndif() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseENDIF();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepElse() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseELSE();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c18();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHARP() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c19;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFINE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c21) {
            s1 = peg$c21;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c22);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINCLUDE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c25) {
            s1 = peg$c25;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFNDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENDIF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c31) {
            s1 = peg$c31;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInlineSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseInlineWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseInlineWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseInlineWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c40) {
            s1 = peg$c40;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c41);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c42) {
              s5 = peg$c42;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s5 = peg$c42;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s3 = peg$c42;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c44(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c45) {
            s1 = peg$c45;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c47;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c47;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c53) {
            s1 = peg$c53;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c55) {
            s1 = peg$c55;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c57) {
            s1 = peg$c57;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c59) {
            s1 = peg$c59;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c60);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c63) {
            s1 = peg$c63;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c65) {
            s1 = peg$c65;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c67) {
            s1 = peg$c67;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c70);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c71) {
            s1 = peg$c71;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c75) {
            s1 = peg$c75;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c79) {
            s1 = peg$c79;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c80);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c53) {
                s1 = peg$c53;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c54);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c55) {
                  s1 = peg$c55;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c56);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c57) {
                    s1 = peg$c57;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c58);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c59) {
                      s1 = peg$c59;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c60);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c61) {
                        s1 = peg$c61;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c62);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c63) {
                          s1 = peg$c63;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c65) {
                            s1 = peg$c65;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c66);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c33) {
                              s1 = peg$c33;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c34);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c67) {
                                s1 = peg$c67;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c68);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c69) {
                                  s1 = peg$c69;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c70);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c71) {
                                    s1 = peg$c71;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c72);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c73) {
                                      s1 = peg$c73;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c74);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c75) {
                                        s1 = peg$c75;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c76);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c77) {
                                          s1 = peg$c77;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c78);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c79) {
                                            s1 = peg$c79;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c80);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c81) {
                                              s1 = peg$c81;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c82);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c83) {
                                                s1 = peg$c83;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c84);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c85) {
                                                  s1 = peg$c85;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c86);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c87) {
                                                    s1 = peg$c87;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c88);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c89) {
                                                      s1 = peg$c89;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c90);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c91) {
                                                        s1 = peg$c91;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c92);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c93) {
                                                          s1 = peg$c93;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c94);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c95) {
                                                            s1 = peg$c95;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c96);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c97) {
                                                              s1 = peg$c97;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c98);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c99) {
                                                                s1 = peg$c99;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c100);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c101) {
                                                                  s1 = peg$c101;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c102);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c103) {
                                                                    s1 = peg$c103;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c104);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c105) {
                                                                      s1 = peg$c105;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c106);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c107) {
                                                                        s1 = peg$c107;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c108);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c109) {
                                                                          s1 = peg$c109;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c110);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c111) {
                                                                            s1 = peg$c111;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c112);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c113) {
                                                                              s1 = peg$c113;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c114);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c115) {
                                                                                s1 = peg$c115;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c116);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c117) {
                                                                                  s1 = peg$c117;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c118);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c125) {
                                                                                    s1 = peg$c125;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c126);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c119) {
                                                                                      s1 = peg$c119;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c120);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c121) {
                                                                                        s1 = peg$c121;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c122);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c123) {
                                                                                          s1 = peg$c123;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c124);
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseInlineSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c127(s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperatorArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdNondigit();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$c128.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c129);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c6(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdNondigit();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$c131.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c132);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c6(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c133.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c135.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c136);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c137.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c138);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c133.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c135.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c136);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c139.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c140);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c137.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c138);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c141) {
            s1 = peg$c141;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c142);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c143(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c144) {
              s1 = peg$c144;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c145);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexOcto();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c143(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexOcto() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8,
              s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHexDigit();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHexDigit();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHexDigit();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHexDigit();
                        if (s9 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c146(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexQuad() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c146(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c147.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c148);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c149.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c150);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c139.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c140);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c151;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c152);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c153;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c154);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c155;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c156);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c157;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c159.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c160);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c161;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c162);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c159.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c160);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUO() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c163;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0,
              s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c165);
            }
          }
          return s0;
        }
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.eLine = posDetails.line;
          r.eColumn = posDetails.column;
          r.eOffset = peg$currPos;
          posDetails = peg$computePosDetails(peg$savedPos);
          r.sLine = posDetails.line;
          r.sColumn = posDetails.column;
          r.sOffset = peg$savedPos;
          return r;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    })();
  }, {}],
  28: [function(require, module, exports) {
    var PEGUtil,
        Preprocessor,
        prepast;
    prepast = require("./prepast");
    PEGUtil = require("pegjs-util");
    Preprocessor = function(rt) {
      var pushInc,
          self;
      pushInc = function(b) {
        self.doinclude.push(self.doinclude[self.doinclude.length - 1] && b);
      };
      this.rt = rt;
      this.ret = "";
      this.macros = {};
      this.macroStack = [];
      this.doinclude = [true];
      self = this;
      this.visitors = {
        TranslationUnit: function(interp, s, code) {
          var dec,
              i;
          i = 0;
          while (i < s.lines.length) {
            dec = s.lines[i];
            interp.visit(dec, code);
            interp.ret += dec.space;
            i++;
          }
          return interp.ret;
        },
        Code: function(interp, s, code) {
          var i,
              x;
          if (interp.doinclude[interp.doinclude.length - 1]) {
            i = 0;
            while (i < s.val.length) {
              x = interp.work(s.val[i]);
              interp.ret += x;
              i++;
            }
          }
        },
        PrepSimpleMacro: function(interp, s, code) {
          interp.newMacro(s.Identifier, s.Replacement);
        },
        PrepFunctionMacro: function(interp, s, code) {
          interp.newMacroFunction(s.Identifier, s.Args, s.Replacement);
        },
        PrepIncludeLib: function(interp, s, code) {
          interp.rt.include(s.name);
        },
        PrepIncludeLocal: function(interp, s, code) {
          var includes;
          includes = interp.rt.config.includes;
          if (s.name in includes) {
            includes[s.name].load(interp.rt);
          } else {
            interp.rt.raiseException("cannot find file: " + s.name);
          }
        },
        PrepUndef: function(interp, s, code) {
          if (interp.isMacroDefined(s.Identifier)) {
            delete interp.macros[s.Identifier.val];
          }
        },
        PrepIfdef: function(interp, s, code) {
          pushInc(interp.isMacroDefined(s.Identifier));
        },
        PrepIfndef: function(interp, s, code) {
          pushInc(!interp.isMacroDefined(s.Identifier));
        },
        PrepElse: function(interp, s, code) {
          var x;
          if (interp.doinclude.length > 1) {
            x = interp.doinclude.pop();
            pushInc(!x);
          } else {
            interp.rt.raiseException("#else must be used after a #if");
          }
        },
        PrepEndif: function(interp, s, code) {
          if (interp.doinclude.length > 1) {
            interp.doinclude.pop();
          } else {
            interp.rt.raiseException("#endif must be used after a #if");
          }
        },
        unknown: function(interp, s, code) {
          interp.rt.raiseException("unhandled syntax " + s.type);
        }
      };
    };
    Preprocessor.prototype.visit = function(s, code) {
      var _node;
      if ("type" in s) {
        _node = this.currentNode;
        this.currentNode = s;
        if (s.type in this.visitors) {
          return this.visitors[s.type](this, s, code);
        } else {
          return this.visitors["unknown"](this, s, code);
        }
        this.currentNode = _node;
      } else {
        this.currentNode = s;
        this.rt.raiseException("untyped syntax structure: " + JSON.stringify(s));
      }
    };
    Preprocessor.prototype.isMacroDefined = function(node) {
      if (node.type === "Identifier") {
        return node.val in this.macros;
      } else {
        return node.Identifier.val in this.macros;
      }
    };
    Preprocessor.prototype.isMacro = function(node) {
      return this.isMacroDefined(node) && "val" in node && this.macros[node.val].type === "simple";
    };
    Preprocessor.prototype.isMacroFunction = function(node) {
      return this.isMacroDefined(node) && "Identifier" in node && this.macros[node.Identifier.val].type === "function";
    };
    Preprocessor.prototype.newMacro = function(id, replacement) {
      if (this.isMacroDefined(id)) {
        this.rt.raiseException("macro " + id.val + " is already defined");
      }
      this.macros[id.val] = {
        type: "simple",
        replacement: replacement
      };
    };
    Preprocessor.prototype.newMacroFunction = function(id, args, replacement) {
      if (this.isMacroDefined(id)) {
        this.rt.raiseException("macro " + id.val + " is already defined");
      }
      this.macros[id.val] = {
        type: "function",
        args: args,
        replacement: replacement
      };
    };
    Preprocessor.prototype.work = function(node) {
      if (node.type === "Seperator") {
        return node.val + node.space;
      } else {
        if (node in this.macroStack) {
          this.rt.raiseException("recursive macro detected");
        }
        this.macroStack.push(node);
        if (node.type === "Identifier") {
          return this.replaceMacro(node) + node.space;
        } else if (node.type === "PrepFunctionMacroCall") {
          return this.replaceMacroFunction(node);
        }
        this.macroStack.pop();
      }
    };
    Preprocessor.prototype.replaceMacro = function(id) {
      var i,
          rep,
          ret,
          v;
      if (this.isMacro(id)) {
        ret = "";
        rep = this.macros[id.val].replacement;
        i = 0;
        while (i < rep.length) {
          v = this.work(rep[i]);
          ret += v;
          i++;
        }
        return ret;
      } else {
        return id.val;
      }
    };
    Preprocessor.prototype.replaceMacroFunction = function(node) {
      var argi,
          args,
          argsText,
          i,
          j,
          name,
          rep,
          ret,
          v,
          x;
      if (this.isMacroFunction(node)) {
        name = node.Identifier.val;
        argsText = node.Args;
        rep = this.macros[name].replacement;
        args = this.macros[name].args;
        if (args.length === argsText.length) {
          ret = "";
          i = 0;
          while (i < rep.length) {
            if (rep[i].type === "Seperator") {
              v = this.work(rep[i]);
              ret += v;
            } else {
              argi = -1;
              j = 0;
              while (j < args.length) {
                if (rep[i].type === "Identifier" && args[j].val === rep[i].val) {
                  argi = j;
                  break;
                }
                j++;
              }
              if (argi >= 0) {
                v = "";
                j = 0;
                while (j < argsText[argi].length) {
                  v += this.work(argsText[argi][j]);
                  j++;
                }
                ret += v + rep[i].space;
              } else {
                v = this.work(rep[i]);
                ret += v;
              }
            }
            i++;
          }
          return ret;
        } else {
          this.rt.raiseException("macro " + name + " requires " + args.length + " arguments (" + argsText.length + " given)");
        }
      } else {
        argsText = node.Args;
        v = [];
        i = 0;
        while (i < argsText.length) {
          x = "";
          j = 0;
          while (j < argsText[i].length) {
            x += this.work(argsText[i][j]);
            j++;
          }
          v.push(x);
          i++;
        }
        return node.Identifier.val + "(" + v.join(",") + ")" + node.space;
      }
    };
    Preprocessor.prototype.parse = function(code) {
      var result;
      result = PEGUtil.parse(prepast, code);
      if (result.error != null) {
        throw "ERROR: Preprocessing Failure:\n" + PEGUtil.errorMessage(result.error, true);
      }
      this.rt.interp = this;
      return this.visit(result.ast, code);
    };
    module.exports = {parse: function(rt, code) {
        return new Preprocessor(rt).parse(code);
      }};
  }, {
    "./prepast": 27,
    "pegjs-util": 39
  }],
  29: [function(require, module, exports) {
    var CRuntime,
        Defaults,
        indexOf = [].indexOf;
    Defaults = require("./defaults");
    CRuntime = function(config) {
      var defaults,
          mergeConfig;
      mergeConfig = function(a, b) {
        var o;
        for (o in b) {
          if (o in a && $traceurRuntime.typeof(b[o]) === "object") {
            mergeConfig(a[o], b[o]);
          } else {
            a[o] = b[o];
          }
        }
      };
      defaults = new Defaults();
      this.config = defaults.config;
      mergeConfig(this.config, config);
      this.numericTypeOrder = defaults.numericTypeOrder;
      this.types = defaults.types;
      this.intTypeLiteral = this.primitiveType("int");
      this.unsignedintTypeLiteral = this.primitiveType("unsigned int");
      this.longTypeLiteral = this.primitiveType("long");
      this.floatTypeLiteral = this.primitiveType("float");
      this.doubleTypeLiteral = this.primitiveType("double");
      this.charTypeLiteral = this.primitiveType("char");
      this.unsignedcharTypeLiteral = this.primitiveType("unsigned char");
      this.boolTypeLiteral = this.primitiveType("bool");
      this.voidTypeLiteral = this.primitiveType("void");
      this.nullPointerValue = this.makeNormalPointerValue(null);
      this.voidPointerType = this.normalPointerType(this.voidTypeLiteral);
      this.nullPointer = this.val(this.voidPointerType, this.nullPointerValue);
      this.scope = [{"$name": "global"}];
      this.typedefs = {};
      return this;
    };
    CRuntime.prototype.include = function(name) {
      var includes,
          lib;
      includes = this.config.includes;
      if (name in includes) {
        lib = includes[name];
        if (indexOf.call(this.config.loadedLibraries, name) >= 0) {
          return;
        }
        this.config.loadedLibraries.push(name);
        includes[name].load(this);
      } else {
        this.raiseException("cannot find library: " + name);
      }
    };
    CRuntime.prototype.getSize = function(element) {
      var i,
          ret;
      ret = 0;
      if (this.isArrayType(element.t) && element.v.position === 0) {
        i = 0;
        while (i < element.v.target.length) {
          ret += this.getSize(element.v.target[i]);
          i++;
        }
      } else {
        ret += this.getSizeByType(element.t);
      }
      return ret;
    };
    CRuntime.prototype.getSizeByType = function(type) {
      if (this.isPointerType(type)) {
        return this.config.limits["pointer"].bytes;
      } else if (this.isPrimitiveType(type)) {
        return this.config.limits[type.name].bytes;
      } else {
        this.raiseException("not implemented");
      }
    };
    CRuntime.prototype.getMember = function(l, r) {
      var lt,
          ltsig,
          t;
      lt = l.t;
      if (this.isClassType(lt)) {
        ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          t = this.types[ltsig];
          if (r in t) {
            return {
              t: {type: "function"},
              v: {
                defineType: lt,
                name: r,
                bindThis: l
              }
            };
          } else if (r in l.v.members) {
            return l.v.members[r];
          }
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
        }
      } else {
        this.raiseException("only a class can have members");
      }
    };
    CRuntime.prototype.defFunc = function(lt, name, retType, argTypes, argNames, stmts, interp, optionalArgs) {
      var f,
          rt;
      rt = this;
      if (stmts != null) {
        f = $traceurRuntime.initGeneratorFunction(function $__11(rt, _this) {
          var args,
              $__3,
              argValue,
              i,
              j,
              optionalArg,
              ref,
              ret,
              $__535,
              $__536,
              $__537,
              $__538,
              $__539,
              $__540,
              $__541,
              $__542,
              $__543,
              $__544,
              $__545;
          var $arguments = arguments;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  for (args = [], $__3 = 2; $__3 < $arguments.length; $__3++)
                    args[$__3 - 2] = $arguments[$__3];
                  rt.enterScope("function " + name);
                  argNames.forEach(function(argName, i) {
                    rt.defVar(argName, argTypes[i], args[i]);
                  });
                  $ctx.state = 50;
                  break;
                case 50:
                  i = j = 0, ref = optionalArgs.length;
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = (j < ref) ? 24 : 26;
                  break;
                case 22:
                  i = j += 1;
                  $ctx.state = 28;
                  break;
                case 24:
                  optionalArg = optionalArgs[i];
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = (args[argNames.length + i] != null) ? 21 : 15;
                  break;
                case 21:
                  rt.defVar(optionalArg.name, optionalArg.type, args[argNames.length + i]);
                  $ctx.state = 22;
                  break;
                case 15:
                  $__535 = interp.visit;
                  $__536 = optionalArg.expression;
                  $__537 = $__535.call(interp, interp, $__536);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__539 = $ctx.wrapYieldStar($__537[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__540 = $__539[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__540.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__540.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__540.value;
                case 10:
                  $__538 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  argValue = $__538;
                  $ctx.state = 18;
                  break;
                case 18:
                  rt.defVar(optionalArg.name, optionalArg.type, rt.cast(optionalArg.type, argValue));
                  $ctx.state = 22;
                  break;
                case 26:
                  $__541 = interp.run;
                  $__542 = $__541.call(interp, stmts, {scope: "function"});
                  $ctx.state = 44;
                  break;
                case 44:
                  $__544 = $ctx.wrapYieldStar($__542[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 40;
                  break;
                case 40:
                  $__545 = $__544[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 37;
                  break;
                case 37:
                  $ctx.state = ($__545.done) ? 31 : 30;
                  break;
                case 31:
                  $ctx.sent = $__545.value;
                  $ctx.state = 38;
                  break;
                case 30:
                  $ctx.state = 40;
                  return $__545.value;
                case 38:
                  $__543 = $ctx.sentIgnoreThrow;
                  $ctx.state = 42;
                  break;
                case 42:
                  ret = $__543;
                  $ctx.state = 46;
                  break;
                case 46:
                  if (!rt.isTypeEqualTo(retType, rt.voidTypeLiteral)) {
                    if (ret instanceof Array && ret[0] === "return") {
                      ret = rt.cast(retType, ret[1]);
                    } else {
                      rt.raiseException("you must return a value");
                    }
                  } else {
                    if (typeof ret === "Array") {
                      if (ret[0] === "return" && ret[1]) {
                        rt.raiseException("you cannot return a value from a void function");
                      }
                    }
                    ret = void 0;
                  }
                  rt.exitScope("function " + name);
                  $ctx.state = 52;
                  break;
                case 52:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__11, this);
        });
        this.regFunc(f, lt, name, argTypes, retType, optionalArgs);
      } else {
        this.regFuncPrototype(lt, name, argTypes, retType, optionalArgs);
      }
    };
    CRuntime.prototype.makeParametersSignature = function(args) {
      var i,
          ret;
      ret = new Array(args.length);
      i = 0;
      while (i < args.length) {
        ret[i] = this.getTypeSignature(args[i]);
        i++;
      }
      return ret.join(",");
    };
    CRuntime.prototype.getCompatibleFunc = function(lt, name, args) {
      var $__2 = this;
      var argsStr,
          compatibles,
          ltsig,
          reg,
          ret,
          sig,
          t,
          ts;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (name in t) {
          ts = args.map(function(v) {
            return v.t;
          });
          sig = this.makeParametersSignature(ts);
          if (sig in t[name]) {
            ret = t[name][sig];
          } else {
            compatibles = [];
            reg = t[name]["reg"];
            Object.keys(reg).forEach(function(signature) {
              var dts,
                  i,
                  newTs,
                  ok,
                  optionalArgs,
                  regArgInfo;
              regArgInfo = reg[signature];
              dts = regArgInfo.args;
              optionalArgs = regArgInfo.optionalArgs;
              if (dts[dts.length - 1] === "?" && dts.length - 1 <= ts.length) {
                newTs = ts.slice(0, dts.length - 1);
                dts = dts.slice(0, -1);
              } else {
                newTs = ts;
              }
              if (dts.length <= newTs.length) {
                ok = true;
                i = 0;
                while (ok && i < dts.length) {
                  ok = $__2.castable(newTs[i], dts[i]);
                  i++;
                }
                while (ok && i < newTs.length) {
                  ok = $__2.castable(newTs[i], optionalArgs[i - dts.length].type);
                  i++;
                }
                if (ok) {
                  compatibles.push(t[name][$__2.makeParametersSignature(regArgInfo.args)]);
                }
              }
            });
            if (compatibles.length === 0) {
              if ("#default" in t[name]) {
                ret = t[name]["#default"];
              } else {
                argsStr = ts.map(function(v) {
                  return $__2.makeTypeString(v);
                }).join(",");
                this.raiseException("no method " + name + " in " + lt + " accepts " + argsStr);
              }
            } else if (compatibles.length > 1) {
              this.raiseException("ambiguous method invoking, " + compatibles.length + " compatible methods");
            } else {
              ret = compatibles[0];
            }
          }
        } else {
          this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
        }
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
      if (ret == null) {
        this.raiseException("method " + name + " does not seem to be implemented");
      }
      return ret;
    };
    CRuntime.prototype.matchVarArg = function(methods, sig) {
      var _sig;
      for (_sig in methods) {
        if (_sig[_sig.length - 1] === "?") {
          _sig = _sig.slice(0, -1);
          if (sig.startsWith(_sig)) {
            return methods[_sig];
          }
        }
      }
      return null;
    };
    CRuntime.prototype.getFunc = function(lt, name, args) {
      var f,
          ltsig,
          method,
          sig,
          t;
      method = void 0;
      if (this.isPointerType(lt) || this.isFunctionType(lt)) {
        f = void 0;
        if (this.isArrayType(lt)) {
          f = "pointer_array";
        } else if (this.isFunctionType(lt)) {
          f = "function";
        } else {
          f = "pointer_normal";
        }
        t = null;
        if (name in this.types[f]) {
          t = this.types[f];
        } else if (name in this.types["pointer"]) {
          t = this.types["pointer"];
        }
        if (t) {
          sig = this.makeParametersSignature(args);
          if (sig in t[name]) {
            return t[name][sig];
          } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
            return method;
          } else if ("#default" in t[name]) {
            return t[name]["#default"];
          } else {
            this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
          }
        }
      }
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (name in t) {
          sig = this.makeParametersSignature(args);
          if (sig in t[name]) {
            return t[name][sig];
          } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
            return method;
          } else if ("#default" in t[name]) {
            return t[name]["#default"];
          } else {
            this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
          }
        } else {
          this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
        }
      } else {
        if (this.isPointerType(lt)) {
          this.raiseException("this pointer has no proper method overload");
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is not defined");
        }
      }
    };
    CRuntime.prototype.makeOperatorFuncName = function(name) {
      return ("o(" + name + ")");
    };
    CRuntime.prototype.regOperator = function(f, lt, name, args, retType) {
      return this.regFunc(f, lt, this.makeOperatorFuncName(name), args, retType);
    };
    CRuntime.prototype.regFuncPrototype = function(lt, name, args, retType, optionalArgs) {
      var base,
          ltsig,
          sig,
          t,
          type;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (!(name in t)) {
          t[name] = {};
        }
        if (!("reg" in t[name])) {
          t[name]["reg"] = {};
        }
        sig = this.makeParametersSignature(args);
        if (sig in t[name]) {
          this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
        }
        type = this.functionType(retType, args);
        if (lt === "global") {
          this.defVar(name, type, this.val(type, this.makeFunctionPointerValue(null, name, lt, args, retType)));
        }
        t[name][sig] = null;
        if ((base = t[name]["reg"])[sig] == null) {
          base[sig] = {
            args: args,
            optionalArgs: optionalArgs
          };
        }
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
    };
    CRuntime.prototype.regFunc = function(f, lt, name, args, retType, optionalArgs) {
      var func,
          ltsig,
          sig,
          t,
          type;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        optionalArgs || (optionalArgs = []);
        t = this.types[ltsig];
        if (!(name in t)) {
          t[name] = {};
        }
        if (!("reg" in t[name])) {
          t[name]["reg"] = {};
        }
        sig = this.makeParametersSignature(args);
        if (sig in t[name] && (t[name][sig] != null)) {
          this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
        }
        type = this.functionType(retType, args);
        if (lt === "global") {
          if (this.varAlreadyDefined(name)) {
            func = this.scope[0][name];
            if (func.v.target !== null) {
              this.raiseException("global method " + name + " with parameters (" + sig + ") is already defined");
            } else {
              func.v.target = f;
            }
          } else {
            this.defVar(name, type, this.val(type, this.makeFunctionPointerValue(f, name, lt, args, retType)));
          }
        }
        t[name][sig] = f;
        t[name]["reg"][sig] = {
          args: args,
          optionalArgs: optionalArgs
        };
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
    };
    CRuntime.prototype.registerTypedef = function(basttype, name) {
      return this.typedefs[name] = basttype;
    };
    CRuntime.prototype.promoteNumeric = function(l, r) {
      var rett,
          slt,
          slti,
          srt,
          srti;
      if (!this.isNumericType(l) || !this.isNumericType(r)) {
        this.raiseException("you cannot promote (to) a non numeric type");
      }
      if (this.isTypeEqualTo(l, r)) {
        if (this.isTypeEqualTo(l, this.boolTypeLiteral)) {
          return this.intTypeLiteral;
        }
        if (this.isTypeEqualTo(l, this.charTypeLiteral)) {
          return this.intTypeLiteral;
        }
        if (this.isTypeEqualTo(l, this.unsignedcharTypeLiteral)) {
          return this.unsignedintTypeLiteral;
        }
        return l;
      } else if (this.isIntegerType(l) && this.isIntegerType(r)) {
        slt = this.getSignedType(l);
        srt = this.getSignedType(r);
        if (this.isTypeEqualTo(slt, srt)) {
          rett = slt;
        } else {
          slti = this.numericTypeOrder.indexOf(slt.name);
          srti = this.numericTypeOrder.indexOf(srt.name);
          if (slti <= srti) {
            if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
              rett = r;
            } else {
              rett = srt;
            }
          } else {
            if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
              rett = l;
            } else {
              rett = slt;
            }
          }
        }
        return rett;
      } else if (!this.isIntegerType(l) && this.isIntegerType(r)) {
        return l;
      } else if (this.isIntegerType(l) && !this.isIntegerType(r)) {
        return r;
      } else if (!this.isIntegerType(l) && !this.isIntegerType(r)) {
        return this.primitiveType("double");
      }
    };
    CRuntime.prototype.writeVar = function(varname) {
      var i,
          ret,
          vc;
      i = this.scope.length - 1;
      while (i >= 0) {
        vc = this.scope[i];
        if (vc[varname]) {
          ret = vc;
          return ret;
        }
        i--;
      }
      this.raiseException("variable " + varname + " does not exist");
    };
    CRuntime.prototype.readVar = function(varname) {
      var i,
          ret,
          vc;
      i = this.scope.length - 1;
      while (i >= 0) {
        vc = this.scope[i];
        if (vc[varname]) {
          ret = vc[varname];
          return ret;
        }
        i--;
      }
      this.raiseException("variable " + varname + " does not exist");
    };
    CRuntime.prototype.varAlreadyDefined = function(varname) {
      var vc;
      vc = this.scope[this.scope.length - 1];
      return varname in vc;
    };
    CRuntime.prototype.defVar = function(varname, type, initval) {
      var vc;
      if (this.varAlreadyDefined(varname)) {
        this.raiseException("variable " + varname + " already defined");
      }
      vc = this.scope[this.scope.length - 1];
      initval = this.clone(this.cast(type, initval));
      if (initval === void 0) {
        vc[varname] = this.defaultValue(type);
        vc[varname].left = true;
      } else {
        vc[varname] = initval;
        vc[varname].left = true;
      }
    };
    CRuntime.prototype.inrange = function(type, value) {
      var limit;
      if (this.isPrimitiveType(type)) {
        limit = this.config.limits[type.name];
        return value <= limit.max && value >= limit.min;
      } else {
        return true;
      }
    };
    CRuntime.prototype.isNumericType = function(type) {
      return this.isFloatType(type) || this.isIntegerType(type);
    };
    CRuntime.prototype.isUnsignedType = function(type) {
      if (typeof type === "string") {
        switch (type) {
          case "unsigned char":
          case "unsigned short":
          case "unsigned short int":
          case "unsigned":
          case "unsigned int":
          case "unsigned long":
          case "unsigned long int":
          case "unsigned long long":
          case "unsigned long long int":
            return true;
          default:
            return false;
        }
      } else {
        return type.type === "primitive" && this.isUnsignedType(type.name);
      }
    };
    CRuntime.prototype.isIntegerType = function(type) {
      if (typeof type === "string") {
        return indexOf.call(this.config.charTypes, type) >= 0 || indexOf.call(this.config.intTypes, type) >= 0;
      } else {
        return type.type === "primitive" && this.isIntegerType(type.name);
      }
    };
    CRuntime.prototype.isFloatType = function(type) {
      if (typeof type === "string") {
        switch (type) {
          case "float":
          case "double":
            return true;
          default:
            return false;
        }
      } else {
        return type.type === "primitive" && this.isFloatType(type.name);
      }
    };
    CRuntime.prototype.getSignedType = function(type) {
      if (type !== "unsigned") {
        return this.primitiveType(type.name.replace("unsigned", "").trim());
      } else {
        return this.primitiveType("int");
      }
    };
    CRuntime.prototype.castable = function(type1, type2) {
      if (this.isTypeEqualTo(type1, type2)) {
        return true;
      }
      if (this.isPrimitiveType(type1) && this.isPrimitiveType(type2)) {
        return this.isNumericType(type2) && this.isNumericType(type1);
      } else if (this.isPointerType(type1) && this.isPointerType(type2)) {
        if (this.isFunctionType(type1)) {
          return this.isPointerType(type2);
        }
        return !this.isFunctionType(type2);
      } else if (this.isClassType(type1) || this.isClassType(type2)) {
        this.raiseException("not implemented");
      }
      return false;
    };
    CRuntime.prototype.cast = function(type, value) {
      var $__9;
      var bytes,
          newValue,
          ref,
          v;
      if (this.isTypeEqualTo(value.t, type)) {
        return value;
      }
      if (this.isPrimitiveType(type) && this.isPrimitiveType(value.t)) {
        if (type.name === "bool") {
          return this.val(type, value.v ? 1 : 0);
        } else if ((ref = type.name) === "float" || ref === "double") {
          if (!this.isNumericType(value.t)) {
            this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
          if (this.inrange(type, value.v)) {
            return this.val(type, value.v);
          } else {
            this.raiseException("overflow when casting " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
        } else {
          if (type.name.slice(0, 8) === "unsigned") {
            if (!this.isNumericType(value.t)) {
              this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
            } else if (value.v < 0) {
              (($__9 = this.config.limits[type.name], bytes = $__9.bytes, $__9));
              newValue = value.v & ((1 << 8 * bytes) - 1);
              if (!this.inrange(type, newValue)) {
                this.raiseException(("cannot cast negative value " + newValue + " to ") + this.makeTypeString(type));
              } else {
                return this.val(type, newValue);
              }
            }
          }
          if (!this.isNumericType(value.t)) {
            this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
          if (value.t.name === "float" || value.t.name === "double") {
            v = value.v > 0 ? Math.floor(value.v) : Math.ceil(value.v);
            if (this.inrange(type, v)) {
              return this.val(type, v);
            } else {
              this.raiseException("overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type));
            }
          } else {
            if (this.inrange(type, value.v)) {
              return this.val(type, value.v);
            } else {
              this.raiseException("overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type));
            }
          }
        }
      } else if (this.isPointerType(type)) {
        if (this.isArrayType(value.t)) {
          if (this.isNormalPointerType(type)) {
            if (this.isTypeEqualTo(type.targetType, value.t.eleType)) {
              return value;
            } else {
              this.raiseException(this.makeTypeString(type.targetType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
            }
          } else if (this.isArrayType(type)) {
            if (this.isTypeEqualTo(type.eleType, value.t.eleType)) {
              return value;
            } else {
              this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
            }
          } else {
            this.raiseException("cannot cast a function to a regular pointer");
          }
        } else {
          if (this.isNormalPointerType(type)) {
            if (this.isTypeEqualTo(type.targetType, value.t.targetType)) {
              return value;
            } else {
              this.raiseException(this.makeTypeString(type.targetType) + " is not equal to " + this.makeTypeString(value.t.eleType));
            }
          } else if (this.isArrayType(type)) {
            if (this.isTypeEqualTo(type.eleType, value.t.targetType)) {
              return value;
            } else {
              this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to " + this.makeTypeString(value.t.eleType));
            }
          } else {
            this.raiseException("cannot cast a function to a regular pointer");
          }
        }
      } else if (this.isFunctionType(type)) {
        if (this.isFunctionType(value.t)) {
          return this.val(value.t, value.v);
        } else {
          this.raiseException("cannot cast a regular pointer to a function");
        }
      } else if (this.isClassType(type)) {
        this.raiseException("not implemented");
      } else if (this.isClassType(value.t)) {
        value = this.getCompatibleFunc(value.t, this.makeOperatorFuncName(type.name), [])(this, value);
        return value;
      } else {
        this.raiseException("cast failed from type " + this.makeTypeString(type) + " to " + this.makeTypeString(value.t));
      }
    };
    CRuntime.prototype.clone = function(v) {
      return this.val(v.t, v.v);
    };
    CRuntime.prototype.enterScope = function(scopename) {
      this.scope.push({"$name": scopename});
    };
    CRuntime.prototype.exitScope = function(scopename) {
      var s;
      while (true) {
        s = this.scope.pop();
        if (!(scopename && this.scope.length > 1 && s["$name"] !== scopename)) {
          break;
        }
      }
    };
    CRuntime.prototype.val = function(type, v, left) {
      if (this.isNumericType(type) && !this.inrange(type, v)) {
        this.raiseException(("overflow of " + this.makeValString({
          t: type,
          v: v
        })));
      }
      if (left === void 0) {
        left = false;
      }
      return {
        "t": type,
        "v": v,
        "left": left
      };
    };
    CRuntime.prototype.isTypeEqualTo = function(type1, type2) {
      var _this;
      if (type1.type === type2.type) {
        switch (type1.type) {
          case "primitive":
          case "class":
            return type1.name === type2.name;
          case "pointer":
            if (type1.ptrType === type2.ptrType || type1.ptrType !== "function" && type2.ptrType !== "function") {
              switch (type1.ptrType) {
                case "array":
                  return this.isTypeEqualTo(type1.eleType, type2.eleType || type2.targetType);
                case "function":
                  return this.isTypeEqualTo(type1.funcType, type2.funcType);
                case "normal":
                  return this.isTypeEqualTo(type1.targetType, type2.eleType || type2.targetType);
              }
            }
            break;
          case "function":
            if (this.isTypeEqualTo(type1.retType, type2.retType) && type1.signature.length === type2.signature.length) {
              _this = this;
              return type1.signature.every(function(type, index, arr) {
                var x;
                x = _this.isTypeEqualTo(type, type2.signature[index]);
                return x;
              });
            }
        }
      }
      return type1 === type2;
    };
    CRuntime.prototype.isBoolType = function(type) {
      if (typeof type === "string") {
        return type === "bool";
      } else {
        return type.type === "primitive" && this.isBoolType(type.name);
      }
    };
    CRuntime.prototype.isVoidType = function(type) {
      if (typeof type === "string") {
        return type === "void";
      } else {
        return type.type === "primitive" && this.isVoidType(type.name);
      }
    };
    CRuntime.prototype.isPrimitiveType = function(type) {
      return this.isNumericType(type) || this.isBoolType(type) || this.isVoidType(type);
    };
    CRuntime.prototype.isArrayType = function(type) {
      return this.isPointerType(type) && type.ptrType === "array";
    };
    CRuntime.prototype.isFunctionType = function(type) {
      return type.type === "function" || this.isNormalPointerType(type) && this.isFunctionType(type.targetType);
    };
    CRuntime.prototype.isNormalPointerType = function(type) {
      return this.isPointerType(type) && type.ptrType === "normal";
    };
    CRuntime.prototype.isPointerType = function(type) {
      return type.type === "pointer";
    };
    CRuntime.prototype.isClassType = function(type) {
      return type.type === "class";
    };
    CRuntime.prototype.arrayPointerType = function(eleType, size) {
      return {
        type: "pointer",
        ptrType: "array",
        eleType: eleType,
        size: size
      };
    };
    CRuntime.prototype.makeArrayPointerValue = function(arr, position) {
      return {
        target: arr,
        position: position
      };
    };
    CRuntime.prototype.functionPointerType = function(retType, signature) {
      return this.normalPointerType(this.functionType(retType, signature));
    };
    CRuntime.prototype.functionType = function(retType, signature) {
      return {
        type: "function",
        retType: retType,
        signature: signature
      };
    };
    CRuntime.prototype.makeFunctionPointerValue = function(f, name, lt, args, retType) {
      return {
        target: f,
        name: name,
        defineType: lt,
        args: args,
        retType: retType
      };
    };
    CRuntime.prototype.normalPointerType = function(targetType) {
      return {
        type: "pointer",
        ptrType: "normal",
        targetType: targetType
      };
    };
    CRuntime.prototype.makeNormalPointerValue = function(target) {
      return {target: target};
    };
    CRuntime.prototype.simpleType = function(type) {
      var $__2 = this;
      var clsType,
          typeStr;
      if (Array.isArray(type)) {
        if (type.length > 1) {
          typeStr = type.filter(function(t) {
            return indexOf.call($__2.config.specifiers, t) < 0;
          }).join(" ");
          return this.simpleType(typeStr);
        } else {
          return this.typedefs[type[0]] || this.simpleType(type[0]);
        }
      } else {
        if (this.isPrimitiveType(type)) {
          return this.primitiveType(type);
        } else {
          clsType = {
            type: "class",
            name: type
          };
          if (this.getTypeSignature(clsType) in this.types) {
            return clsType;
          } else {
            this.raiseException("type " + this.makeTypeString(type) + " is not defined");
          }
        }
      }
    };
    CRuntime.prototype.newClass = function(classname, members) {
      var clsType,
          sig;
      clsType = {
        type: "class",
        name: classname
      };
      sig = this.getTypeSignature(clsType);
      if (sig in this.types) {
        this.raiseException(this.makeTypeString(clsType) + " is already defined");
      }
      this.types[sig] = {
        "#constructor": function(rt, _this) {
          var i,
              member;
          _this.v.members = {};
          i = 0;
          while (i < members.length) {
            member = members[i];
            _this.v.members[member.name] = member.initialize != null ? member.initialize(rt, _this) : rt.defaultValue(member.t, true);
            i++;
          }
        },
        "#members": members
      };
      return clsType;
    };
    CRuntime.prototype.primitiveType = function(type) {
      return {
        type: "primitive",
        name: type
      };
    };
    CRuntime.prototype.isCharType = function(type) {
      return this.config.charTypes.indexOf(type.name) !== -1;
    };
    CRuntime.prototype.isStringType = function(type) {
      return this.isArrayType(type) && this.isCharType(type.eleType);
    };
    CRuntime.prototype.getStringFromCharArray = function(element) {
      var charVal,
          i,
          result,
          target;
      if (this.isStringType(element.t)) {
        target = element.v.target;
        result = "";
        i = 0;
        while (i < target.length) {
          charVal = target[i];
          if (charVal.v === 0) {
            break;
          }
          result += String.fromCharCode(charVal.v);
          i++;
        }
        return result;
      } else {
        this.raiseException("target is not a string");
      }
    };
    CRuntime.prototype.makeCharArrayFromString = function(str, typename) {
      var charType,
          self,
          trailingZero,
          type;
      self = this;
      typename || (typename = "char");
      charType = this.primitiveType(typename);
      type = this.arrayPointerType(charType, str.length + 1);
      trailingZero = this.val(charType, 0);
      return this.val(type, {
        target: str.split("").map(function(c) {
          return self.val(charType, c.charCodeAt(0));
        }).concat([trailingZero]),
        position: 0
      });
    };
    CRuntime.prototype.getTypeSignature = function(type) {
      var $__2 = this;
      var ret,
          self;
      ret = type;
      self = this;
      if (type.type === "primitive") {
        ret = "(" + type.name + ")";
      } else if (type.type === "class") {
        ret = "[" + type.name + "]";
      } else if (type.type === "pointer") {
        ret = "{";
        if (type.ptrType === "normal") {
          ret += "!" + this.getTypeSignature(type.targetType);
        } else if (type.ptrType === "array") {
          ret += "!" + this.getTypeSignature(type.eleType);
        }
        ret += "}";
      } else if (type.type === "function") {
        ret = "#" + this.getTypeSignature(type.retType) + "!" + type.signature.map(function(e) {
          return $__2.getTypeSignature(e);
        }).join(",");
      }
      return ret;
    };
    CRuntime.prototype.makeTypeString = function(type) {
      var $__2 = this;
      var ret;
      ret = "$" + type;
      if (type.type === "primitive") {
        ret = type.name;
      } else if (type.type === "class") {
        ret = type.name;
      } else if (type.type === "pointer") {
        ret = "";
        if (type.ptrType === "normal") {
          ret += this.makeTypeString(type.targetType) + "*";
        } else if (type.ptrType === "array") {
          ret += this.makeTypeString(type.eleType) + ("[" + type.size + "]");
        } else if (type.ptrType === "function") {
          ret += this.makeTypeString(type.retType) + "(*f)" + "(" + type.signature.map(function(e) {
            return $__2.makeTypeString(e);
          }).join(",") + ")";
        }
      }
      return ret;
    };
    CRuntime.prototype.makeValueString = function(l, options) {
      var display,
          i,
          j,
          ref,
          ref1;
      options || (options = {});
      if (this.isPrimitiveType(l.t)) {
        if (this.isTypeEqualTo(l.t, this.charTypeLiteral)) {
          display = "'" + String.fromCharCode(l.v) + "'";
        } else if (this.isBoolType(l.t)) {
          display = l.v !== 0 ? "true" : "false";
        } else {
          display = l.v;
        }
      } else if (this.isPointerType(l.t)) {
        if (this.isFunctionType(l.t)) {
          display = "<function>";
        } else if (this.isArrayType(l.t)) {
          if (this.isTypeEqualTo(l.t.eleType, this.charTypeLiteral)) {
            display = "\"" + this.getStringFromCharArray(l) + "\"";
          } else if (options.noArray) {
            display = "[...]";
          } else {
            options.noArray = true;
            display = [];
            for (i = j = ref = l.v.position, ref1 = l.v.target.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
              display.push(this.makeValueString(l.v.target[i], options));
            }
            display = "[" + display.join(",") + "]";
          }
        } else if (this.isNormalPointerType(l.t)) {
          if (options.noPointer) {
            display = "->?";
          } else {
            options.noPointer = true;
            display = "->" + this.makeValueString(l.v.target);
          }
        } else {
          this.raiseException("unknown pointer type");
        }
      } else if (this.isClassType(l.t)) {
        display = "<object>";
      }
      return display;
    };
    CRuntime.prototype.makeValString = function(l) {
      return this.makeValueString(l) + "(" + this.makeTypeString(l.t) + ")";
    };
    CRuntime.prototype.defaultValue = function(type, left) {
      var i,
          init,
          j,
          ref,
          ret;
      if (type.type === "primitive") {
        if (this.isNumericType(type)) {
          return this.val(type, 0, left);
        }
      } else if (type.type === "class") {
        ret = this.val(type, {}, left);
        this.types[this.getTypeSignature(type)]["#constructor"](this, ret);
        return ret;
      } else if (type.type === "pointer") {
        if (type.ptrType === "normal") {
          return this.val(type, this.nullPointerValue, left);
        } else if (type.ptrType === "array") {
          init = [];
          for (i = j = 0, ref = type.size; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            init[i] = this.defaultValue(type.eleType, true);
          }
          return this.val(type, this.makeArrayPointerValue(init, 0), left);
        }
      }
    };
    CRuntime.prototype.raiseException = function(message, currentNode) {
      var col,
          ln,
          posInfo;
      if (this.interp) {
        if (currentNode == null) {
          currentNode = this.interp.currentNode;
        }
        posInfo = currentNode != null ? (ln = currentNode.sLine, col = currentNode.sColumn, ln + ":" + col) : "<position unavailable>";
        throw posInfo + " " + message;
      } else {
        throw message;
      }
    };
    module.exports = CRuntime;
  }, {"./defaults": 3}],
  30: [function(require, module, exports) {
    'use strict';
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0,
        len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
    function placeHoldersCount(b64) {
      var len = b64.length;
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
    }
    function byteLength(b64) {
      return (b64.length * 3 / 4) - placeHoldersCount(b64);
    }
    function toByteArray(b64) {
      var i,
          l,
          tmp,
          placeHolders,
          arr;
      var len = b64.length;
      placeHolders = placeHoldersCount(b64);
      arr = new Arr((len * 3 / 4) - placeHolders);
      l = placeHolders > 0 ? len - 4 : len;
      var L = 0;
      for (i = 0; i < l; i += 4) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }
      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('');
    }
    function fromByteArray(uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3;
      var output = '';
      var parts = [];
      var maxChunkLength = 16383;
      for (var i = 0,
          len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }
      parts.push(output);
      return parts.join('');
    }
  }, {}],
  31: [function(require, module, exports) {}, {}],
  32: [function(require, module, exports) {
    'use strict';
    var base64 = require('base64-js');
    var ieee754 = require('ieee754');
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function() {
            return 42;
          }
        };
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('Invalid typed array length');
      }
      var buf = new Uint8Array(length);
      buf.__proto__ = Buffer.prototype;
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error('If encoding is specified then the first argument must be a string');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }
      return fromObject(value);
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== undefined) {
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
      }
      var buf;
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      buf.__proto__ = Buffer.prototype;
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (isArrayBufferView(obj) || 'length' in obj) {
          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true;
    };
    Buffer.compare = function compare(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0,
          len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (isArrayBufferView(string) || isArrayBuffer(string)) {
        return string.byteLength;
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length;
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;
          case 'hex':
            return len >>> 1;
          case 'base64':
            return base64ToBytes(string).length;
          default:
            if (loweredCase)
              return utf8ToBytes(string).length;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === undefined || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return '';
      }
      if (end === undefined || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return '';
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return '';
      }
      if (!encoding)
        encoding = 'utf8';
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);
          case 'ascii':
            return asciiSlice(this, start, end);
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);
          case 'base64':
            return base64Slice(this, start, end);
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return '';
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError('Argument must be a Buffer');
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max)
          str += ' ... ';
      }
      return '<Buffer ' + str + '>';
    };
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
      }
      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : (buffer.length - 1);
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError('val must be string, number or Buffer');
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (strLen % 2 !== 0)
        throw new TypeError('Invalid hex string');
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined)
            encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }
      var remaining = this.length - offset;
      if (length === undefined || length > remaining)
        length = remaining;
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }
      if (!encoding)
        encoding = 'utf8';
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);
          case 'ascii':
            return asciiWrite(this, string, offset, length);
          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);
          case 'base64':
            return base64Write(this, string, offset, length);
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte = void 0,
              thirdByte = void 0,
              fourthByte = void 0,
              tempCodePoint = void 0;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 0x1000;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0)
        throw new RangeError('offset is not uint');
      if (offset + ext > length)
        throw new RangeError('Trying to access beyond buffer length');
    }
    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }
      return val;
    };
    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8);
    };
    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1];
    };
    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
    };
    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80))
        return (this[offset]);
      return ((0xff - this[offset] + 1) * -1);
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
    }
    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }
      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = (value & 0xff);
      return offset + 1;
    };
    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2;
    };
    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2;
    };
    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
      return offset + 4;
    };
    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }
      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0)
        value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0)
        value = 0xffffffff + value + 1;
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
      if (offset < 0)
        throw new RangeError('Index out of range');
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }
      if (start < 0 || start >= this.length)
        throw new RangeError('sourceStart out of bounds');
      if (end < 0)
        throw new RangeError('sourceEnd out of bounds');
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.trim().replace(INVALID_BASE64_RE, '');
      if (str.length < 2)
        return '';
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str;
    }
    function toHex(n) {
      if (n < 16)
        return '0' + n.toString(16);
      return n.toString(16);
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          if (!leadSurrogate) {
            if (codePoint > 0xDBFF) {
              if ((units -= 3) > -1)
                bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        if (codePoint < 0x80) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c,
          hi,
          lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length))
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isArrayBuffer(obj) {
      return obj instanceof ArrayBuffer || (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' && typeof obj.byteLength === 'number');
    }
    function isArrayBufferView(obj) {
      return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj);
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
  }, {
    "base64-js": 30,
    "ieee754": 35
  }],
  33: [function(require, module, exports) {
    (function(Buffer) {
      function isArray(arg) {
        if (Array.isArray) {
          return Array.isArray(arg);
        }
        return objectToString(arg) === '[object Array]';
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol';
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;
      function isError(e) {
        return (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol' || typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = Buffer.isBuffer;
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
    }).call(this, {"isBuffer": require("../../is-buffer/index.js")});
  }, {"../../is-buffer/index.js": 37}],
  34: [function(require, module, exports) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er,
          handler,
          len,
          args,
          i,
          listeners;
      if (!this._events)
        this._events = {};
      if (type === 'error') {
        if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
            err.context = er;
            throw err;
          }
        }
      }
      handler = this._events[type];
      if (isUndefined(handler))
        return false;
      if (isFunction(handler)) {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      if (!this._events)
        this._events = {};
      if (this._events.newListener)
        this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
      if (!this._events[type])
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        this._events[type].push(listener);
      else
        this._events[type] = [this._events[type], listener];
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
          if (typeof console.trace === 'function') {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      var fired = false;
      function g() {
        this.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
      g.listener = listener;
      this.on(type, g);
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list,
          position,
          length,
          i;
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      if (!this._events || !this._events[type])
        return this;
      list = this._events[type];
      length = list.length;
      position = -1;
      if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0; ) {
          if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key,
          listeners;
      if (!this._events)
        return this;
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener')
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }
      listeners = this._events[type];
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
        if (isFunction(evlistener))
          return 1;
        else if (evlistener)
          return evlistener.length;
      }
      return 0;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isObject(arg) {
      return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
  }, {}],
  35: [function(require, module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e,
          m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity);
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e,
          m,
          c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
      buffer[offset + i - d] |= s * 128;
    };
  }, {}],
  36: [function(require, module, exports) {
    if (typeof Object.create === 'function') {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }});
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }, {}],
  37: [function(require, module, exports) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
    }
  }, {}],
  38: [function(require, module, exports) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == '[object Array]';
    };
  }, {}],
  39: [function(require, module, exports) {
    (function(global) {
      (function(root, name, factory) {
        if (typeof define === "function" && typeof define.amd !== "undefined")
          define(name, function() {
            return factory(root);
          });
        else if ((typeof module === 'undefined' ? 'undefined' : $traceurRuntime.typeof(module)) === "object" && $traceurRuntime.typeof(module.exports) === "object")
          module.exports = factory(root);
        else
          root[name] = factory(root);
      }((typeof global !== "undefined" ? global : (typeof window !== "undefined" ? window : this)), "PEGUtil", function() {
        var PEGUtil = {};
        PEGUtil.makeAST = function makeAST(location, options) {
          return function() {
            return options.util.__makeAST.call(null, location().start.line, location().start.column, location().start.offset, arguments);
          };
        };
        PEGUtil.makeUnroll = function(location, options) {
          return function(first, list, take) {
            if ((typeof list === 'undefined' ? 'undefined' : $traceurRuntime.typeof(list)) !== "object" || !(list instanceof Array))
              throw new options.util.__SyntaxError("unroll: invalid list argument for unrolling", ((typeof list === 'undefined' ? 'undefined' : $traceurRuntime.typeof(list))), "Array", location());
            if (typeof take !== "undefined") {
              if (typeof take === "number")
                take = [take];
              var result = [];
              if (first !== null)
                result.push(first);
              for (var i = 0; i < list.length; i++) {
                for (var j = 0; j < take.length; j++)
                  result.push(list[i][take[j]]);
              }
              return result;
            } else {
              if (first !== null)
                list.unshift(first);
              return list;
            }
          };
        };
        var excerpt = function(txt, o) {
          var l = txt.length;
          var b = o - 20;
          if (b < 0)
            b = 0;
          var e = o + 20;
          if (e > l)
            e = l;
          var hex = function(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          };
          var extract = function(txt, pos, len) {
            return txt.substr(pos, len).replace(/\\/g, "\\\\").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0100-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1000-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          };
          return {
            prolog: extract(txt, b, o - b),
            token: extract(txt, o, 1),
            epilog: extract(txt, o + 1, e - (o + 1))
          };
        };
        PEGUtil.parse = function(parser, txt, options) {
          if ((typeof parser === 'undefined' ? 'undefined' : $traceurRuntime.typeof(parser)) !== "object")
            throw new Error("invalid parser object (not an object)");
          if (typeof parser.parse !== "function")
            throw new Error("invalid parser object (no \"parse\" function)");
          if (typeof txt !== "string")
            throw new Error("invalid input text (not a string)");
          if (typeof options !== "undefined" && (typeof options === 'undefined' ? 'undefined' : $traceurRuntime.typeof(options)) !== "object")
            throw new Error("invalid options (not an object)");
          if (typeof options === "undefined")
            options = {};
          var result = {
            ast: null,
            error: null
          };
          try {
            var makeAST;
            if (typeof options.makeAST === "function")
              makeAST = options.makeAST;
            else {
              makeAST = function(location, args) {
                return {
                  line: location().start.line,
                  column: location().start.column,
                  offset: location().start.offset,
                  args: args
                };
              };
            }
            options.util = {
              makeUnroll: PEGUtil.makeUnroll,
              makeAST: PEGUtil.makeAST,
              __makeAST: makeAST,
              __SyntaxError: parser.SyntaxError
            };
            result.ast = parser.parse(txt, options);
            result.error = null;
          } catch (e) {
            result.ast = null;
            if (e instanceof parser.SyntaxError) {
              var definedOrElse = function(value, fallback) {
                return (typeof value !== "undefined" ? value : fallback);
              };
              result.error = {
                line: definedOrElse(e.location.start.line, 0),
                column: definedOrElse(e.location.start.column, 0),
                message: e.message,
                found: definedOrElse(e.found, ""),
                expected: definedOrElse(e.expected, ""),
                location: excerpt(txt, definedOrElse(e.location.start.offset, 0))
              };
            } else {
              result.error = {
                line: 0,
                column: 0,
                message: e.message,
                found: "",
                expected: "",
                location: excerpt("", 0)
              };
            }
          }
          return result;
        };
        PEGUtil.errorMessage = function(e, noFinalNewline) {
          var l = e.location;
          var prefix1 = "line " + e.line + " (column " + e.column + "): ";
          var prefix2 = "";
          for (var i = 0; i < prefix1.length + l.prolog.length; i++)
            prefix2 += "-";
          var msg = prefix1 + l.prolog + l.token + l.epilog + "\n" + prefix2 + "^" + "\n" + e.message + (noFinalNewline ? "" : "\n");
          return msg;
        };
        return PEGUtil;
      }));
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  40: [function(require, module, exports) {
    var util = require('util');
    var tokenize = function(str, re, parseDelim, instance) {
      var tokens = [];
      var match,
          content,
          lastIndex = 0;
      while ((match = re.exec(str))) {
        content = str.slice(lastIndex, re.lastIndex - match[0].length);
        if (content.length) {
          tokens.push(content);
        }
        if (parseDelim) {
          var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
          if (typeof parsed != 'undefined') {
            if (parsed.specifier === '%') {
              tokens.push('%');
            } else {
              tokens.push(parsed);
            }
          }
        }
        lastIndex = re.lastIndex;
      }
      content = str.slice(lastIndex);
      if (content.length) {
        tokens.push(content);
      }
      return tokens;
    };
    var Formatter = function(format) {
      this._mapped = false;
      this._format = format;
      this._tokens = tokenize(format, this._re, this._parseDelim, this);
    };
    Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
    Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier) {
      if (mapping) {
        this._mapped = true;
      }
      return {
        mapping: mapping,
        intmapping: intmapping,
        flags: flags,
        _minWidth: minWidth,
        period: period,
        _precision: precision,
        specifier: specifier
      };
    };
    Formatter.prototype._specifiers = {
      b: {
        base: 2,
        isInt: true
      },
      o: {
        base: 8,
        isInt: true
      },
      x: {
        base: 16,
        isInt: true
      },
      X: {
        extend: ['x'],
        toUpper: true
      },
      d: {
        base: 10,
        isInt: true
      },
      i: {extend: ['d']},
      u: {
        extend: ['d'],
        isUnsigned: true
      },
      c: {setArg: function(token) {
          if (!isNaN(token.arg)) {
            var num = parseInt(token.arg);
            if (num < 0 || num > 127) {
              throw new Error('invalid character code passed to %c in printf');
            }
            token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
          }
        }},
      s: {setMaxWidth: function(token) {
          token.maxWidth = (token.period == '.') ? token.precision : -1;
        }},
      e: {
        isDouble: true,
        doubleNotation: 'e'
      },
      E: {
        extend: ['e'],
        toUpper: true
      },
      f: {
        isDouble: true,
        doubleNotation: 'f'
      },
      F: {extend: ['f']},
      g: {
        isDouble: true,
        doubleNotation: 'g'
      },
      G: {
        extend: ['g'],
        toUpper: true
      },
      O: {isObject: true}
    };
    Formatter.prototype.format = function(filler) {
      if (this._mapped && (typeof filler === 'undefined' ? 'undefined' : $traceurRuntime.typeof(filler)) != 'object') {
        throw new Error('format requires a mapping');
      }
      var str = '';
      var position = 0;
      for (var i = 0,
          token = void 0; i < this._tokens.length; i++) {
        token = this._tokens[i];
        if (typeof token == 'string') {
          str += token;
        } else {
          if (this._mapped) {
            var tokens = token.mapping.split('.');
            var value = filler;
            for (var j = 0,
                c = tokens.length; j < c; j++) {
              value = value[tokens[j]];
              if (typeof value === 'undefined') {
                break;
              }
            }
            if (typeof value == 'undefined') {
              throw new Error('missing key ' + token.mapping);
            }
            token.arg = value;
          } else {
            if (token.intmapping) {
              position = parseInt(token.intmapping) - 1;
            }
            if (position >= arguments.length) {
              throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
            }
            token.arg = arguments[position++];
          }
          if (!token.compiled) {
            token.compiled = true;
            token.sign = '';
            token.zeroPad = false;
            token.rightJustify = false;
            token.alternative = false;
            var flags = {};
            for (var fi = token.flags.length; fi--; ) {
              var flag = token.flags.charAt(fi);
              flags[flag] = true;
              switch (flag) {
                case ' ':
                  token.sign = ' ';
                  break;
                case '+':
                  token.sign = '+';
                  break;
                case '0':
                  token.zeroPad = (flags['-']) ? false : true;
                  break;
                case '-':
                  token.rightJustify = true;
                  token.zeroPad = false;
                  break;
                case '#':
                  token.alternative = true;
                  break;
                default:
                  throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
              }
            }
            token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
            token.maxWidth = -1;
            token.toUpper = false;
            token.isUnsigned = false;
            token.isInt = false;
            token.isDouble = false;
            token.isObject = false;
            token.precision = 1;
            if (token.period == '.') {
              if (token._precision) {
                token.precision = parseInt(token._precision);
              } else {
                token.precision = 0;
              }
            }
            var mixins = this._specifiers[token.specifier];
            if (typeof mixins == 'undefined') {
              throw new Error('unexpected specifier \'' + token.specifier + '\'');
            }
            if (mixins.extend) {
              var s = this._specifiers[mixins.extend];
              for (var k in s) {
                mixins[k] = s[k];
              }
              delete mixins.extend;
            }
            for (var l in mixins) {
              token[l] = mixins[l];
            }
          }
          if (typeof token.setArg == 'function') {
            token.setArg(token);
          }
          if (typeof token.setMaxWidth == 'function') {
            token.setMaxWidth(token);
          }
          if (token._minWidth == '*') {
            if (this._mapped) {
              throw new Error('* width not supported in mapped formats');
            }
            token.minWidth = parseInt(arguments[position++]);
            if (isNaN(token.minWidth)) {
              throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
            }
            if (token.minWidth < 0) {
              token.rightJustify = true;
              token.minWidth = -token.minWidth;
            }
          }
          if (token._precision == '*' && token.period == '.') {
            if (this._mapped) {
              throw new Error('* precision not supported in mapped formats');
            }
            token.precision = parseInt(arguments[position++]);
            if (isNaN(token.precision)) {
              throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
            }
            if (token.precision < 0) {
              token.precision = 1;
              token.period = '';
            }
          }
          if (token.isInt) {
            if (token.period == '.') {
              token.zeroPad = false;
            }
            this.formatInt(token);
          } else if (token.isDouble) {
            if (token.period != '.') {
              token.precision = 6;
            }
            this.formatDouble(token);
          } else if (token.isObject) {
            this.formatObject(token);
          }
          this.fitField(token);
          str += '' + token.arg;
        }
      }
      return str;
    };
    Formatter.prototype._zeros10 = '0000000000';
    Formatter.prototype._spaces10 = '          ';
    Formatter.prototype.formatInt = function(token) {
      var i = parseInt(token.arg);
      if (!isFinite(i)) {
        if (typeof token.arg != 'number') {
          throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
        }
        i = 0;
      }
      if (i < 0 && (token.isUnsigned || token.base != 10)) {
        i = 0xffffffff + i + 1;
      }
      if (i < 0) {
        token.arg = (-i).toString(token.base);
        this.zeroPad(token);
        token.arg = '-' + token.arg;
      } else {
        token.arg = i.toString(token.base);
        if (!i && !token.precision) {
          token.arg = '';
        } else {
          this.zeroPad(token);
        }
        if (token.sign) {
          token.arg = token.sign + token.arg;
        }
      }
      if (token.base == 16) {
        if (token.alternative) {
          token.arg = '0x' + token.arg;
        }
        token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
      }
      if (token.base == 8) {
        if (token.alternative && token.arg.charAt(0) != '0') {
          token.arg = '0' + token.arg;
        }
      }
    };
    Formatter.prototype.formatDouble = function(token) {
      var f = parseFloat(token.arg);
      if (!isFinite(f)) {
        if (typeof token.arg != 'number') {
          throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
        }
        f = 0;
      }
      switch (token.doubleNotation) {
        case 'e':
          {
            token.arg = f.toExponential(token.precision);
            break;
          }
        case 'f':
          {
            token.arg = f.toFixed(token.precision);
            break;
          }
        case 'g':
          {
            if (Math.abs(f) < 0.0001) {
              token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
            } else {
              token.arg = f.toPrecision(token.precision);
            }
            if (!token.alternative) {
              token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
              token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/, '');
            }
            break;
          }
        default:
          throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
      }
      token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');
      if (token.alternative) {
        token.arg = token.arg.replace(/^(\d+)$/, '$1.');
        token.arg = token.arg.replace(/^(\d+)e/, '$1.e');
      }
      if (f >= 0 && token.sign) {
        token.arg = token.sign + token.arg;
      }
      token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
    };
    Formatter.prototype.formatObject = function(token) {
      var precision = (token.period === '.') ? token.precision : null;
      token.arg = util.inspect(token.arg, !token.alternative, precision);
    };
    Formatter.prototype.zeroPad = function(token, length) {
      length = (arguments.length == 2) ? length : token.precision;
      var negative = false;
      if (typeof token.arg != "string") {
        token.arg = "" + token.arg;
      }
      if (token.arg.substr(0, 1) === '-') {
        negative = true;
        token.arg = token.arg.substr(1);
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
      if (negative)
        token.arg = '-' + token.arg;
    };
    Formatter.prototype.fitField = function(token) {
      if (token.maxWidth >= 0 && token.arg.length > token.maxWidth) {
        return token.arg.substring(0, token.maxWidth);
      }
      if (token.zeroPad) {
        this.zeroPad(token, token.minWidth);
        return;
      }
      this.spacePad(token);
    };
    Formatter.prototype.spacePad = function(token, length) {
      length = (arguments.length == 2) ? length : token.minWidth;
      if (typeof token.arg != 'string') {
        token.arg = '' + token.arg;
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
    };
    module.exports = function() {
      var args = Array.prototype.slice.call(arguments),
          stream,
          format;
      if (args[0] instanceof require('stream').Stream) {
        stream = args.shift();
      }
      format = args.shift();
      var formatter = new Formatter(format);
      var string = formatter.format.apply(formatter, args);
      if (stream) {
        stream.write(string);
      } else {
        return string;
      }
    };
    module.exports.Formatter = Formatter;
  }, {
    "stream": 57,
    "util": 62
  }],
  41: [function(require, module, exports) {
    (function(process) {
      'use strict';
      if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
        module.exports = nextTick;
      } else {
        module.exports = process.nextTick;
      }
      function nextTick(fn, arg1, arg2, arg3) {
        if (typeof fn !== 'function') {
          throw new TypeError('"callback" argument must be a function');
        }
        var len = arguments.length;
        var args,
            i;
        switch (len) {
          case 0:
          case 1:
            return process.nextTick(fn);
          case 2:
            return process.nextTick(function afterTickOne() {
              fn.call(null, arg1);
            });
          case 3:
            return process.nextTick(function afterTickTwo() {
              fn.call(null, arg1, arg2);
            });
          case 4:
            return process.nextTick(function afterTickThree() {
              fn.call(null, arg1, arg2, arg3);
            });
          default:
            args = new Array(len - 1);
            i = 0;
            while (i < args.length) {
              args[i++] = arguments[i];
            }
            return process.nextTick(function afterTick() {
              fn.apply(null, args);
            });
        }
      }
    }).call(this, require('_process'));
  }, {"_process": 42}],
  42: [function(require, module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function() {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }());
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error('process.binding is not supported');
    };
    process.cwd = function() {
      return '/';
    };
    process.chdir = function(dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function() {
      return 0;
    };
  }, {}],
  43: [function(require, module, exports) {
    module.exports = require('./lib/_stream_duplex.js');
  }, {"./lib/_stream_duplex.js": 44}],
  44: [function(require, module, exports) {
    'use strict';
    var processNextTick = require('process-nextick-args');
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj) {
        keys.push(key);
      }
      return keys;
    };
    module.exports = Duplex;
    var util = require('core-util-is');
    util.inherits = require('inherits');
    var Readable = require('./_stream_readable');
    var Writable = require('./_stream_writable');
    util.inherits(Duplex, Readable);
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      processNextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    Object.defineProperty(Duplex.prototype, 'destroyed', {
      get: function() {
        if (this._readableState === undefined || this._writableState === undefined) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === undefined || this._writableState === undefined) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      processNextTick(cb, err);
    };
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }, {
    "./_stream_readable": 46,
    "./_stream_writable": 48,
    "core-util-is": 33,
    "inherits": 36,
    "process-nextick-args": 41
  }],
  45: [function(require, module, exports) {
    'use strict';
    module.exports = PassThrough;
    var Transform = require('./_stream_transform');
    var util = require('core-util-is');
    util.inherits = require('inherits');
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }, {
    "./_stream_transform": 47,
    "core-util-is": 33,
    "inherits": 36
  }],
  46: [function(require, module, exports) {
    (function(process, global) {
      'use strict';
      var processNextTick = require('process-nextick-args');
      module.exports = Readable;
      var isArray = require('isarray');
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = require('events').EventEmitter;
      var EElistenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require('./internal/streams/stream');
      var Buffer = require('safe-buffer').Buffer;
      var OurUint8Array = global.Uint8Array || function() {};
      function _uint8ArrayToBuffer(chunk) {
        return Buffer.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var util = require('core-util-is');
      util.inherits = require('inherits');
      var debugUtil = require('util');
      var debug = void 0;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog('stream');
      } else {
        debug = function() {};
      }
      var BufferList = require('./internal/streams/BufferList');
      var destroyImpl = require('./internal/streams/destroy');
      var StringDecoder;
      util.inherits(Readable, Stream);
      var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === 'function') {
          return emitter.prependListener(event, fn);
        } else {
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      function ReadableState(options, stream) {
        Duplex = Duplex || require('./_stream_duplex');
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || 'utf8';
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require('string_decoder/').StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require('./_stream_duplex');
        if (!(this instanceof Readable))
          return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options) {
          if (typeof options.read === 'function')
            this._read = options.read;
          if (typeof options.destroy === 'function')
            this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, 'destroyed', {
        get: function() {
          if (this._readableState === undefined) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        this.push(null);
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === 'string') {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer.from(chunk, encoding);
              encoding = '';
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
          if (er) {
            stream.emit('error', er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                stream.emit('error', new Error('stream.unshift() after end event'));
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              stream.emit('error', new Error('stream.push() after EOF'));
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
          }
        }
        return needMoreData(state);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
          er = new TypeError('Invalid non-string/buffer chunk');
        }
        return er;
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 0x800000;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug('read', n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug('read: emitReadable', state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug('need readable', doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug('length less than watermark', doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug('reading or ended', doRead);
        } else if (doRead) {
          debug('do read');
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit('data', ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug('emitReadable', state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            processNextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug('emit readable');
        stream.emit('readable');
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          processNextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug('maybeReadMore read 0');
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit('error', new Error('_read() is not implemented'));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          processNextTick(endFn);
        else
          src.once('end', endFn);
        dest.on('unpipe', onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug('onunpipe');
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug('onend');
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on('drain', ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug('cleanup');
          dest.removeListener('close', onclose);
          dest.removeListener('finish', onfinish);
          dest.removeListener('drain', ondrain);
          dest.removeListener('error', onerror);
          dest.removeListener('unpipe', onunpipe);
          src.removeListener('end', onend);
          src.removeListener('end', unpipe);
          src.removeListener('data', ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on('data', ondata);
        function ondata(chunk) {
          debug('ondata');
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug('false write response, pause', src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug('onerror', er);
          unpipe();
          dest.removeListener('error', onerror);
          if (EElistenerCount(dest, 'error') === 0)
            dest.emit('error', er);
        }
        prependListener(dest, 'error', onerror);
        function onclose() {
          dest.removeListener('finish', onfinish);
          unpipe();
        }
        dest.once('close', onclose);
        function onfinish() {
          debug('onfinish');
          dest.removeListener('close', onclose);
          unpipe();
        }
        dest.once('finish', onfinish);
        function unpipe() {
          debug('unpipe');
          src.unpipe(dest);
        }
        dest.emit('pipe', src);
        if (!state.flowing) {
          debug('pipe resume');
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug('pipeOnDrain', state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {hasUnpiped: false};
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit('unpipe', this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit('unpipe', this, unpipeInfo);
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit('unpipe', this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        if (ev === 'data') {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === 'readable') {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              processNextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self) {
        debug('readable nexttick read 0');
        self.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug('resume');
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          processNextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug('resume read 0');
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit('resume');
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug('call pause flowing=%j', this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug('pause');
          this._readableState.flowing = false;
          this.emit('pause');
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug('flow', state.flowing);
        while (state.flowing && stream.read() !== null) {}
      }
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self = this;
        stream.on('end', function() {
          debug('wrapped end');
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self.push(chunk);
          }
          self.push(null);
        });
        stream.on('data', function(chunk) {
          debug('wrapped data');
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === undefined))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
        }
        self._read = function(n) {
          debug('wrapped _read', n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join('');
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          processNextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit('end');
        }
      }
      function forEach(xs, f) {
        for (var i = 0,
            l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      function indexOf(xs, x) {
        for (var i = 0,
            l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./_stream_duplex": 44,
    "./internal/streams/BufferList": 49,
    "./internal/streams/destroy": 50,
    "./internal/streams/stream": 51,
    "_process": 42,
    "core-util-is": 33,
    "events": 34,
    "inherits": 36,
    "isarray": 38,
    "process-nextick-args": 41,
    "safe-buffer": 56,
    "string_decoder/": 58,
    "util": 31
  }],
  47: [function(require, module, exports) {
    'use strict';
    module.exports = Transform;
    var Duplex = require('./_stream_duplex');
    var util = require('core-util-is');
    util.inherits = require('inherits');
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return stream.emit('error', new Error('write callback called multiple times'));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined)
        stream.push(data);
      cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er, data) {
            done(stream, er, data);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('_transform() is not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this.emit('close');
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit('error', er);
      if (data !== null && data !== undefined)
        stream.push(data);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('Calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('Calling transform done when still transforming');
      return stream.push(null);
    }
  }, {
    "./_stream_duplex": 44,
    "core-util-is": 33,
    "inherits": 36
  }],
  48: [function(require, module, exports) {
    (function(process, global) {
      'use strict';
      var processNextTick = require('process-nextick-args');
      module.exports = Writable;
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
      var Duplex;
      Writable.WritableState = WritableState;
      var util = require('core-util-is');
      util.inherits = require('inherits');
      var internalUtil = {deprecate: require('util-deprecate')};
      var Stream = require('./internal/streams/stream');
      var Buffer = require('safe-buffer').Buffer;
      var OurUint8Array = global.Uint8Array || function() {};
      function _uint8ArrayToBuffer(chunk) {
        return Buffer.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require('./internal/streams/destroy');
      util.inherits(Writable, Stream);
      function nop() {}
      function WritableState(options, stream) {
        Duplex = Duplex || require('./_stream_duplex');
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || 'utf8';
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, 'buffer', {get: internalUtil.deprecate(function() {
              return this.getBuffer();
            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')});
        } catch (_) {}
      })();
      var realHasInstance;
      if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {value: function(object) {
            if (realHasInstance.call(this, object))
              return true;
            return object && object._writableState instanceof WritableState;
          }});
      } else {
        realHasInstance = function(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require('./_stream_duplex');
        if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
          return new Writable(options);
        }
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === 'function')
            this._write = options.write;
          if (typeof options.writev === 'function')
            this._writev = options.writev;
          if (typeof options.destroy === 'function')
            this._destroy = options.destroy;
          if (typeof options.final === 'function')
            this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit('error', new Error('Cannot pipe, not readable'));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error('write after end');
        stream.emit('error', er);
        processNextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError('May not write null values to stream');
        } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
          er = new TypeError('Invalid non-string/buffer chunk');
        }
        if (er) {
          stream.emit('error', er);
          processNextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = _isUint8Array(chunk) && !state.objectMode;
        if (isBuf && !Buffer.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === 'function') {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = 'buffer';
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== 'function')
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === 'string')
          encoding = encoding.toLowerCase();
        if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
          throw new TypeError('Unknown encoding: ' + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
          chunk = Buffer.from(chunk, encoding);
        }
        return chunk;
      }
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = 'buffer';
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          processNextTick(cb, er);
          processNextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          stream.emit('error', er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          stream.emit('error', er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            asyncWrite(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit('drain');
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, '', holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error('_write() is not implemented'));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === 'function') {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === 'function') {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== undefined)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            stream.emit('error', err);
          }
          state.prefinished = true;
          stream.emit('prefinish');
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === 'function') {
            state.pendingcb++;
            state.finalCalled = true;
            processNextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit('prefinish');
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit('finish');
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            processNextTick(cb);
          else
            stream.once('finish', cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = corkReq;
        } else {
          state.corkedRequestsFree = corkReq;
        }
      }
      Object.defineProperty(Writable.prototype, 'destroyed', {
        get: function() {
          if (this._writableState === undefined) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        this.end();
        cb(err);
      };
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./_stream_duplex": 44,
    "./internal/streams/destroy": 50,
    "./internal/streams/stream": 51,
    "_process": 42,
    "core-util-is": 33,
    "inherits": 36,
    "process-nextick-args": 41,
    "safe-buffer": 56,
    "util-deprecate": 59
  }],
  49: [function(require, module, exports) {
    'use strict';
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer = require('safe-buffer').Buffer;
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return '';
        var p = this.head;
        var ret = '' + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
  }, {"safe-buffer": 56}],
  50: [function(require, module, exports) {
    'use strict';
    var processNextTick = require('process-nextick-args');
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          processNextTick(emitErrorNT, this, err);
        }
        return;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err) {
        if (!cb && err) {
          processNextTick(emitErrorNT, _this, err);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err);
        }
      });
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self, err) {
      self.emit('error', err);
    }
    module.exports = {
      destroy: destroy,
      undestroy: undestroy
    };
  }, {"process-nextick-args": 41}],
  51: [function(require, module, exports) {
    module.exports = require('events').EventEmitter;
  }, {"events": 34}],
  52: [function(require, module, exports) {
    module.exports = require('./readable').PassThrough;
  }, {"./readable": 53}],
  53: [function(require, module, exports) {
    exports = module.exports = require('./lib/_stream_readable.js');
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require('./lib/_stream_writable.js');
    exports.Duplex = require('./lib/_stream_duplex.js');
    exports.Transform = require('./lib/_stream_transform.js');
    exports.PassThrough = require('./lib/_stream_passthrough.js');
  }, {
    "./lib/_stream_duplex.js": 44,
    "./lib/_stream_passthrough.js": 45,
    "./lib/_stream_readable.js": 46,
    "./lib/_stream_transform.js": 47,
    "./lib/_stream_writable.js": 48
  }],
  54: [function(require, module, exports) {
    module.exports = require('./readable').Transform;
  }, {"./readable": 53}],
  55: [function(require, module, exports) {
    module.exports = require('./lib/_stream_writable.js');
  }, {"./lib/_stream_writable.js": 48}],
  56: [function(require, module, exports) {
    var buffer = require('buffer');
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }
      return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      var buf = Buffer(size);
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return buffer.SlowBuffer(size);
    };
  }, {"buffer": 32}],
  57: [function(require, module, exports) {
    module.exports = Stream;
    var EE = require('events').EventEmitter;
    var inherits = require('inherits');
    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/readable.js');
    Stream.Writable = require('readable-stream/writable.js');
    Stream.Duplex = require('readable-stream/duplex.js');
    Stream.Transform = require('readable-stream/transform.js');
    Stream.PassThrough = require('readable-stream/passthrough.js');
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on('data', ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on('drain', ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function')
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
          throw er;
        }
      }
      source.on('error', onerror);
      dest.on('error', onerror);
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
      }
      source.on('end', cleanup);
      source.on('close', cleanup);
      dest.on('close', cleanup);
      dest.emit('pipe', source);
      return dest;
    };
  }, {
    "events": 34,
    "inherits": 36,
    "readable-stream/duplex.js": 43,
    "readable-stream/passthrough.js": 52,
    "readable-stream/readable.js": 53,
    "readable-stream/transform.js": 54,
    "readable-stream/writable.js": 55
  }],
  58: [function(require, module, exports) {
    'use strict';
    var Buffer = require('safe-buffer').Buffer;
    var isEncoding = Buffer.isEncoding || function(encoding) {
      encoding = '' + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return 'utf8';
      var retried;
      while (true) {
        switch (enc) {
          case 'utf8':
          case 'utf-8':
            return 'utf8';
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return 'utf16le';
          case 'latin1':
          case 'binary':
            return 'latin1';
          case 'base64':
          case 'ascii':
          case 'hex':
            return enc;
          default:
            if (retried)
              return;
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
      }
    }
    ;
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error('Unknown encoding: ' + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case 'utf16le':
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case 'utf8':
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case 'base64':
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return '';
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined)
          return '';
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || '';
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 0x7F)
        return 0;
      else if (byte >> 5 === 0x06)
        return 2;
      else if (byte >> 4 === 0x0E)
        return 3;
      else if (byte >> 3 === 0x1E)
        return 4;
      return -1;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd'.repeat(p);
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
          self.lastNeed = 1;
          return '\ufffd'.repeat(p + 1);
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 0xC0) !== 0x80) {
            self.lastNeed = 2;
            return '\ufffd'.repeat(p + 2);
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString('utf8', i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString('utf8', i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed)
        return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 0xD800 && c <= 0xDBFF) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString('utf16le', i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString('base64', i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString('base64', i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed)
        return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : '';
    }
  }, {"safe-buffer": 56}],
  59: [function(require, module, exports) {
    (function(global) {
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config('noDeprecation')) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config('throwDeprecation')) {
              throw new Error(msg);
            } else if (config('traceDeprecation')) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!global.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val)
          return false;
        return String(val).toLowerCase() === 'true';
      }
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  60: [function(require, module, exports) {
    arguments[4][36][0].apply(exports, arguments);
  }, {"dup": 36}],
  61: [function(require, module, exports) {
    module.exports = function isBuffer(arg) {
      return arg && (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
    };
  }, {}],
  62: [function(require, module, exports) {
    (function(process, global) {
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x) {
          if (x === '%%')
            return '%';
          if (i >= len)
            return x;
          switch (x) {
            case '%s':
              return String(args[i++]);
            case '%d':
              return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (isUndefined(global.process)) {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        if (process.noDeprecation === true) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnviron;
      exports.debuglog = function(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = process.env.NODE_DEBUG || '';
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error('%s %d: %s', set, pid, msg);
            };
          } else {
            debugs[set] = function() {};
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        'bold': [1, 22],
        'italic': [3, 23],
        'underline': [4, 24],
        'inverse': [7, 27],
        'white': [37, 39],
        'grey': [90, 39],
        'black': [30, 39],
        'blue': [34, 39],
        'cyan': [36, 39],
        'green': [32, 39],
        'magenta': [35, 39],
        'red': [31, 39],
        'yellow': [33, 39]
      };
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        'regexp': 'red'
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = '',
            array = false,
            braces = ['{', '}'];
        if (isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }
        if (isFunction(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }
        if (isRegExp(value)) {
          base = ' ' + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = ' ' + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = ' ' + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber(value))
          return ctx.stylize('' + value, 'number');
        if (isBoolean(value))
          return ctx.stylize('' + value, 'boolean');
        if (isNull(value))
          return ctx.stylize('null', 'null');
      }
      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0,
            l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name,
            str,
            desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function(line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + str.split('\n').map(function(line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }
        return name + ': ' + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
        }
        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol';
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol' || typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require('./support/isBuffer');
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? '0' + n.toString(10) : n.toString(10);
      }
      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      function timestamp() {
        var d = new Date();
        var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      }
      exports.log = function() {
        console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require('inherits');
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./support/isBuffer": 61,
    "_process": 42,
    "inherits": 60
  }]
}, {}, [1, 2, 3, 12, 13, 14, 15, 16, 17, 18, 19, 20, 4, 5, 6, 7, 8, 9, 21, 10, 11, 22, 23, 24, 25, 26, 27, 28, 29]);
